---
title: "A practical guide for CMake"
date: "2022-05-06"
author: "erri120"
authorTwitter: "erri120"
tags: ["CMake", "C++"]
keywords: ["C++", "CMake"]
description: "CMake and buildsystems in general are very complex and often seem like magic. This post is for normal programmers who have no idea what is going on and just want to write code."
showFullContent: false
readingTime: false
draft: true
---

I hate CMake. Actually not just CMake, I hate the everything that gets in the way of programming. Almost every other language that was created after C++ does not have this problem. Due to how C++ came to be we now have a very fragmented ecosystem that consists of a million ways to create and manage your code. Not a million ways to write code but how to manage and compile it. The developer experience is horrible and the buildsystem is often the gatekeeper of C++ which is just pathetic and sad.

If you are still resolute on writing C++ and wanting to use CMake but have no idea what you are doing then this post is for you. I am not a CMake expert and this post is mainly a collection on tips and tricks for getting something to work. Throughout this post I will link to the [CMake documentation](https://cmake.org/cmake/help/latest/) which is more technical so take a look at that if you want.

## Requirements

- Compiler: [MSVC](https://visualstudio.microsoft.com/vs/features/cplusplus/), [GCC](https://gcc.gnu.org/), [Clang](https://clang.llvm.org/)
- IDE: [Visual Studio](https://visualstudio.microsoft.com/), [Visual Studio Code](https://code.visualstudio.com/) + [C++ Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) + [CMake Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools&ssr=false#overview), [CLion](https://www.jetbrains.com/clion/)
- [CMake](https://cmake.org/)

On Windows I highly suggest using Visual Studio. The CMake integration is relatively new but works great. If you are on Linux you can use either GCC or Clang as a compiler and VSCode or CLion as an IDE. I personally like working with Clang more than GCC but this is mainly because of [clangd](https://clangd.llvm.org/) which is a very good language server for VSCode and other IDEs.

Also some IDEs like Visual Studio and CLion bundle CMake so you don't have to install it separately.

## CMakeLists.txt

The `CMakeLists.txt` file is where you configure how your code is build and linked. Let's look a very simple example:

```cmake
cmake_minimum_required(VERSION 3.12)

project(
    "MyProject"
    VERSION 1.0.0
    DESCRIPTION "This is my very cool project."
    HOMEPAGE_URL "https://github.com/erri120/myproject"
    LANGUAGES CXX
)

add_executable(${PROJECT_NAME} "main.cpp")
```

In the first line we set the minimum required version of CMake using [`cmake_minimum_required`](https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html). You should always put this at the beginning of your `CMakeLists.txt` file so that CMake immediately exists if the version doesn't match.

Next we specify our project with the [`project`](https://cmake.org/cmake/help/latest/command/project.html#command:project) command. Here we can set some metadata like the name, version, a description the home URL for the project and what programming languages are needed to build the project. Everything except the project name is optional so you could just write this:

```cmake
project("MyProject")
```

CMake will issue a warning if you do not specify a project and it will pretend there is a `project(Project)` at the top of the file however it's better to be explicit and set it yourself.

Finally we get to [`add_executable`](https://cmake.org/cmake/help/latest/command/add_executable.html) where things start getting complex. In CMake you work with [targets](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#id15). Each target corresponds to an executable, library or a custom target. With `add_executable` we create a new target to an executable and give it a list of source files.

Now let us talk about [variables](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#cmake-language-variables). The `${PROJECT_NAME}` is a variable that was created my `project(...)`. In our case we specified the name, version, description and homepage URL so we have access to `PROJECT_NAME`, `PROJECT_VERSION`, `PROJECT_DESCRIPTION` and `PROJECT_HOMEPAGE_URL`.

These variables are extremely useful and will be used throughout this post so you can easily copy paste the code you find here. If you want to create your own variable you can just use the [`set`](https://cmake.org/cmake/help/latest/command/set.html) command:

```cmake
set(MyProjectSources "main.cpp")
add_executable(${PROJECT_NAME} ${MyProjectSources})
```

## Targets

As described earlier: each [target](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#id15) corresponds to an [executable](#executable), [library](#library) or a [custom target](#custom-target). In this section we will go in-depth on each type of target and look at some examples and advanced use-cases.

### Executable

The most simple target of them all:

```cmake
set(MyProjectSources "main.cpp")
add_executable(${PROJECT_NAME} ${MyProjectSources})
```

This target will create an executable like `${PROJECT_NAME}.exe` and will require a `main()` function somewhere in your code. If you are on Windows and your code does not use `main()` but `WinMain()` for whatever reason you can use the [`WIN32_EXECUTABLE`](https://cmake.org/cmake/help/latest/prop_tgt/WIN32_EXECUTABLE.html#prop_tgt:WIN32_EXECUTABLE) property:

```cmake
set(MyProjectSources "main.cpp")

# WIN32 will set the WIN32_EXECUTABLE property on the target
add_executable(${PROJECT_NAME} WIN32 ${MyProjectSources})
```

### Library

Executables are fun and all but maybe you want to create a library instead. This can be done by using [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html#command:add_library):

```cmake
set(MyProjectSources "mylib.h" "mylib.cpp")
add_library(${PROJECT_NAME} STATIC ${MyProjectSources})
```

The second argument of the command is the library type. The three types are `STATIC`, `SHARED` and `INTERFACE`. Let's start by comparing Static vs Shared and for that we need to talk about the linker:

During the build step you have 2 main "phases": compilation and linking. The compiler takes all your input files and creates machine code. The linker runs after the compiler and has the difficult job of combining all of that machine code, re-arranging code and creating the layout of the resulting file.

Let's use a simple example for this:

```c++
// in main.cpp:
#include "values.h"

int main() {
    return get_value();
}

// in values.h:
int get_value();

// in values.cpp:
int get_value() {
    return 42;
}
```

In this basic C++ example the most important part is the include statement. We have 2 files: `values.h` and `values.cpp` but we only include the header. The header holds the function definition but the implementation is in `values.cpp`. When the compiler processes `main.cpp` it will see that we include this header and use this function from the header so it will generate a call instruction to the function. The issue is that the compiler doesn't know "where" this function is.

The assembly call instruction looks something like this (on x86):

```asm
e8 00 00 00 00
```

The first byte is the type of the instruction, in our case it's a call instruction which has the value `e8`. The next 4 bytes are the address of the function we want to call. Our compiler generates this instruction with an address of `00 00 00 00` because it doesn't know where the function is in the resulting binary file. The linker is responsible for the layout of the file so only it knows where this function is.

The linker has always been this magical thing that sometimes throws an error with the weirdest messages you have ever seen but it plays a very important role when building your project. So what does this have to do with Static and Shared libraries?

When referencing a static library (`.lib` on Windows and `.a` on Linux), the entire library will be copied into the output and directly linked against it. This means that the output will be bigger than if you were to use a shared library.

When referencing a shared library (`.dll` on Windows and `.so` on Linux), the library will be loaded at runtime. This means the output only has a symbol table of things it needs to load and can dynamically load the library. The process of loading a library takes some time but the results are cached so it's not a big deal.

There are more points to this comparisons but in practice you should almost always use a shared library. If you want to know more about this topic I highly recommend this very technical talk by [Matt Godbolt](https://twitter.com/mattgodbolt) at CppCon:

{{< youtube dOfucXtyEsU >}}

#### Shared

```cmake
set(MyProjectSources "mylib.h" "mylib.cpp")
add_library(${PROJECT_NAME} SHARED ${MyProjectSources})
```

#### Static

```cmake
set(MyProjectSources "mylib.h" "mylib.cpp")
add_library(${PROJECT_NAME} STATIC ${MyProjectSources})`
```

#### Interface (header-only)

We have dealt with Static vs Shared but now for something very different:

```cmake
add_library(${PROJECT_NAME} INTERFACE "myheader.h")`
```

An `INTERFACE` library does not compile sources and does not produce a library artifact. The primary use-case is header-only libraries:

```cmake
add_library("mylib" INTERFACE "myheader.h")

add_executable("myexe" "main.cpp")
target_link_libraries("myexe" "mylib")
```

Header-only libraries are a bit weird. Often you find cool libraries on GitHub which just give you a single header file. This makes it very easy to add to our project however there are some problems like tangled and longer compilation. I don't really suggest creating your own header-only libs but if you have to use one this might be something for you.

### Custom Target and Command

Custom targets and commands are very useful for everything that is not an executable or a library but is still part of the build process. They are usually used when you need to generate some files or need to do something before or after a build:

```cmake
add_custom_command(
    OUTPUT output.txt
    COMMAND python ${CMAKE_CURRENT_SOURCE_DIR}/generate.py ${CMAKE_CURRENT_SOURCE_DIR}/input.txt
    COMMENT "Generates output.txt using input.txt"
    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/generate.py ${CMAKE_CURRENT_SOURCE_DIR}/input.txt
)

add_custom_target(
    "Generate" ALL
    DEPENDS output.txt
    SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/generate.py
)
```

In this example we create a new command using [`add_custom_command`](https://cmake.org/cmake/help/latest/command/add_custom_command.html#command:add_custom_command) and a new target with [`add_custom_target`](https://cmake.org/cmake/help/latest/command/add_custom_target.html#command:add_custom_target). The command will run a python script that takes some input `input.txt` and produces `output.txt`. The target depends on this `output.txt` so CMake will create a dependency and makes sure that when building this target the command is executed and the required file is generated.

CMake is smart enough to see the connection between the target and the command but the target doesn't have to be a custom target. You could have a dependency between an executable or library and a command by marking one of the sources of the target as the output of the command:

```cmake
add_custom_command(
  OUTPUT out.c
  COMMAND cp ${CMAKE_CURRENT_SOURCE_DIR}/in.c out.c
  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/in.c
)

add_library(myLib out.c)
```

If you do any code generation then this is what you want. CMake sees the dependency between the source `out.c` which is the output of the custom command so now whenever the depending files of the command change, the command will be re-run and the output is re-generated.

The last use-case of custom commands is running some command before or after a build:

```cmake
add_executable(myExe main.cpp)

add_custom_command(
  TARGET myExe POST_BUILD
  COMMAND cp "$<TARGET_FILE:myExe>" "$<TARGET_FILE:myExe>.copy"
)
```

In this useless example the command will create a copy of the output executable post-build.

## Dependencies

We have now arrived at the biggest gatekeeper of the C++ community: dealing with dependencies. In this post I will use [vcpkg](https://vcpkg.io/en/index.html) which I highly recommend but there are alternatives like [Conan](https://conan.io/) and [CPM](https://github.com/cpm-cmake/CPM.cmake).

After you have installed vcpkg and configured your IDE to use it you can create a `vcpkg.json` file at the root of your project and start declaring some dependencies:

```json
{
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
  "name": "my-project",
  "version": "1.0.0",
  "dependencies": [
    "fmt"
  ]
}
```

And in our `CMakeLists.txt` file we now have to add the library:

```cmake
find_package(fmt CONFIG REQUIRED)
target_link_libraries(${PROJECT_NAME} PRIVATE fmt::fmt)
```

If you have configured everything correctly, vcpkg will run before build, look at the `vcpkg.json` file, download the dependencies listed and then we use [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html) to find the library.

The `find_package` command has 2 modes, Module and Config mode which look different files:

- Module mode
  - `Find<PackageName>.cmake`.
- Config mode
  - `<lowercasePackageName>-config.cmake`
  - `<PackageName>Config.cmake`
  - `<lowercasePackageName>-config-version.cmake`
  - `<PackageName>ConfigVersion.cmake`

Much more important that what files these modes look for is where they search. Module mode is usually intended to be used if the `File<PackageName>.cmake` file is inside your project:

```txt
CMakeLists.txt
cmake/FindFoo.cmake
```

```cmake
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake/FindFoo.cmake")
find_package(Foo REQUIRED)
```

In Module mode CMake will look in `CMAKE_MODULE_PATH` and try to find the file so you should append to this variable if the `.cmake` file is inside your project. Config mode is much more complicated and has a ton of rules you can find in the [documentation](https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure).

If you use vcpkg or another package manager you will very likely want to use the config mode. In our case with vcpkg and the [fmt](https://github.com/fmtlib/fmt) library we want to use the Config mode and CMake will find the `.cmake` file at `[vcpkg_root]/installed/<triplet>/share/fmt/fmt-config.cmake`. In the same folder you can also find `fmt-targets.cmake` which contains all the targets you can use which is very useful in case you forget.

Now regardless of which mode you used, the `find_package` command will create a lot variables you can use like `<PackageName>_FOUND` to check if we found the `.cmake` file. Note that CMake will error out if you used the `REQUIRED` option so this is only useful for _optional_ libraries.

Sadly there is no definitive list of variables you can use. Sometimes you get `<PackageName>_INCLUDE_DIRS` and `<PackageName>_LIBRARIES` or `<PackageName>_LIBRARY` like this:

```cmake
find_package(Intl REQUIRED)
target_link_libraries(${PROJECT_NAME} PUBLIC ${Intl_LIBRARY})
target_include_directories(${PROJECT_NAME} PUBLIC ${Intl_INCLUDE_DIRS})
```

You will likely have to check the `.cmake` file which is another pain point of dependency management.

Now let us talk about the [`target_link_libraries`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html) and [`target_include_directories`](https://cmake.org/cmake/help/latest/command/target_include_directories.html) commands seen before.

With `target_link_libraries` we can tell the linker to also use these libraries. We can actually use a lot of different values as our "libraries":

- library target name specified with `add_library` or imported using `find_package`
- full path to a library file: `C:\\libs\\CoolLibrary.dll`
- plain library name, this is only useful for Linux if you want to link against `pthreads` which becomes `-lpthreads` for GCC

For your daily coding adventures I highly discourage you from using a full path to a library and just use a library target name.

`target_include_directories` is exactly what it sounds like, if you have a folder `includes` and you want to include everything in it you use this command:

```cmake
target_include_directories(${PROJECT_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)
```

Now you might be wondering about that `PUBLIC` option. In fact you can use either `PUBLIC`, `PRIVATE` and `INTERFACE` for every item:

```cmake
target_include_directories(<target>
    INTERFACE <include_path_1> <include_path_2> <include_path_3>
    PUBLIC <include_path_4> <include_path_5> <include_path_6>
    PRIVATE <include_path_7> <include_path_8> <include_path_9>
)
```

But what does this mean? Similar to C++ where you have `public`, `private` and `protected` keywords, these 3 options specify the _visibility_ of the target property:

- `PRIVATE`: only visible to the current target
- `PUBLIC`: only visible to the current target and targets that link against it
- `INTERFACE`: only for usage by other libraries (if your library is of type `INTERFACE` then you need to use this)

Let's say you have a library where you want to expose which headers are visible to other projects that use it. You might have some _public_ headers and some _private_ headers. This is the visibility you can set in CMake.

I highly recommend reading the post [Modern CMake is like inheritance](https://kubasejdak.com/modern-cmake-is-like-inheritance) by [Kuba Sejdak](https://twitter.com/kubasejdak) if you want more information on this topic.

## Understanding install()

So far we have looked at the configure and build steps of CMake but there is another one: [`cmake --install`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#install-a-project).

Let's look at a simple executable:

```cmake
add_executable(${PROJECT_NAME} main.cpp)
install(
    TARGETS ${PROJECT_NAME}
    RUNTIME
    DESTINATION bin
)
```

If you run the CMake build then it will build the executable and the files will end up in the build directory. With the [`install`](https://cmake.org/cmake/help/latest/command/install.html) command we can specify how our project is to be _installed_. The terminology is sadly a bit misleading. When talking about _installing_ with CMake we are mostly talking about copying your build files somewhere else. If we run `cmake --install` with the example above the executable will be copied to the `bin` folder inside your install directory. Let's go through all options specified:

- `TARGETS` sets the targets to be installed
- `RUNTIME` specifies which _Output Artifacts_ are to be installed, in this case we want executables
- `DESTINATION` sets the output folder where the files end up

### Creating CMake Package Configuration Files

https://cmake.org/cmake/help/book/mastering-cmake/chapter/Finding%20Packages.html#creating-cmake-package-configuration-files

## Multiple CMakeLists.txt files

TODO

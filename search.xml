<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo+NexT</title>
    <url>/2020/12/08/Hexo-NexT/</url>
    <content><![CDATA[<p>Look at this beautiful blog site made with <a href="https://www.hexo.io/">Hexo</a> and the <a href="https://theme-next.js.org/">NexT</a> theme!</p>
]]></content>
  </entry>
  <entry>
    <title>Creating a GitHub Actions Release Pipeline for .NET Core 3.1/.NET 5</title>
    <url>/2020/12/19/Creating-a-GitHub-Actions-Release-Pipeline-for-NET-Core-3-1-NET-5/</url>
    <content><![CDATA[<p>GitHub Actions Release Workflows can be very tricky to set up and require a lot of experimenting to get right. Your project will also likely have something unique about it which means you need a workflow that is tailored to your project. This being said, the workflow we will set up, builds a .NET Core project for multiple runtimes (Linux and Windows for multiple architectures), compresses all of the builds into zip files and then creates a new GitHub Release with a changelog.</p>
<h2 id="Step-by-Step"><a href="#Step-by-Step" class="headerlink" title="Step by Step"></a>Step by Step</h2><p>Before we begin I want to encourage you to create a test repository with some dummy projects before implementing this in your actual repository. Using a test repo will keep your commit log clean and makes the entire process easier and faster as you don’t have to wait for your massive project to build.</p>
<p>Now that you have created a dummy repository, head over to the Actions tab and create a new blank workflow.</p>
<h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>There are multiple different triggers that you can use (see <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/events-that-trigger-workflows">GitHub Actions Reference</a>) but we want to use the <code>push</code> trigger, specifically the push trigger for tags:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Create</span> <span class="string">Release</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;v*&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>on push</code> would normally run whenever we push a commit to the repository but we can specify a filter so that we only trigger this workflow when we push a tag that starts with <code>v</code>. You can create and push a tag locally with git using <code>git tag &lt;tag_name&gt;</code> and then <code>git push origin --tags</code>. Alternatively you can also create a GitHub Release manually which will create a tag for you.</p>
<h3 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h3><p>I recommend using environment variables for stuff like SDK Version or configuration, this makes the workflow very easy to configure further down the line and easy to copy and paste into different repositories without having to change a ton of lines.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">PROJECT_FOLDER:</span> <span class="string">FunWithGithubActions</span></span><br><span class="line">  <span class="attr">PROJECT_FILE:</span> <span class="string">FunWithGithubActions/FunWithGithubActions.csproj</span></span><br><span class="line">  <span class="attr">PROJECT_PREFIX:</span> <span class="string">&quot;Fun With GitHub Actions&quot;</span></span><br><span class="line">  <span class="attr">DOTNET_SDK_VERSION:</span> <span class="string">&quot;3.1.x&quot;</span></span><br><span class="line">  <span class="attr">FRAMEWORK:</span> <span class="string">netcoreapp3.1</span></span><br><span class="line">  <span class="attr">CONFIGURATION:</span> <span class="string">Release</span></span><br></pre></td></tr></table></figure>
<p>Here we want SDK <code>3.1.x</code> because the project uses <code>netcoreapp3.1</code>. If you are targeting <code>net5</code> then you want <code>DOTNET_SDK_VERSION: &quot;5.0.x&quot;</code>.</p>
<h3 id="Checkout-and-SDK-Setup"><a href="#Checkout-and-SDK-Setup" class="headerlink" title="Checkout and SDK Setup"></a>Checkout and SDK Setup</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">.NET</span> <span class="string">Core</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-dotnet@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">dotnet-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DOTNET_SDK_VERSION</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Verify</span> <span class="string">.NET</span> <span class="string">Core</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">dotnet</span> <span class="string">--info</span></span><br></pre></td></tr></table></figure>
<p>Nothing special here, we are just doing a checkout and setting up .NET for the specific SDK Version. You could skip the verification of .NET but this is just to be 100% sure it installed correctly and if something goes wrong then we can always check the log file and see the exact information about the installed .NET SDK.</p>
<p>I recommend using <code>ubuntu-latest</code> instead of <code>windows-latest</code> because everything from setting up the SDK to building and even testing is faster on Ubuntu than on Windows.</p>
<h3 id="Building-for-multiple-Runtimes"><a href="#Building-for-multiple-Runtimes" class="headerlink" title="Building for multiple Runtimes"></a>Building for multiple Runtimes</h3><p>The main problem with targeting multiple runtimes when dealing with release workflows is figuring out a way to not repeat yourself. Since we want to do the same thing (<code>dotnet restore</code>, <code>dotnet publish</code> and then compressing) for every runtime we can just use a simple bash script that goes over an array of runtimes:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Building</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">VARIANTS:</span> <span class="string">linux-arm</span> <span class="string">linux-arm64</span> <span class="string">linux-x64</span> <span class="string">win-x64</span> <span class="string">win-x86</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">bash</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">set</span> <span class="string">-eu</span></span><br><span class="line"></span><br><span class="line">    <span class="string">publish()</span> &#123;</span><br><span class="line">      <span class="comment">#TODO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">for</span> <span class="string">variant</span> <span class="string">in</span> <span class="string">$VARIANTS;</span> <span class="string">do</span></span><br><span class="line">        <span class="string">publish</span> <span class="string">&quot;$variant&quot;</span></span><br><span class="line">    <span class="string">done</span></span><br></pre></td></tr></table></figure>
<p>The general idea is to have an array of Runtimes in the Environment Variable <code>VARIANTS</code> of the step so we can loop over all the variants and call <code>publish</code> on each one.</p>
<p>In publish we will restore the dependencies using <code>dotnet restore</code> and then use <code>dotnet publish</code> to publish the project to a folder:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">publish</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Building for runtime <span class="variable">$&#123;1&#125;</span>&quot;</span></span><br><span class="line">  rm -rf <span class="string">&quot;<span class="variable">$&#123;PROJECT_FOLDER&#125;</span>/bin&quot;</span></span><br><span class="line">  rm -rf <span class="string">&quot;<span class="variable">$&#123;PROJECT_FOLDER&#125;</span>/obj&quot;</span></span><br><span class="line">  dotnet restore <span class="string">&quot;<span class="variable">$&#123;PROJECT_FILE&#125;</span>&quot;</span> -r <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span></span><br><span class="line">  dotnet publish <span class="string">&quot;<span class="variable">$&#123;PROJECT_FILE&#125;</span>&quot;</span> -c <span class="string">&quot;<span class="variable">$&#123;CONFIGURATION&#125;</span>&quot;</span> -f <span class="string">&quot;<span class="variable">$&#123;FRAMEWORK&#125;</span>&quot;</span> -o <span class="string">&quot;out/<span class="variable">$&#123;1&#125;</span>&quot;</span> -r <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> -p:PublishSingleFile=<span class="literal">true</span> -p:PublishTrimmed=<span class="literal">true</span> --no-restore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can see that we make heavy use of the environment variables we previously declared which keeps this code clean and reuseable. Going over some arguments for the <code>dotnet</code> commands, we supply the path the project, set the configuration and framework and publish the project for runtime <code>-r &quot;$&#123;1&#125;&quot;</code> to the folder <code>-o &quot;out/$&#123;1&#125;&quot;</code>. The arguments <code>-p:PublishSingleFile=true</code> and <code>-p:PublishTrimmed=true</code> are optional, I recommend reading up on those in the docs: <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish">dotnet publish</a> and deciding if you want to use them or not. The <code>--no-restore</code> makes sure that <code>dotnet publish</code> does not restore the dependencies. I added an explicit <code>dotnet restore</code> call before because <code>dotnet publish</code> did not successfully restore all dependencies.</p>
<p>Since we build the project multiple times, I recommend cleaning up the output directory before each build. I have run into some issues before when building for different runtimes without cleaning the output directory so a simple command will prevent that from happening again.</p>
<p>The remaining step to do in our script is compressing the files to an archive using <code>7z</code> or <code>zip</code>, depending on what is available:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span> -v 7z &gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    7z a -bd -slp -tzip -mm=Deflate -mx=1 <span class="string">&quot;out/<span class="variable">$&#123;PROJECT_PREFIX&#125;</span>-<span class="variable">$&#123;1&#125;</span>.zip&quot;</span> <span class="string">&quot;<span class="variable">$&#123;GITHUB_WORKSPACE&#125;</span>/out/<span class="variable">$&#123;1&#125;</span>/*&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">command</span> -v zip &gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    (</span><br><span class="line">        <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;GITHUB_WORKSPACE&#125;</span>/out/<span class="variable">$&#123;1&#125;</span>&quot;</span></span><br><span class="line">        zip -1 -q -r <span class="string">&quot;../<span class="variable">$&#123;PROJECT_PREFIX&#125;</span>-<span class="variable">$&#123;1&#125;</span>.zip&quot;</span> .</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;ERROR: No supported zip tool!&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>With this our little bash script is complete:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -eu</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">publish</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Building for runtime <span class="variable">$&#123;1&#125;</span>&quot;</span></span><br><span class="line">  rm -rf <span class="string">&quot;<span class="variable">$&#123;PROJECT_FOLDER&#125;</span>/bin&quot;</span></span><br><span class="line">  rm -rf <span class="string">&quot;<span class="variable">$&#123;PROJECT_FOLDER&#125;</span>/obj&quot;</span></span><br><span class="line">  dotnet restore <span class="string">&quot;<span class="variable">$&#123;PROJECT_FILE&#125;</span>&quot;</span> -r <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span></span><br><span class="line">  dotnet publish <span class="string">&quot;<span class="variable">$&#123;PROJECT_FILE&#125;</span>&quot;</span> -c <span class="string">&quot;<span class="variable">$&#123;CONFIGURATION&#125;</span>&quot;</span> -f <span class="string">&quot;<span class="variable">$&#123;FRAMEWORK&#125;</span>&quot;</span> -o <span class="string">&quot;out/<span class="variable">$&#123;1&#125;</span>&quot;</span> -r <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> -p:PublishSingleFile=<span class="literal">true</span> -p:PublishTrimmed=<span class="literal">true</span> --no-restore</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">command</span> -v 7z &gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">      7z a -bd -slp -tzip -mm=Deflate -mx=1 <span class="string">&quot;out/<span class="variable">$&#123;PROJECT_PREFIX&#125;</span>-<span class="variable">$&#123;1&#125;</span>.zip&quot;</span> <span class="string">&quot;<span class="variable">$&#123;GITHUB_WORKSPACE&#125;</span>/out/<span class="variable">$&#123;1&#125;</span>/*&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> <span class="built_in">command</span> -v zip &gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">      (</span><br><span class="line">          <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;GITHUB_WORKSPACE&#125;</span>/out/<span class="variable">$&#123;1&#125;</span>&quot;</span></span><br><span class="line">          zip -1 -q -r <span class="string">&quot;../<span class="variable">$&#123;PROJECT_PREFIX&#125;</span>-<span class="variable">$&#123;1&#125;</span>.zip&quot;</span> .</span><br><span class="line">      )</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;ERROR: No supported zip tool!&quot;</span></span><br><span class="line">      <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> variant <span class="keyword">in</span> <span class="variable">$VARIANTS</span>; <span class="keyword">do</span></span><br><span class="line">    publish <span class="string">&quot;<span class="variable">$variant</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="Changelog-and-Versioning"><a href="#Changelog-and-Versioning" class="headerlink" title="Changelog and Versioning"></a>Changelog and Versioning</h3><p>The reason we are doing all of this is because we are lazy and don’t want to do tedious and repetitive tasks. Following this trend we are going to use <a href="https://github.com/mindsers/changelog-reader-action">Changelog Reader</a> to read the Changelog from our Changelog file and use it in our GitHub Release.</p>
<p><strong>This action only works if your Changelog file follows the <a href="https://github.com/olivierlacan/keep-a-changelog">Keep a Changelog</a> standard.</strong></p>
<p>This means your <code>CHANGELOG.md</code> should look something like this (see <a href="https://github.com/olivierlacan/keep-a-changelog">Keep a Changelog</a> for more information):</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Changelog</span></span><br><span class="line"></span><br><span class="line"><span class="section">## [Unreleased]</span></span><br><span class="line"></span><br><span class="line"><span class="section">## [1.0.0] - 2020-12-19</span></span><br><span class="line"></span><br><span class="line"><span class="section">### Added</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Added something</span><br><span class="line"></span><br><span class="line"><span class="section">### Fixed</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Fixed something</span><br></pre></td></tr></table></figure>
<h4 id="Getting-the-Current-Version"><a href="#Getting-the-Current-Version" class="headerlink" title="Getting the Current Version"></a>Getting the Current Version</h4><p>Lets start by getting the current version with another simple bash script:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">version</span> <span class="string">from</span> <span class="string">tag</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">tag_name</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">bash</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">echo</span> <span class="string">::set-output</span> <span class="string">name=current_version::$&#123;GITHUB_REF#refs/tags/v&#125;</span></span><br></pre></td></tr></table></figure>
<p>You can get the output of a step in GitHub Actions using <code>$&#123;&#123; steps.<step id>.outputs &#125;&#125;</code> (see <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/context-and-expression-syntax-for-github-actions#steps-context">GitHub Actions Reference</a>) and we can set the output in a bash script with <code>echo ::set-output</code>.</p>
<h4 id="Setting-the-Project-Version"><a href="#Setting-the-Project-Version" class="headerlink" title="Setting the Project Version"></a>Setting the Project Version</h4><p>Now that we have the current Version of the Release we can actually forward it to <code>dotnet publish</code> by adding <code>PUBLISH_VERSION: $&#123;&#123; steps.tag_name.outputs.current_version &#125;&#125;</code> to the <code>Building</code> job Environment Variables and adding <code>-p:Version=&quot;$&#123;PUBLISH_VERSION&#125;&quot;</code> to <code>dotnet publish</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Building</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">VARIANTS:</span> <span class="string">linux-arm</span> <span class="string">linux-arm64</span> <span class="string">linux-x64</span> <span class="string">win-x64</span> <span class="string">win-x86</span></span><br><span class="line">    <span class="attr">PUBLISH_VERSION:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.tag_name.outputs.current_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">bash</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">      <span class="comment">#...</span></span><br><span class="line">      <span class="string">dotnet</span> <span class="string">publish</span> <span class="string">&quot;$&#123;PROJECT_FILE&#125;&quot;</span> <span class="string">-c</span> <span class="string">&quot;$&#123;CONFIGURATION&#125;&quot;</span> <span class="string">-f</span> <span class="string">&quot;$&#123;FRAMEWORK&#125;&quot;</span> <span class="string">-o</span> <span class="string">&quot;out/$&#123;1&#125;&quot;</span> <span class="string">-r</span> <span class="string">&quot;$&#123;1&#125;&quot;</span> <span class="string">-p:PublishSingleFile=true</span> <span class="string">-p:PublishTrimmed=true</span> <span class="string">-p:Version=&quot;$&#123;PUBLISH_VERSION&#125;&quot;</span> <span class="string">--no-restore</span></span><br><span class="line">      <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>Forwarding the Version with <code>-p:Version</code> will set the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.fileversioninfo.fileversion?view=net-5.0"><code>FileVersion</code></a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.fileversioninfo.productversion?view=net-5.0"><code>ProductVersion</code></a> of the output executable so we don’t have to spend a commit on version bumping.</p>
<h4 id="Getting-the-current-Changelog"><a href="#Getting-the-current-Changelog" class="headerlink" title="Getting the current Changelog"></a>Getting the current Changelog</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">Changelog</span> <span class="string">Entry</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">changelog_reader</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">mindsers/changelog-reader-action@v2</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.tag_name.outputs.current_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./CHANGELOG.md</span></span><br></pre></td></tr></table></figure>
<p>We are again using the output of our little bash script to get the Changelog. This action also has some outputs we will later use when creating the release.</p>
<h3 id="Creating-a-Release"><a href="#Creating-a-Release" class="headerlink" title="Creating a Release"></a>Creating a Release</h3><p>Now we are finally ready to create a new GitHub Release using the <a href="https://github.com/actions/create-release"><code>create-release</code></a> action.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Release</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">create_release</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/create-release@v1</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span> <span class="comment"># This token is provided by Actions, you do not need to create your own token</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">tag_name:</span> <span class="string">v$&#123;&#123;</span> <span class="string">steps.changelog_reader.outputs.version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">release_name:</span> <span class="string">Release</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.changelog_reader.outputs.version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">body:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.changelog_reader.outputs.changes</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">draft:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.changelog_reader.outputs.status</span> <span class="string">==</span> <span class="string">&#x27;unreleased&#x27;</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">prerelease:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.changelog_reader.outputs.status</span> <span class="string">==</span> <span class="string">&#x27;prereleased&#x27;</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>As you can see, we are only using variables for this action as everything is provided by the <code>changelog_reader</code> step.</p>
<h3 id="Uploading-Files"><a href="#Uploading-Files" class="headerlink" title="Uploading Files"></a>Uploading Files</h3><p>I hope you didn’t forget about this step. We created a release and can use the <code>upload_url</code> output to upload our archives to GitHub:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">Release</span> <span class="string">Assets</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">upload_release_assets</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">NBTX/upload-release-assets@v1</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">upload_url:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.create_release.outputs.upload_url</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">targets:</span> <span class="string">&quot;out/$<span class="template-variable">&#123;&#123; env.PROJECT_PREFIX &#125;&#125;</span>-*.*&quot;</span></span><br></pre></td></tr></table></figure>
<p>I’m using <a href="https://github.com/NBTX/upload-release-assets">NBTX/upload-release-assets</a> instead of <a href="https://github.com/actions/upload-release-asset">upload-release-asset</a> because it uses glob matching to upload multiple files instead of just one.</p>
<h2 id="Complete-File"><a href="#Complete-File" class="headerlink" title="Complete File"></a>Complete File</h2><p>You can view the entire <a href="https://github.com/erri120/fun-with-github-actions/blob/master/.github/workflows/release.yml"><code>release.yml</code></a> file on my <a href="https://github.com/erri120/fun-with-github-actions">Fun with GitHub Actions</a> repository or below.</p>
<pre><code class="yaml">name: Create Release

on:
  push:
    tags: 
      - &#39;v*&#39;

env:
  PROJECT_FOLDER: FunWithGithubActions
  PROJECT_FILE: FunWithGithubActions/FunWithGithubActions.csproj
  PROJECT_PREFIX: &quot;Fun With GitHub Actions&quot;
  DOTNET_SDK_VERSION: &quot;3.1.x&quot;
  FRAMEWORK: netcoreapp3.1
  CONFIGURATION: Release

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Get version from tag
      id: tag_name
      shell: bash
      run: |
        echo ::set-output name=current_version::${GITHUB_REF#refs/tags/v}

    - uses: actions/checkout@v2

    - name: Setup .NET Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}

    - name: Verify .NET Core
      run: dotnet --info

    - name: Building
      env:
        VARIANTS: linux-arm linux-arm64 linux-x64 win-x64 win-x86
        PUBLISH_VERSION: ${{ steps.tag_name.outputs.current_version }}
      shell: bash
      run: |
        set -eu

        publish() {
          echo &quot;Building for runtime ${1}&quot;
          rm -rf &quot;${PROJECT_FOLDER}/bin&quot;
          rm -rf &quot;${PROJECT_FOLDER}/obj&quot;
          dotnet restore &quot;${PROJECT_FILE}&quot; -r &quot;${1}&quot;
          dotnet publish &quot;${PROJECT_FILE}&quot; -c &quot;${CONFIGURATION}&quot; -f &quot;${FRAMEWORK}&quot; -o &quot;out/${1}&quot; -r &quot;${1}&quot; -p:PublishSingleFile=true -p:PublishTrimmed=true -p:Version=&quot;${PUBLISH_VERSION}&quot; --no-restore

          if command -v 7z &gt;/dev/null; then
              7z a -bd -slp -tzip -mm=Deflate -mx=1 &quot;out/${PROJECT_PREFIX}-${1}.zip&quot; &quot;${GITHUB_WORKSPACE}/out/${1}/*&quot;
          elif command -v zip &gt;/dev/null; then
              (
                  cd &quot;${GITHUB_WORKSPACE}/out/${1}&quot;
                  zip -1 -q -r &quot;../${PROJECT_PREFIX}-${1}.zip&quot; .
              )
          else
              echo &quot;ERROR: No supported zip tool!&quot;
              return 1
          fi
        }

        for variant in $VARIANTS; do
            publish &quot;$variant&quot;
        done

    #- name: Upload Artifact
    #  uses: actions/upload-artifact@v2
    #  with:
    #    path: &quot;out/${{ env.PROJECT_PREFIX }}-*.zip&quot;

    - name: Get Changelog Entry
      id: changelog_reader
      uses: mindsers/changelog-reader-action@v2
      with:
        version: ${{ steps.tag_name.outputs.current_version }}
        path: ./CHANGELOG.md

    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
      with:
        tag_name: v${{ steps.changelog_reader.outputs.version }}
        release_name: Release ${{ steps.changelog_reader.outputs.version }}
        body: ${{ steps.changelog_reader.outputs.changes }}
        draft: ${{ steps.changelog_reader.outputs.status == &#39;unreleased&#39; }}
        prerelease: ${{ steps.changelog_reader.outputs.status == &#39;prereleased&#39; }}

    - name: Upload Release Assets
      id: upload_release_assets
      uses: NBTX/upload-release-assets@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        targets: &quot;out/${{ env.PROJECT_PREFIX }}-*.*&quot;
</code></pre>

]]></content>
      <categories>
        <category>GitHub Actions</category>
        <category>Release Pipelines</category>
      </categories>
      <tags>
        <tag>GitHub Actions</tag>
        <tag>Release Pipelines</tag>
        <tag>.NET</tag>
        <tag>.NET Core 3.1</tag>
        <tag>.NET 5</tag>
      </tags>
  </entry>
  <entry>
    <title>Image Steganography in Koikatsu! and AI Shoujo</title>
    <url>/2021/01/27/Image-Steganography-in-Koikatsu-and-AI-Shoujo/</url>
    <content><![CDATA[<p>Image Steganography is nothing new or groundbreaking, steganography has been around since <a href="https://en.wikipedia.org/wiki/Steganography#History">440 BC</a> and digital steganography started appearing once personal computers became a thing. This post is about the method used in games by <a href="http://www.illusion.jp/">イリュージョン</a> (Illusion) like コイカツ！ (Koikatsu!) or AI 少女 (AI Shoujo).</p>
<h2 id="Character-Presets-in-Illusion-Games"><a href="#Character-Presets-in-Illusion-Games" class="headerlink" title="Character Presets in Illusion Games"></a>Character Presets in Illusion Games</h2><p>In most Illusion Games you have an extensive editor for designing the appearance of your character or of characters that are later found in the game world. The preset is stored as a PNG like this one:</p>
<p><img src="/2021/01/27/Image-Steganography-in-Koikatsu-and-AI-Shoujo/Mona.png" alt="mona-preset"></p>
<p>Opening this image in a hex editor like <a href="https://mh-nexus.de/en/hxd/">HxD</a> you will find your normal PNG data but at the end of the file after the end-marker <code>IEND</code> you have the actual preset data:</p>
<p><img src="/2021/01/27/Image-Steganography-in-Koikatsu-and-AI-Shoujo/preset-in-hxd.png" alt="preset-in-hxd"></p>
<h2 id="Why-this-works"><a href="#Why-this-works" class="headerlink" title="Why this works"></a>Why this works</h2><p>The reason this works is because the PNG file format has a clear structure with indicators for start and end:</p>
<p><a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics#Examples"><img src="/2021/01/27/Image-Steganography-in-Koikatsu-and-AI-Shoujo/wikipedia-png-structure.png" alt="wikipedia-png-structure"></a></p>
<p>A PNG parser will never read beyond <code>IEND</code> so the preset data won’t be read. You could also use JPEG for this because it also has an End Of Image (EOI) marker (<code>0xFF</code>, <code>0xD9</code>) and append the preset at the end:</p>
<p><img src="/2021/01/27/Image-Steganography-in-Koikatsu-and-AI-Shoujo/Mona.jpg" alt="mona-preset-jpeg"></p>
<p><img src="/2021/01/27/Image-Steganography-in-Koikatsu-and-AI-Shoujo/jpeg-preset-in-hxd.png" alt="jpeg-preset-in-hxd"></p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>While it might seem very trivial and gimmicky at first, it has been implemented across multiple games and editors and provides a very easy way to share presets with others. Not only can you share character presets in Illusion games, you can also share entire scenes, outfits, textures, materials and more with this method. The community discord for those games is has very active share channels where you simply upload the png and be done with it. No need for an external site or additional files because everything is hidden in the image.</p>
]]></content>
      <categories>
        <category>Game Development</category>
        <category>Random Stuff</category>
      </categories>
      <tags>
        <tag>Koikatsu!/コイカツ！</tag>
        <tag>AI Shoujo/AI 少女</tag>
      </tags>
  </entry>
</search>

[{"content":"Day 11 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 11: Monkey in the Middle Links: Puzzle Page, My Code\nPart One Description As you finally start making your way upriver, you realize your pack is much lighter than you remember. Just then, one of the items from your pack goes flying overhead. Monkeys are playing Keep Away with your missing things!\nTo get your stuff back, you need to be able to predict where the monkeys will throw your items. After some careful observation, you realize the monkeys operate based on how worried you are about each item.\nYou take some notes (your puzzle input) on the items each monkey currently has, how worried you are about those items, and how the monkey makes decisions based on your worry level. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Monkey 0: Starting items: 79, 98 Operation: new = old * 19 Test: divisible by 23 If true: throw to monkey 2 If false: throw to monkey 3 Monkey 1: Starting items: 54, 65, 75, 74 Operation: new = old + 6 Test: divisible by 19 If true: throw to monkey 2 If false: throw to monkey 0 Monkey 2: Starting items: 79, 60, 97 Operation: new = old * old Test: divisible by 13 If true: throw to monkey 1 If false: throw to monkey 3 Monkey 3: Starting items: 74 Operation: new = old + 3 Test: divisible by 17 If true: throw to monkey 0 If false: throw to monkey 1 Each monkey has several attributes:\nStarting items lists your worry level for each item the monkey is currently holding in the order they will be inspected. Operation shows how your worry level changes as that monkey inspects an item. (An operation like new = old * 5 means that your worry level after the monkey inspected the item is five times whatever your worry level was before inspection.) Test shows how the monkey uses your worry level to decide where to throw an item next. If true shows what happens with an item if the Test was true. If false shows what happens with an item if the Test was false. After each monkey inspects an item but before it tests your worry level, your relief that the monkey\u0026rsquo;s inspection didn\u0026rsquo;t damage the item causes your worry level to be divided by three and rounded down to the nearest integer.\nThe monkeys take turns inspecting and throwing items. On a single monkey\u0026rsquo;s turn, it inspects and throws all of the items it is holding one at a time and in the order listed. Monkey 0 goes first, then monkey 1, and so on until each monkey has had one turn. The process of each monkey taking a single turn is called a round.\nWhen a monkey throws an item to another monkey, the item goes on the end of the recipient monkey\u0026rsquo;s list. A monkey that starts a round with no items could end up inspecting and throwing many items by the time its turn comes around. If a monkey is holding no items at the start of its turn, its turn ends.\nIn the above example, the first round proceeds as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 Monkey 0: Monkey inspects an item with a worry level of 79. Worry level is multiplied by 19 to 1501. Monkey gets bored with item. Worry level is divided by 3 to 500. Current worry level is not divisible by 23. Item with worry level 500 is thrown to monkey 3. Monkey inspects an item with a worry level of 98. Worry level is multiplied by 19 to 1862. Monkey gets bored with item. Worry level is divided by 3 to 620. Current worry level is not divisible by 23. Item with worry level 620 is thrown to monkey 3. Monkey 1: Monkey inspects an item with a worry level of 54. Worry level increases by 6 to 60. Monkey gets bored with item. Worry level is divided by 3 to 20. Current worry level is not divisible by 19. Item with worry level 20 is thrown to monkey 0. Monkey inspects an item with a worry level of 65. Worry level increases by 6 to 71. Monkey gets bored with item. Worry level is divided by 3 to 23. Current worry level is not divisible by 19. Item with worry level 23 is thrown to monkey 0. Monkey inspects an item with a worry level of 75. Worry level increases by 6 to 81. Monkey gets bored with item. Worry level is divided by 3 to 27. Current worry level is not divisible by 19. Item with worry level 27 is thrown to monkey 0. Monkey inspects an item with a worry level of 74. Worry level increases by 6 to 80. Monkey gets bored with item. Worry level is divided by 3 to 26. Current worry level is not divisible by 19. Item with worry level 26 is thrown to monkey 0. Monkey 2: Monkey inspects an item with a worry level of 79. Worry level is multiplied by itself to 6241. Monkey gets bored with item. Worry level is divided by 3 to 2080. Current worry level is divisible by 13. Item with worry level 2080 is thrown to monkey 1. Monkey inspects an item with a worry level of 60. Worry level is multiplied by itself to 3600. Monkey gets bored with item. Worry level is divided by 3 to 1200. Current worry level is not divisible by 13. Item with worry level 1200 is thrown to monkey 3. Monkey inspects an item with a worry level of 97. Worry level is multiplied by itself to 9409. Monkey gets bored with item. Worry level is divided by 3 to 3136. Current worry level is not divisible by 13. Item with worry level 3136 is thrown to monkey 3. Monkey 3: Monkey inspects an item with a worry level of 74. Worry level increases by 3 to 77. Monkey gets bored with item. Worry level is divided by 3 to 25. Current worry level is not divisible by 17. Item with worry level 25 is thrown to monkey 1. Monkey inspects an item with a worry level of 500. Worry level increases by 3 to 503. Monkey gets bored with item. Worry level is divided by 3 to 167. Current worry level is not divisible by 17. Item with worry level 167 is thrown to monkey 1. Monkey inspects an item with a worry level of 620. Worry level increases by 3 to 623. Monkey gets bored with item. Worry level is divided by 3 to 207. Current worry level is not divisible by 17. Item with worry level 207 is thrown to monkey 1. Monkey inspects an item with a worry level of 1200. Worry level increases by 3 to 1203. Monkey gets bored with item. Worry level is divided by 3 to 401. Current worry level is not divisible by 17. Item with worry level 401 is thrown to monkey 1. Monkey inspects an item with a worry level of 3136. Worry level increases by 3 to 3139. Monkey gets bored with item. Worry level is divided by 3 to 1046. Current worry level is not divisible by 17. Item with worry level 1046 is thrown to monkey 1. After round 1, the monkeys are holding items with these worry levels:\n1 2 3 4 Monkey 0: 20, 23, 27, 26 Monkey 1: 2080, 25, 167, 207, 401, 1046 Monkey 2: Monkey 3: Monkeys 2 and 3 aren\u0026rsquo;t holding any items at the end of the round; they both inspected items during the round and threw them all before the round ended.\nThis process continues for a few more rounds:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 After round 2, the monkeys are holding items with these worry levels: Monkey 0: 695, 10, 71, 135, 350 Monkey 1: 43, 49, 58, 55, 362 Monkey 2: Monkey 3: After round 3, the monkeys are holding items with these worry levels: Monkey 0: 16, 18, 21, 20, 122 Monkey 1: 1468, 22, 150, 286, 739 Monkey 2: Monkey 3: After round 4, the monkeys are holding items with these worry levels: Monkey 0: 491, 9, 52, 97, 248, 34 Monkey 1: 39, 45, 43, 258 Monkey 2: Monkey 3: After round 5, the monkeys are holding items with these worry levels: Monkey 0: 15, 17, 16, 88, 1037 Monkey 1: 20, 110, 205, 524, 72 Monkey 2: Monkey 3: After round 6, the monkeys are holding items with these worry levels: Monkey 0: 8, 70, 176, 26, 34 Monkey 1: 481, 32, 36, 186, 2190 Monkey 2: Monkey 3: After round 7, the monkeys are holding items with these worry levels: Monkey 0: 162, 12, 14, 64, 732, 17 Monkey 1: 148, 372, 55, 72 Monkey 2: Monkey 3: After round 8, the monkeys are holding items with these worry levels: Monkey 0: 51, 126, 20, 26, 136 Monkey 1: 343, 26, 30, 1546, 36 Monkey 2: Monkey 3: After round 9, the monkeys are holding items with these worry levels: Monkey 0: 116, 10, 12, 517, 14 Monkey 1: 108, 267, 43, 55, 288 Monkey 2: Monkey 3: After round 10, the monkeys are holding items with these worry levels: Monkey 0: 91, 16, 20, 98 Monkey 1: 481, 245, 22, 26, 1092, 30 Monkey 2: Monkey 3: ... After round 15, the monkeys are holding items with these worry levels: Monkey 0: 83, 44, 8, 184, 9, 20, 26, 102 Monkey 1: 110, 36 Monkey 2: Monkey 3: ... After round 20, the monkeys are holding items with these worry levels: Monkey 0: 10, 12, 14, 26, 34 Monkey 1: 245, 93, 53, 199, 115 Monkey 2: Monkey 3: Chasing all of the monkeys at once is impossible; you\u0026rsquo;re going to have to focus on the two most active monkeys if you want any hope of getting your stuff back. Count the total number of times each monkey inspects items over 20 rounds:\n1 2 3 4 Monkey 0 inspected items 101 times. Monkey 1 inspected items 95 times. Monkey 2 inspected items 7 times. Monkey 3 inspected items 105 times. In this example, the two most active monkeys inspected items 101 and 105 times. The level of monkey business in this situation can be found by multiplying these together: 10605.\nFigure out which monkeys to chase by counting how many items they inspect over 20 rounds. What is the level of monkey business after 20 rounds of stuff-slinging simian shenanigans?\nYou know the drill by now, let\u0026rsquo;s start with the data and model a monkey:\n1 2 3 4 5 6 Monkey 0: Starting items: 79, 98 Operation: new = old * 19 Test: divisible by 23 If true: throw to monkey 2 If false: throw to monkey 3 A monkey has an identifier, some starting items, a mathematical operation that produces a new worry level and a test that determines where the monkey will throw the item. There is only one complex thing in the input but let\u0026rsquo;s start by parsing the easy ones first:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static Monkey FromString(string text) { var lines = text.Split(\u0026#39;\\n\u0026#39;, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries); var id = int.Parse(lines[0][7..8]); var startingItems = lines[1][16..] .Split(\u0026#39;,\u0026#39;, StringSplitOptions.TrimEntries) .Select(long.Parse) .ToArray(); var divisibleBy = int.Parse(lines[3][19..]); var monkeyIDIfTrue = int.Parse(lines[4][25..]); var monkeyIDIfFalse = int.Parse(lines[5][26..]); //... } Nothing special about this code, we are just getting all lines and doing some very easy parsing. Notice that I\u0026rsquo;m using hardcoded values for the start position of the substring. This is something you can do in puzzles like these where the form of the input is always the same. I said there is only one complex thing and that is the operation:\n1 Operation: new = old * 19 How are we supposed to parse this and later execute? There are a bunch of different approaches but since we are using C#, I want to show you some cool C# features, namely compiling creating an Expression Tree and compiling a function at runtime.\nWe want to compile a method that has one parameter old and returns the result of either an addition or multiplication (these are the only operations I have in my puzzle input). Once again, you could just hardcode the lambdas:\n1 2 3 Func\u0026lt;long, long, long\u0026gt; addition = (old, value) =\u0026gt; old + value; Func\u0026lt;long, long, long\u0026gt; multiplication = (old, value) =\u0026gt; old * value; Func\u0026lt;long, long\u0026gt; square = (old) =\u0026gt; old * old; However, this is boring. Instead, let\u0026rsquo;s compile a delegate at runtime using expressions:\nTo build an Expression Tree, we start from within and move outside. The innermost expressions of our delegate are the operands of the binary operation. These are typically called lhs for left-hand side and rhs for right-hand side. The operands are either some constant value or the parameter old. Let\u0026rsquo;s start by creating the parameter first:\n1 var parameter = Expression.Parameter(typeof(long), \u0026#34;old\u0026#34;); Expression.Parameter creates a ParameterExpression node that represents a named parameter expression, which in our case is of type long and has the name old. Because both operands can be the parameter or a constant, we can use an inline function and not have to repeat ourselves:\n1 2 3 4 5 6 7 8 Expression ParseOperand(string s) { if (s == \u0026#34;old\u0026#34;) return parameter; return Expression.Constant(long.Parse(s)); } var lhs = ParseOperand(operationParts[0]); var rhs = ParseOperand(operationParts[2]); Expression.Constant, of course, creates a ConstantExpression that represents some constant value.\nWith both operands we can now create the BinaryExpression for either addition or multiplication:\n1 2 3 4 5 6 var body = operationParts[1] switch { \u0026#34;+\u0026#34; =\u0026gt; Expression.Add(lhs, rhs), \u0026#34;*\u0026#34; =\u0026gt; Expression.Multiply(lhs, rhs), _ =\u0026gt; throw new UnreachableException() }; Finally, we put everything together and create and compile our delegate:\n1 2 var expression = Expression.Lambda\u0026lt;Func\u0026lt;long, long\u0026gt;\u0026gt;(body, parameter); return expression.Compile(); The complete method looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private static Func\u0026lt;long, long\u0026gt; ParseOperation(string line) { var rawOperation = line[17..]; var operationParts = rawOperation.Split(\u0026#39; \u0026#39;, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries); var parameter = Expression.Parameter(typeof(long), \u0026#34;old\u0026#34;); Expression ParseOperand(string s) { if (s == \u0026#34;old\u0026#34;) return parameter; return Expression.Constant(long.Parse(s)); } var lhs = ParseOperand(operationParts[0]); var rhs = ParseOperand(operationParts[2]); var body = operationParts[1] switch { \u0026#34;+\u0026#34; =\u0026gt; Expression.Add(lhs, rhs), \u0026#34;*\u0026#34; =\u0026gt; Expression.Multiply(lhs, rhs), _ =\u0026gt; throw new UnreachableException() }; var expression = Expression.Lambda\u0026lt;Func\u0026lt;long, long\u0026gt;\u0026gt;(body, parameter); return expression.Compile(); } Now that we can parse the operation it\u0026rsquo;s time to look at the complete Monkey class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class Monkey { public readonly int ID; public readonly Queue\u0026lt;long\u0026gt; Items; public readonly Func\u0026lt;long, long\u0026gt; Operation; public readonly int DivisibleBy; public readonly int MonkeyIDIfTrue; public readonly int MonkeyIDIfFalse; public Monkey(int id, Queue\u0026lt;long\u0026gt; items, Func\u0026lt;long, long\u0026gt; operation, int divisibleBy, int monkeyIDIfTrue, int monkeyIDIfFalse) { ID = id; Items = items; DivisibleBy = divisibleBy; Operation = operation; MonkeyIDIfTrue = monkeyIDIfTrue; MonkeyIDIfFalse = monkeyIDIfFalse; } public static Monkey FromString(string text) { var lines = text.Split(\u0026#39;\\n\u0026#39;, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries); var id = int.Parse(lines[0][7..8]); var startingItems = lines[1][16..] .Split(\u0026#39;,\u0026#39;, StringSplitOptions.TrimEntries) .Select(long.Parse) .ToArray(); var items = new Queue\u0026lt;long\u0026gt;(startingItems); var divisibleBy = int.Parse(lines[3][19..]); var operation = ParseOperation(lines[2]); var monkeyIDIfTrue = int.Parse(lines[4][25..]); var monkeyIDIfFalse = int.Parse(lines[5][26..]); return new Monkey(id, items, operation, divisibleBy, monkeyIDIfTrue, monkeyIDIfFalse); } } One thing of note is the use of Queue\u0026lt;T\u0026gt;. For the 5th day we used the last-in-first-out (LIFO) collection Stack\u0026lt;T\u0026gt;, but this puzzle requires a first-in-first-out (FIFO) collection instead.\nHaving parsed all the monkeys, we can now actually deal with the puzzle. Our goal is to count the number of times a monkey inspects an item and get the count for the two monkeys with the highest number of inspected items. Both numbers are then multiplied together to form the Monkey Business value.\nYesterday had us running CPU cycles, this time it\u0026rsquo;s rounds of passing around items. Each round the following happens:\nmonkey 0 looks at his items in order the worry level of each item gets changed based on the operation the worry level gets divided by 3 and rounded down (3.4 becomes 3) the worry level gets tested by checking if it\u0026rsquo;s divisible by a certain number the monkey passes the item to another monkey depending on the outcome of the test the next monkey looks at his items in order Since monkeys have to pass items from one monkey to another by ID, it\u0026rsquo;s best to use a dictionary for key-based access:\n1 2 3 4 var monkeys = text .Split(\u0026#34;\\n\\n\u0026#34;) .Select(Monkey.FromString) .ToDictionary(monkey =\u0026gt; monkey.ID, monkey =\u0026gt; monkey); This way we can just do monkeys[id].Items.Enqueue(something). With these types of puzzles its best to start simple and expand later on. Let\u0026rsquo;s start by just looking at one round and how items get moved from one monkey to another:\n1 2 3 4 5 6 7 foreach (var (monkeyID, monkey) in monkeys) { while (monkey.Items.TryDequeue(out var worryLevel)) { //... } } The Queue\u0026lt;T\u0026gt; class has a neat method TryDequeue with returns true if the dequeue was successful. This allows for a very simple while loop that dequeues all items in the queue.\n1 2 worryLevel = monkey.Operation(worryLevel); worryLevel = (long)Math.Floor(worryLevel / 3.0); The worry level is then changed according to the rules: first the operation changes the value, and then we divide by 3 and use Math.Floor to round down.\n1 2 3 4 5 6 7 8 9 var test = worryLevel % monkey.DivisibleBy == 0; if (test) { monkeys[monkey.MonkeyIDIfTrue].Items.Enqueue(worryLevel); } else { monkeys[monkey.MonkeyIDIfFalse].Items.Enqueue(worryLevel); } Finally, we do the test and use the module operator to check if a number is divisible by another one. The item is then moved to the end of the queue of another monkey. Since we need to count the number of times a monkey looks at any item, we can start using LINQ to do that:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 monkeys .OrderBy(pair =\u0026gt; pair.Key) .Select(pair =\u0026gt; { var (monkeyID, monkey) = pair; var numInspectedItems = monkey.Items.Count; while (monkey.Items.TryDequeue(out var worryLevel)) { worryLevel = monkey.Operation(worryLevel); worryLevel = (long)Math.Floor(worryLevel / 3.0); var test = worryLevel % monkey.DivisibleBy == 0; if (test) { monkeys[monkey.MonkeyIDIfTrue].Items.Enqueue(worryLevel); } else { monkeys[monkey.MonkeyIDIfFalse].Items.Enqueue(worryLevel); } } return (monkeyID, numInspectedItems); }) I use Enumerable.OrderBy just to be on the safe side. The dictionary is not ordered and will usually return items in insertion order. We want monkey 0 to be first then monkey 1 and so on.\nThis code works for one round and returns us the number of inspected items of a monkey that round. The puzzle requires 20 rounds instead of 1 so let\u0026rsquo;s continue using LINQ:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var monkeyBusiness = Enumerable .Range(0, 20) .SelectMany(_ =\u0026gt; monkeys .OrderBy(pair =\u0026gt; pair.Key) .Select(pair =\u0026gt; { //... })) .GroupBy(pair =\u0026gt; pair.monkeyID, pair =\u0026gt; pair.numInspectedItems) .Select(group =\u0026gt; group.Aggregate((a, b) =\u0026gt; a + b)) .OrderDescending() .Take(2) .Aggregate((a, b) =\u0026gt; a * b); Console.WriteLine($\u0026#34;Monkey Business: {monkeyBusiness}\u0026#34;); Using Enumerable.Range we can easily do 20 iterations. In each iteration we iterate over every monkey and return the number of inspected items. Since we don\u0026rsquo;t want a list of lists, we use Enumerable.SelectMany to flatten IEnumerable\u0026lt;IEnumerable\u0026lt;(int, int)\u0026gt;\u0026gt; into IEnumerable\u0026lt;(int, int)\u0026gt;. However, we are not done yet because the contents of this sequence contains elements with duplicate IDs (same monkey but different rounds). A simple Enumerable.GroupBy will group all those elements by the monkey identifier.\nAt this point we have a bunch of groups where the key is the monkey identifier and the values are the number of items from each round. This is still not what we want, so let\u0026rsquo;s sum up all the values using aggregation.\nWhat remains is taking the two biggest values and multiplying them together to get the Monkey Business value.\nPart Two Description You\u0026rsquo;re worried you might not ever get your items back. So worried, in fact, that your relief that a monkey\u0026rsquo;s inspection didn\u0026rsquo;t damage an item no longer causes your worry level to be divided by three.\nUnfortunately, that relief was all that was keeping your worry levels from reaching ridiculous levels. You\u0026rsquo;ll need to find another way to keep your worry levels manageable.\nAt this rate, you might be putting up with these monkeys for a very long time - possibly 10000 rounds!\nWith these new rules, you can still figure out the monkey business after 10000 rounds. Using the same example above:\nWith these new rules, you can still figure out the monkey business after 10000 rounds. Using the same example above:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 == After round 1 == Monkey 0 inspected items 2 times. Monkey 1 inspected items 4 times. Monkey 2 inspected items 3 times. Monkey 3 inspected items 6 times. == After round 20 == Monkey 0 inspected items 99 times. Monkey 1 inspected items 97 times. Monkey 2 inspected items 8 times. Monkey 3 inspected items 103 times. == After round 1000 == Monkey 0 inspected items 5204 times. Monkey 1 inspected items 4792 times. Monkey 2 inspected items 199 times. Monkey 3 inspected items 5192 times. == After round 2000 == Monkey 0 inspected items 10419 times. Monkey 1 inspected items 9577 times. Monkey 2 inspected items 392 times. Monkey 3 inspected items 10391 times. == After round 3000 == Monkey 0 inspected items 15638 times. Monkey 1 inspected items 14358 times. Monkey 2 inspected items 587 times. Monkey 3 inspected items 15593 times. == After round 4000 == Monkey 0 inspected items 20858 times. Monkey 1 inspected items 19138 times. Monkey 2 inspected items 780 times. Monkey 3 inspected items 20797 times. == After round 5000 == Monkey 0 inspected items 26075 times. Monkey 1 inspected items 23921 times. Monkey 2 inspected items 974 times. Monkey 3 inspected items 26000 times. == After round 6000 == Monkey 0 inspected items 31294 times. Monkey 1 inspected items 28702 times. Monkey 2 inspected items 1165 times. Monkey 3 inspected items 31204 times. == After round 7000 == Monkey 0 inspected items 36508 times. Monkey 1 inspected items 33488 times. Monkey 2 inspected items 1360 times. Monkey 3 inspected items 36400 times. == After round 8000 == Monkey 0 inspected items 41728 times. Monkey 1 inspected items 38268 times. Monkey 2 inspected items 1553 times. Monkey 3 inspected items 41606 times. == After round 9000 == Monkey 0 inspected items 46945 times. Monkey 1 inspected items 43051 times. Monkey 2 inspected items 1746 times. Monkey 3 inspected items 46807 times. == After round 10000 == Monkey 0 inspected items 52166 times. Monkey 1 inspected items 47830 times. Monkey 2 inspected items 1938 times. Monkey 3 inspected items 52013 times. After 10000 rounds, the two most active monkeys inspected items 52166 and 52013 times. Multiplying these together, the level of monkey business in this situation is now 2713310158.\nWorry levels are no longer divided by three after each item is inspected; you\u0026rsquo;ll need to find another way to keep your worry levels manageable. Starting again from the initial state in your puzzle input, what is the level of monkey business after 10000 rounds?\nPart Two is very interesting. Instead of 20 rounds we now have to run this for 10000 rounds. Not only that, but the worry level does not get divided by 3 anymore. This means that the values will get very big, very fast. The puzzle asks us to find a way to make the worry levels smaller without changing the results of the tests. You could brute force this problem by just using bigger and bigger data types. While this is an option, you can just do a bit of math to find a better solution.\nWhen coming up with a solution it\u0026rsquo;s important to remember that the actual worry level is unimportant. The only important thing is that the test, whether the worry level is divisible by a certain number, has to produce the same output for all monkeys as before. In other words:\nFor all worry levels x1 ... xn, find a function f(x) so that test(xi, yi) is equal to test(f(xi), yi) with test(x, y) being x % y == 0, for all values of x and y.\nI hope this wording makes it clear that we are dealing with a math puzzle. How do we change the values without changing the outcome?\nThe solution lies in the fact that we are using a modulo operation for the test, it only has to check if the value is divisible by some other value:\n7848 mod 12 = 0: 7848 is divisible by 12 7848 mod 17 = 11: 7848 is not divisible by 17 The modulo operation just returns the remainder of x / y:\n7848 / 12: 7848 = 654 * 12 + 0 ← 7848 / 17: 7848 = 461 * 17 + 11 ← So let\u0026rsquo;s just make sure for f(x) / y the remainders stay the same:\n7848 mod 17 = 11 11 mod 17 = 1 Using the remainder of the first operation in the second operation returns the same result. Which makes total sense when you think about it:\n7848 / 17: 7848 = 461 * 17 + 11 11 / 17: 11 = 0 * 17 + 11 So to reduce the worry level, we just have to use another module operation before the test:\n1 2 worryLevel %= monkey.DivisibleBy; var test = worryLevel % monkey.DivisibleBy == 0; However, this only works for the current monkey. Every monkey a different test value:\noriginal results:\n7848 mod 12 = 0: 7848 is divisible by 12 7848 mod 17 = 11: 7848 is not divisible by 17 results with new technique:\n11 mod 12 = 11: 11 (previous 7848) is not divisible by 12 11 mod 17 = 11: 11 (previous 7848) is not divisible by 17 Instead of using 7848 mod 17 mod 17, how about we use 7848 mod 204 mod 17:\n7848 mod 204 = 96 96 mod 12 = 0 96 mod 17 = 11 This magic value 204 the product of all values of y: p = 12 * 17 = 204. This is also called a common multiple because the result is divisible by all values it was made up of. There is also the least common multiple (LCM) but we don\u0026rsquo;t have to use it.\nWith this new approach we can easily reduce a big number to a smaller one and keeping the test result the same. In order to implement this into the code, we just have to calculate the product before starting the rounds:\n1 var product = monkeys.Select(pair =\u0026gt; pair.Value.DivisibleBy).Aggregate((a, b) =\u0026gt; a * b); Then before doing the test we calculate the new worry level:\n1 worryLevel = isPartOne ? (long)Math.Floor(worryLevel / 3.0) : worryLevel % product; The entire final function looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 private static void RunPart(string text, bool isPartOne) { var monkeys = text .Split(\u0026#34;\\n\\n\u0026#34;) .Select(Monkey.FromString) .ToDictionary(monkey =\u0026gt; monkey.ID, monkey =\u0026gt; monkey); var product = monkeys.Select(pair =\u0026gt; pair.Value.DivisibleBy).Aggregate((a, b) =\u0026gt; a * b); var monkeyBusiness = Enumerable .Range(0, isPartOne ? 20 : 10000) .SelectMany(_ =\u0026gt; monkeys .OrderBy(pair =\u0026gt; pair.Key) .Select(pair =\u0026gt; { var (monkeyID, monkey) = pair; var numInspectedItems = (ulong)monkey.Items.Count; while (monkey.Items.TryDequeue(out var worryLevel)) { worryLevel = monkey.Operation(worryLevel); worryLevel = isPartOne ? (long)Math.Floor(worryLevel / 3.0) : worryLevel % product; var test = worryLevel % monkey.DivisibleBy == 0; if (test) { monkeys[monkey.MonkeyIDIfTrue].Items.Enqueue(worryLevel); } else { monkeys[monkey.MonkeyIDIfFalse].Items.Enqueue(worryLevel); } } return (monkeyID, numInspectedItems); })) .GroupBy(pair =\u0026gt; pair.monkeyID, pair =\u0026gt; pair.numInspectedItems) .Select(group =\u0026gt; group.Aggregate((a, b) =\u0026gt; a + b)) .OrderDescending() .Take(2) .Aggregate((a, b) =\u0026gt; a * b); Console.WriteLine($\u0026#34;Monkey Business: {monkeyBusiness}\u0026#34;); } Conclusion The puzzle for the day before yesterday was also math related. I believe the later puzzles will get more intense with the math problems. I honestly struggled quite a lot, trying to explain the solution, and I\u0026rsquo;m sure there are people who don\u0026rsquo;t understand my incoherent reasoning.\nhttps://www.reddit.com/r/adventofcode/comments/zimtcu/2022_day_11_first_20_rounds_of_monkey_business/\nhttps://www.reddit.com/r/adventofcode/comments/zikzrt/2022_day_11_i_had_to_check_the_solutions_thread/\nhttps://www.reddit.com/r/adventofcode/comments/zihy0i/2022_day_11_i_guess_its_time_to_break_out_this/\n","permalink":"https://erri120.github.io/posts/2022-12-11/","summary":"Day 11: Monkey in the Middle","title":"Advent of Code 2022: Day 11"},{"content":"Day 10 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 10: Cathode-Ray Tube Links: Puzzle Page, My Code\nPart One Description You avoid the ropes, plunge into the river, and swim to shore.\nThe Elves yell something about meeting back up with them upriver, but the river is too loud to tell exactly what they\u0026rsquo;re saying. They finish crossing the bridge and disappear from view.\nSituations like this must be why the Elves prioritized getting the communication system on your handheld device working. You pull it out of your pack, but the amount of water slowly draining from a big crack in its screen tells you it probably won\u0026rsquo;t be of much immediate use.\nUnless, that is, you can design a replacement for the device\u0026rsquo;s video system! It seems to be some kind of cathode-ray tube screen and simple CPU that are both driven by a precise clock circuit. The clock circuit ticks at a constant rate; each tick is called a cycle.\nStart by figuring out the signal being sent by the CPU. The CPU has a single register, X, which starts with the value 1. It supports only two instructions:\naddx V takes two cycles to complete. After two cycles, the X register is increased by the value V. (V can be negative.) noop takes one cycle to complete. It has no other effect. The CPU uses these instructions in a program (your puzzle input) to, somehow, tell the screen what to draw.\nConsider the following small program:\n1 2 3 noop addx 3 addx -5 Execution of this program proceeds as follows:\nAt the start of the first cycle, the noop instruction begins execution. During the first cycle, X is 1. After the first cycle, the noop instruction finishes execution, doing nothing. At the start of the second cycle, the addx 3 instruction begins execution. During the second cycle, X is still 1. During the third cycle, X is still 1. After the third cycle, the addx 3 instruction finishes execution, setting X to 4. At the start of the fourth cycle, the addx -5 instruction begins execution. During the fourth cycle, X is still 4. During the fifth cycle, X is still 4. After the fifth cycle, the addx -5 instruction finishes execution, setting X to -1. Maybe you can learn something by looking at the value of the X register throughout execution. For now, consider the signal strength (the cycle number multiplied by the value of the X register) during the 20th cycle and every 40 cycles after that (that is, during the 20th, 60th, 100th, 140th, 180th, and 220th cycles).\nFor example, consider this larger program:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 addx 15 addx -11 addx 6 addx -3 addx 5 addx -1 addx -8 addx 13 addx 4 noop addx -1 addx 5 addx -1 addx 5 addx -1 addx 5 addx -1 addx 5 addx -1 addx -35 addx 1 addx 24 addx -19 addx 1 addx 16 addx -11 noop noop addx 21 addx -15 noop noop addx -3 addx 9 addx 1 addx -3 addx 8 addx 1 addx 5 noop noop noop noop noop addx -36 noop addx 1 addx 7 noop noop noop addx 2 addx 6 noop noop noop noop noop addx 1 noop noop addx 7 addx 1 noop addx -13 addx 13 addx 7 noop addx 1 addx -33 noop noop noop addx 2 noop noop noop addx 8 noop addx -1 addx 2 addx 1 noop addx 17 addx -9 addx 1 addx 1 addx -3 addx 11 noop noop addx 1 noop addx 1 noop noop addx -13 addx -19 addx 1 addx 3 addx 26 addx -30 addx 12 addx -1 addx 3 addx 1 noop noop noop addx -9 addx 18 addx 1 addx 2 noop noop addx 9 noop noop noop addx -1 addx 2 addx -37 addx 1 addx 3 noop addx 15 addx -21 addx 22 addx -6 addx 1 noop addx 2 addx 1 noop addx -10 noop noop addx 20 addx 1 addx 2 addx 2 addx -6 addx -11 noop noop noop The interesting signal strengths can be determined as follows:\nDuring the 20th cycle, register X has the value 21, so the signal strength is 20 * 21 = 420. (The 20th cycle occurs in the middle of the second addx -1, so the value of register X is the starting value, 1, plus all of the other addx values up to that point: 1 + 15 - 11 + 6 - 3 + 5 - 1 - 8 + 13 + 4 = 21.) During the 60th cycle, register X has the value 19, so the signal strength is 60 * 19 = 1140. During the 100th cycle, register X has the value 18, so the signal strength is 100 * 18 = 1800. During the 140th cycle, register X has the value 21, so the signal strength is 140 * 21 = 2940. During the 180th cycle, register X has the value 16, so the signal strength is 180 * 16 = 2880. During the 220th cycle, register X has the value 18, so the signal strength is 220 * 18 = 3960. The sum of these signal strengths is 13140.\nFind the signal strength during the 20th, 60th, 100th, 140th, 180th, and 220th cycles. What is the sum of these six signal strengths?\nAlright, what do we need? We need two instructions: noop and addx, we need some sort of CPU that keeps track of the cycles and the X register and finally there is calculating the signal strength.\nOnce again, let\u0026rsquo;s start with reading our input and creating the required data types:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class CPU { public Instruction[] Instructions { get; } public int X { get; set; } = 1; public CPU(Instruction[] instructions) { Instructions = instructions; } } public abstract class Instruction { public abstract int CycleCount { get; } public abstract void Execute(CPU cpu); } A simple CPU class that just has an array of instructions and the X register. Since we need different types of instructions, we can create an abstract class that the specific instructions will inherit from. The only thing both noop and addx have is the amount of cycles required and what happens when they execute. One thing I want to note here is that X starts at 1. I initially set it to 0 and got weird results because I didn\u0026rsquo;t read the puzzle correctly.\n1 2 3 4 5 6 public class NoOpInstruction : Instruction { public override int CycleCount =\u0026gt; 1; public override void Execute(CPU cpu) {} } The noop instruction, of course, doesn\u0026rsquo;t do anything but still takes 1 cycle.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class AddXInstruction : Instruction { private readonly int _value; public override int CycleCount =\u0026gt; 2; public AddXInstruction(int value) { _value = value; } public override void Execute(CPU cpu) { cpu.X += _value; } } The addx instruction is similarly uninteresting as it just adds some value to the X register and takes 2 cycles. Finally, let\u0026rsquo;s add a parser function to the abstract class:\n1 2 3 4 5 6 7 8 public static Instruction FromString(string line) { if (line == \u0026#34;noop\u0026#34;) return new NoOpInstruction(); var index = line.IndexOf(\u0026#39; \u0026#39;); var value = int.Parse(line[(index + 1)..]); return new AddXInstruction(value); } With those data types in place and our instructions parsed, how do we actually run this? The puzzle puts great emphasis on when an instruction actually finishes execution and the result can be observed:\nAt the start of the second cycle, the addx 3 instruction begins execution. During the second cycle, X is still 1. During the third cycle, X is still 1. After the third cycle, the addx 3 instruction finishes execution, setting X to 4. At the start of the fourth cycle, the addx -5 instruction begins execution. During the fourth cycle, X is still 4. I think this is just an attempt to confuse programmers by using the word during. It threw me off and certainly threw others off. We essentially just have to keep track of the current cycle, the current instruction, when the current instruction started and when it\u0026rsquo;s supposed to \u0026ldquo;finish\u0026rdquo;. Since the puzzle requires us to do something at specific cycles (20, 60, 100, 140, 180 and 220) we want to iterate over the cycles. If you are thinking of doing a for-i loop, I want to show you a great alternative:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class CPU : IEnumerable\u0026lt;int\u0026gt; { public IEnumerator\u0026lt;int\u0026gt; GetEnumerator() { return new CyclesEnumerator(this); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class CyclesEnumerator : IEnumerator\u0026lt;int\u0026gt; { //... } } We can implement IEnumerable\u0026lt;T\u0026gt; freely on any owned class which allows us to use all the LINQ extension methods. The only thing we need is a custom IEnumerator\u0026lt;T\u0026gt;. Since we want to iterate over the cycles I choose int as the type. Another cool thing is the private nested class CyclesEnumerator. It is only visible for the CPU class because it is private and nested within it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private readonly CPU _cpu; private Instruction _currentInstruction; private int _currentInstructionIndex; private int _currentInstructionCycleStart; public int Current { get; private set; } object IEnumerator.Current =\u0026gt; Current; public CyclesEnumerator(CPU cpu) { _cpu = cpu; _currentInstruction = cpu.Instructions[0]; _currentInstructionIndex = 0; } public bool MoveNext() { //... } public void Reset() { throw new NotSupportedException(); } public void Dispose() {} The IEnumerator\u0026lt;T\u0026gt; interface requires us to implement the MoveNext, Reset and Dispose methods as well as the Current and IEnumerator.Current properties. Dispose comes from IDisposable and doesn\u0026rsquo;t require anything special since we don\u0026rsquo;t have to release unmanaged resources. MoveNext, Reset and IEnumerator.Current all come from IEnuemrator to enable simple iteration over a non-generic collection. The Reset method is not supported since we don\u0026rsquo;t need it.\nThe important work is done in MoveNext which advances the enumerator to the next element, meaning in our case, to the next cycle. If the method returns true it advanced to the next element, if it\u0026rsquo;s false we have arrived at the end of the collection.\nWhat does this mean for our CyclesEnumerator? We want the following behavior:\nif the current instruction requires more cycles, advance to the next if the current instruction does not require more cycles, execute it if we have reached the last instruction, stop iteration, otherwise continue with the next instruction The code would look something like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public bool MoveNext() { // instruction requires more cycles if (_currentInstructionCycleStart + _currentInstruction.CycleCount != Current) { Current += 1; return true; } // execute the instruction after the specified number of cycles _currentInstruction.Execute(_cpu); _currentInstructionIndex += 1; // no more instructions left if (_currentInstructionIndex \u0026gt;= _cpu.Instructions.Length) return false; // move to the next instruction _currentInstruction = _cpu.Instructions[_currentInstructionIndex]; _currentInstructionCycleStart = Current; Current += 1; return true; } Those are all the ingredients we need for part one. Put all together, and we can calculate the signal strength:\n1 2 3 4 5 6 7 8 var cpu = new CPU(instructions); var signalStrength = cpu .Where(cycle =\u0026gt; cycle is \u0026gt;= 20 and \u0026lt;= 220 \u0026amp;\u0026amp; (cycle == 20 || (cycle - 20) % 40 == 0)) .Select(cycle =\u0026gt; cycle * cpu.X) .Sum(); Console.WriteLine($\u0026#34;Signal Strength is {signalStrength}\u0026#34;); Part Two Description It seems like the X register controls the horizontal position of a sprite. Specifically, the sprite is 3 pixels wide, and the X register sets the horizontal position of the middle of that sprite. (In this system, there is no such thing as \u0026ldquo;vertical position\u0026rdquo;: if the sprite\u0026rsquo;s horizontal position puts its pixels where the CRT is currently drawing, then those pixels will be drawn.)\nYou count the pixels on the CRT: 40 wide and 6 high. This CRT screen draws the top row of pixels left-to-right, then the row below that, and so on. The left-most pixel in each row is in position 0, and the right-most pixel in each row is in position 39.\nLike the CPU, the CRT is tied closely to the clock circuit: the CRT draws a single pixel during each cycle. Representing each pixel of the screen as a #, here are the cycles during which the first and last pixel in each row are drawn:\n1 2 3 4 5 6 Cycle 1 -\u0026gt; ######################################## \u0026lt;- Cycle 40 Cycle 41 -\u0026gt; ######################################## \u0026lt;- Cycle 80 Cycle 81 -\u0026gt; ######################################## \u0026lt;- Cycle 120 Cycle 121 -\u0026gt; ######################################## \u0026lt;- Cycle 160 Cycle 161 -\u0026gt; ######################################## \u0026lt;- Cycle 200 Cycle 201 -\u0026gt; ######################################## \u0026lt;- Cycle 240 So, by carefully timing the CPU instructions and the CRT drawing operations, you should be able to determine whether the sprite is visible the instant each pixel is drawn. If the sprite is positioned such that one of its three pixels is the pixel currently being drawn, the screen produces a lit pixel (#); otherwise, the screen leaves the pixel dark (.).\nThe first few pixels from the larger example above are drawn as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 Sprite position: ###..................................... Start cycle 1: begin executing addx 15 During cycle 1: CRT draws pixel in position 0 Current CRT row: # During cycle 2: CRT draws pixel in position 1 Current CRT row: ## End of cycle 2: finish executing addx 15 (Register X is now 16) Sprite position: ...............###...................... Start cycle 3: begin executing addx -11 During cycle 3: CRT draws pixel in position 2 Current CRT row: ##. During cycle 4: CRT draws pixel in position 3 Current CRT row: ##.. End of cycle 4: finish executing addx -11 (Register X is now 5) Sprite position: ....###................................. Start cycle 5: begin executing addx 6 During cycle 5: CRT draws pixel in position 4 Current CRT row: ##..# During cycle 6: CRT draws pixel in position 5 Current CRT row: ##..## End of cycle 6: finish executing addx 6 (Register X is now 11) Sprite position: ..........###........................... Start cycle 7: begin executing addx -3 During cycle 7: CRT draws pixel in position 6 Current CRT row: ##..##. During cycle 8: CRT draws pixel in position 7 Current CRT row: ##..##.. End of cycle 8: finish executing addx -3 (Register X is now 8) Sprite position: .......###.............................. Start cycle 9: begin executing addx 5 During cycle 9: CRT draws pixel in position 8 Current CRT row: ##..##..# During cycle 10: CRT draws pixel in position 9 Current CRT row: ##..##..## End of cycle 10: finish executing addx 5 (Register X is now 13) Sprite position: ............###......................... Start cycle 11: begin executing addx -1 During cycle 11: CRT draws pixel in position 10 Current CRT row: ##..##..##. During cycle 12: CRT draws pixel in position 11 Current CRT row: ##..##..##.. End of cycle 12: finish executing addx -1 (Register X is now 12) Sprite position: ...........###.......................... Start cycle 13: begin executing addx -8 During cycle 13: CRT draws pixel in position 12 Current CRT row: ##..##..##..# During cycle 14: CRT draws pixel in position 13 Current CRT row: ##..##..##..## End of cycle 14: finish executing addx -8 (Register X is now 4) Sprite position: ...###.................................. Start cycle 15: begin executing addx 13 During cycle 15: CRT draws pixel in position 14 Current CRT row: ##..##..##..##. During cycle 16: CRT draws pixel in position 15 Current CRT row: ##..##..##..##.. End of cycle 16: finish executing addx 13 (Register X is now 17) Sprite position: ................###..................... Start cycle 17: begin executing addx 4 During cycle 17: CRT draws pixel in position 16 Current CRT row: ##..##..##..##..# During cycle 18: CRT draws pixel in position 17 Current CRT row: ##..##..##..##..## End of cycle 18: finish executing addx 4 (Register X is now 21) Sprite position: ....................###................. Start cycle 19: begin executing noop During cycle 19: CRT draws pixel in position 18 Current CRT row: ##..##..##..##..##. End of cycle 19: finish executing noop Start cycle 20: begin executing addx -1 During cycle 20: CRT draws pixel in position 19 Current CRT row: ##..##..##..##..##.. During cycle 21: CRT draws pixel in position 20 Current CRT row: ##..##..##..##..##..# End of cycle 21: finish executing addx -1 (Register X is now 20) Sprite position: ...................###.................. Allowing the program to run to completion causes the CRT to produce the following image:\n1 2 3 4 5 6 ##..##..##..##..##..##..##..##..##..##.. ###...###...###...###...###...###...###. ####....####....####....####....####.... #####.....#####.....#####.....#####..... ######......######......######......#### #######.......#######.......#######..... Render the image given by your program. What eight capital letters appear on your CRT?\nPart two looks and sounds intimidating but is actually pretty straightforward. We have a grid of pixels that is 40x6 in size. The X register is now the position of a \u0026ldquo;sprite\u0026rdquo; that is 3 pixels wide. We have to output a # when the sprite is visible and a . when it\u0026rsquo;s not. The sprite is visible if the current horizontal position is in the sprite:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var cpu = new CPU(instructions); foreach (var cycle in cpu) { var spritePosition = cpu.X; var crtPosition = (cycle - 1) % 40; if (spritePosition - 1 \u0026gt; crtPosition || spritePosition + 1 \u0026lt; crtPosition) { // sprite is not visible Console.Write(\u0026#39;.\u0026#39;); } else { // sprite is visible Console.Write(\u0026#39;#\u0026#39;); } if (cycle % 40 == 0) Console.Write(\u0026#39;\\n\u0026#39;); } The only thing noteworthy are the possibilities of multiple off-by-one errors. Positions go from 0 to 39 however Cycles go from 1 to 240:\n1 2 3 4 5 6 Cycle 1 -\u0026gt; ######################################## \u0026lt;- Cycle 40 Cycle 41 -\u0026gt; ######################################## \u0026lt;- Cycle 80 Cycle 81 -\u0026gt; ######################################## \u0026lt;- Cycle 120 Cycle 121 -\u0026gt; ######################################## \u0026lt;- Cycle 160 Cycle 161 -\u0026gt; ######################################## \u0026lt;- Cycle 200 Cycle 201 -\u0026gt; ######################################## \u0026lt;- Cycle 240 This means cycle 1 is actually at position 0 and the X register is interpret as a position meaning the start value of X=1 will be visible from cycle 1 to 3 or position 0 to 2 (since sprites are 3 pixels wide). It\u0026rsquo;s a bit of a mess but once you got that figured out its easy sailing and the solution looks cool:\nMy solution (it reads EFUGLPAP)\nConclusion The good puzzles don\u0026rsquo;t stop. Yesterday and the day before yesterday had fun and interesting puzzles, each adding some new concept. Today we were forced to visualize our solution and the puzzle introduces new programmers to some core concepts like CPU instructions and cycles. I also decided to try something different by implement a custom IEnumerator\u0026lt;T\u0026gt; which was a good refresher on how that works.\nhttps://www.reddit.com/r/adventofcode/comments/zhlhk2/2022_day_10_part_2_if_its_good_enough_for_a_crt/\n","permalink":"https://erri120.github.io/posts/2022-12-10/","summary":"Day 10: Cathode-Ray Tube","title":"Advent of Code 2022: Day 10"},{"content":"Day 9 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 9: Rope Bridge Links: Puzzle Page, My Code\nPart One Description This rope bridge creaks as you walk along it. You aren\u0026rsquo;t sure how old it is, or whether it can even support your weight.\nIt seems to support the Elves just fine, though. The bridge spans a gorge which was carved out by the massive river far below you.\nYou step carefully; as you do, the ropes stretch and twist. You decide to distract yourself by modeling rope physics; maybe you can even figure out where not to step.\nConsider a rope with a knot at each end; these knots mark the head and the tail of the rope. If the head moves far enough away from the tail, the tail is pulled toward the head.\nDue to nebulous reasoning involving Planck lengths, you should be able to model the positions of the knots on a two-dimensional grid. Then, by following a hypothetical series of motions (your puzzle input) for the head, you can determine how the tail will move.\nDue to the aforementioned Planck lengths, the rope must be quite short; in fact, the head (H) and tail (T) must always be touching (diagonally adjacent and even overlapping both count as touching):\n1 2 3 4 5 6 7 8 9 10 11 12 .... .TH. .... .... .H.. ..T. .... ... .H. (H covers T) ... If the head is ever two steps directly up, down, left, or right from the tail, the tail must also move one step in that direction so it remains close enough:\n1 2 3 4 5 6 7 8 9 ..... ..... ..... .TH.. -\u0026gt; .T.H. -\u0026gt; ..TH. ..... ..... ..... ... ... ... .T. .T. ... .H. -\u0026gt; ... -\u0026gt; .T. ... .H. .H. ... ... ... Otherwise, if the head and tail aren\u0026rsquo;t touching and aren\u0026rsquo;t in the same row or column, the tail always moves one step diagonally to keep up:\n1 2 3 4 5 6 7 8 9 10 11 ..... ..... ..... ..... ..H.. ..H.. ..H.. -\u0026gt; ..... -\u0026gt; ..T.. .T... .T... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..... ..H.. -\u0026gt; ...H. -\u0026gt; ..TH. .T... .T... ..... ..... ..... ..... You just need to work out where the tail goes as the head follows a series of motions. Assume the head and the tail both start at the same position, overlapping.\nFor example:\nR 4 U 4 L 3 D 1 R 4 D 1 L 5 R 2 This series of motions moves the head right four steps, then up four steps, then left three steps, then down one step, and so on. After each step, you\u0026rsquo;ll need to update the position of the tail if the step means the head is no longer adjacent to the tail. Visually, these motions occur as follows (s marks the starting position as a reference point):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 == Initial State == ...... ...... ...... ...... H..... (H covers T, s) == R 4 == ...... ...... ...... ...... TH.... (T covers s) ...... ...... ...... ...... sTH... ...... ...... ...... ...... s.TH.. ...... ...... ...... ...... s..TH. == U 4 == ...... ...... ...... ....H. s..T.. ...... ...... ....H. ....T. s..... ...... ....H. ....T. ...... s..... ....H. ....T. ...... ...... s..... == L 3 == ...H.. ....T. ...... ...... s..... ..HT.. ...... ...... ...... s..... .HT... ...... ...... ...... s..... == D 1 == ..T... .H.... ...... ...... s..... == R 4 == ..T... ..H... ...... ...... s..... ..T... ...H.. ...... ...... s..... ...... ...TH. ...... ...... s..... ...... ....TH ...... ...... s..... == D 1 == ...... ....T. .....H ...... s..... == L 5 == ...... ....T. ....H. ...... s..... ...... ....T. ...H.. ...... s..... ...... ...... ..HT.. ...... s..... ...... ...... .HT... ...... s..... ...... ...... HT.... ...... s..... == R 2 == ...... ...... .H.... (H covers T) ...... s..... ...... ...... .TH... ...... s..... After simulating the rope, you can count up all of the positions the tail visited at least once. In this diagram, s again marks the starting position (which the tail also visited) and # marks other positions the tail visited:\nSo, there are 13 positions the tail visited at least once.\nSimulate your complete hypothetical series of motions. How many positions does the tail of the rope visit at least once?\nIf you are like and do these puzzles after waking up, then you might have to re-read the description a couple of times before understanding what\u0026rsquo;s even going on. Essentially we have two points in 2D space, the head and tail position, and whenever the head moves according to the puzzle input, the tail has to follow.\nLet\u0026rsquo;s start by modeling our data:\n1 2 3 4 5 6 7 public enum Direction { Right, Left, Up, Down } Once again I\u0026rsquo;m reaching for a readonly struct to store the motion data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public readonly struct Motion { public readonly Direction Direction; public readonly int Steps; public Motion(Direction direction, int steps) { Direction = direction; Steps = steps; } public static Motion FromString(string line) { var sDirection = line[0]; var direction = sDirection switch { \u0026#39;R\u0026#39; =\u0026gt; Direction.Right, \u0026#39;L\u0026#39; =\u0026gt; Direction.Left, \u0026#39;U\u0026#39; =\u0026gt; Direction.Up, \u0026#39;D\u0026#39; =\u0026gt; Direction.Down, _ =\u0026gt; throw new UnreachableException() }; var count = int.Parse(line[1..]); return new Motion(direction, count); } } Another straightforward thing we can implement right now is updating the head position:\n1 2 3 4 5 6 7 8 9 10 11 private static Vector2 NewHeadPosition(Vector2 current, Direction direction) { return direction switch { Direction.Right =\u0026gt; current with { X = current.X += 1 }, Direction.Left =\u0026gt; current with { X = current.X -= 1 }, Direction.Up =\u0026gt; current with { Y = current.Y += 1 }, Direction.Down =\u0026gt; current with { Y = current.Y -= 1 }, _ =\u0026gt; throw new UnreachableException() }; } This method utilizes some cool .NET features, first I\u0026rsquo;ve decided to represent the positions as Vector2, there is also Vector3 and Vector4 if you need more dimensions. More interesting than that is the switch expression using Pattern matching we got in C# 7 and 8 and the awesome new with expression from C# 9 and C# 10. Here is how with works with Vector2:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void M() { var a = new Vector2(0, 1); var b = a with { X = 100 }; } // gets converted into public void M() { Vector2 vector = new Vector2(0f, 1f); Vector2 vector2 = vector; vector2.X = 100f; Vector2 vector3 = vector2; } You can observe this behavior on SharpLab.\nNow onto the interesting part. How do we update the tail position to follow the head? Let\u0026rsquo;s make a new method and think about it.\n1 2 3 4 private static Vector2 NewTailPosition(Vector2 tail, Vector2 head) { // ... } The tail only has to move, if it doesn\u0026rsquo;t touch the head. It can have the same position as the head or be in any adjacent field to the right, left, up, down or diagonally. We can check if the tail is next to the head by calculating the distance between the two points:\n1 2 var d1 = Vector2.Distance(a, b); var d2 = Vector2.DistanceSquared(a, b); Vector2 has two distance methods 1) Vector2.Distance returns the Euclidean distance and Vector2.DistanceSquared return the Euclidean distance squared. The squared distance is faster to compute and always non-negative so exactly what we want:\n1 2 var distance = Vector2.DistanceSquared(head, tail); if (distance \u0026lt;= 2.0f) return tail; tail position is overlapping with the head position: distance = 0 tail position is right, left, up or down of the head position: distance = 1 tail position is diagonally to the head position: distance = 2 These are the three cases we want to cover, and the Euclidean distance squared allows us to check for them easily. We don\u0026rsquo;t have to update the tail position and can just return it again. More difficult is figuring out the position when the tail is too far away.\nThe head will only move one step at a time meaning we also only have to move the tail one step if we want to catch up. The question is if we need to update the X or Y coordinates or both. You could simply use a bunch of if statements like this:\n1 2 3 4 5 6 var newX = head.X \u0026gt; tail.X ? tail.X + 1 : tail.X - 1; var newY = head.Y \u0026gt; tail.Y ? tail.Y + 1 : tail.Y - 1; if (tail.X != head.X \u0026amp;\u0026amp; tail.Y == head.Y) return tail with { X = newX }; if (tail.Y != head.Y \u0026amp;\u0026amp; tail.X == head.X) return tail with { Y = newY }; return new Vector2(newX, newY); This is what a programmer would do. But what would a mathematician come up with? They will look at this problem and abuse the fact that we are working with two points on a 2-dimensional plane:\n1 2 var delta = Vector2.Subtract(head, tail); return new Vector2(tail.X + MathF.Sign(delta.X), tail.Y + MathF.Sign(delta.Y)); First we use Vector2.Subtract to calculate the difference between the two positions. This vector will \u0026ldquo;point\u0026rdquo; in the direction we need to move the tail position. Here is an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 tail = (0, 0) head = (2, 0) delta = head - tail = (2, 0) newTail = (1, 0) tail = (4, 3) head = (2, 3) delta = head - tail = (-2, 0) newTail = (3, 3) tail = (1, 1) head = (3, 2) delta = head - tail = (2, 1) newTail = (2, 2) The actual values of the difference is not important, the only meaningful thing is whether X or Y is positive or negative, or in other words, what sign they have.\nIn the first example delta = (2, 0) the X component is positive and the correct new position is X+1. The second example has a negative X and to update the tail position we need use X-1. In the final example the head moved diagonally and then sideways, both the X and Y components of the delta is positive, and the tail position has to be updated to X+1 and Y+1. The MathF.Sign method will return the following:\n-1: the input is negative 0: the input is zero 1: the input is positive This is exactly what we need. If one of the components is positive we add 1, if it\u0026rsquo;s negative we subtract 1 and when it\u0026rsquo;s 0 we do nothing. This is the final method:\n1 2 3 4 5 6 7 8 private static Vector2 NewTailPosition(Vector2 tail, Vector2 head) { var distance = Vector2.DistanceSquared(head, tail); if (distance \u0026lt;= 2.0f) return tail; var delta = Vector2.Subtract(head, tail); return new Vector2(tail.X + MathF.Sign(delta.X), tail.Y + MathF.Sign(delta.Y)); } Now we have everything we need and can put it all together:\n1 2 3 4 5 6 7 8 9 10 11 12 13 var head = Vector2.Zero; var tail = Vector2.Zero; var visitedPositions = motions.SelectMany(motion =\u0026gt; { return Enumerable.Range(0, motion.Steps) .Select(_ =\u0026gt; { head = NewHeadPosition(head, motion.Direction); tail = NewTailPosition(tail, head); return tail; }); }).Distinct().Count(); A couple interesting things are going on here. Vector2.Zero is the same as writing new Vector2(0, 0). The puzzle requires us to count the number of unique positions of the tail. I initially used Enumerable.Count to count all positions, but that was just me not reading carefully enough. If you want uniqueness you can use Enumerable.Distinct.\nIn order for the head to only do one move at a time, followed by changing the tail position, we need to iterate over the number of steps and not do them all at once. Enumerable.Range has got us covered, but this will now return an IEnumerable\u0026lt;Vector2\u0026gt; which means the outer loop will return an IEnumerable\u0026lt;IEnumerable\u0026lt;Vector2\u0026gt;\u0026gt;. This is where Enumerable.SelectMany comes into play as it can flatten the sequences into one.\nPart Two Description A rope snaps! Suddenly, the river is getting a lot closer than you remember. The bridge is still there, but some of the ropes that broke are now whipping toward you as you fall through the air!\nThe ropes are moving too quickly to grab; you only have a few seconds to choose how to arch your body to avoid being hit. Fortunately, your simulation can be extended to support longer ropes.\nRather than two knots, you now must simulate a rope consisting of ten knots. One knot is still the head of the rope and moves according to the series of motions. Each knot further down the rope follows the knot in front of it using the same rules as before.\nUsing the same series of motions as the above example, but with the knots marked H, 1, 2, \u0026hellip;, 9, the motions now occur as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 == Initial State == ...... ...... ...... ...... H..... (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s) == R 4 == ...... ...... ...... ...... 1H.... (1 covers 2, 3, 4, 5, 6, 7, 8, 9, s) ...... ...... ...... ...... 21H... (2 covers 3, 4, 5, 6, 7, 8, 9, s) ...... ...... ...... ...... 321H.. (3 covers 4, 5, 6, 7, 8, 9, s) ...... ...... ...... ...... 4321H. (4 covers 5, 6, 7, 8, 9, s) == U 4 == ...... ...... ...... ....H. 4321.. (4 covers 5, 6, 7, 8, 9, s) ...... ...... ....H. .4321. 5..... (5 covers 6, 7, 8, 9, s) ...... ....H. ....1. .432.. 5..... (5 covers 6, 7, 8, 9, s) ....H. ....1. ..432. .5.... 6..... (6 covers 7, 8, 9, s) == L 3 == ...H.. ....1. ..432. .5.... 6..... (6 covers 7, 8, 9, s) ..H1.. ...2.. ..43.. .5.... 6..... (6 covers 7, 8, 9, s) .H1... ...2.. ..43.. .5.... 6..... (6 covers 7, 8, 9, s) == D 1 == ..1... .H.2.. ..43.. .5.... 6..... (6 covers 7, 8, 9, s) == R 4 == ..1... ..H2.. ..43.. .5.... 6..... (6 covers 7, 8, 9, s) ..1... ...H.. (H covers 2) ..43.. .5.... 6..... (6 covers 7, 8, 9, s) ...... ...1H. (1 covers 2) ..43.. .5.... 6..... (6 covers 7, 8, 9, s) ...... ...21H ..43.. .5.... 6..... (6 covers 7, 8, 9, s) == D 1 == ...... ...21. ..43.H .5.... 6..... (6 covers 7, 8, 9, s) == L 5 == ...... ...21. ..43H. .5.... 6..... (6 covers 7, 8, 9, s) ...... ...21. ..4H.. (H covers 3) .5.... 6..... (6 covers 7, 8, 9, s) ...... ...2.. ..H1.. (H covers 4; 1 covers 3) .5.... 6..... (6 covers 7, 8, 9, s) ...... ...2.. .H13.. (1 covers 4) .5.... 6..... (6 covers 7, 8, 9, s) ...... ...... H123.. (2 covers 4) .5.... 6..... (6 covers 7, 8, 9, s) == R 2 == ...... ...... .H23.. (H covers 1; 2 covers 4) .5.... 6..... (6 covers 7, 8, 9, s) ...... ...... .1H3.. (H covers 2, 4) .5.... 6..... (6 covers 7, 8, 9, s) Now, you need to keep track of the positions the new tail, 9, visits. In this example, the tail never moves, and so it only visits 1 position. However, be careful: more types of motion are possible than before, so you might want to visually compare your simulated rope to the one above.\nHere\u0026rsquo;s a larger example:\n1 2 3 4 5 6 7 8 R 5 U 8 L 8 D 3 R 17 D 10 L 25 U 20 These motions occur as follows (individual steps are not shown):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 == Initial State == .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... ...........H.............. (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s) .......................... .......................... .......................... .......................... .......................... == R 5 == .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... ...........54321H......... (5 covers 6, 7, 8, 9, s) .......................... .......................... .......................... .......................... .......................... == U 8 == .......................... .......................... .......................... .......................... .......................... .......................... .......................... ................H......... ................1......... ................2......... ................3......... ...............54......... ..............6........... .............7............ ............8............. ...........9.............. (9 covers s) .......................... .......................... .......................... .......................... .......................... == L 8 == .......................... .......................... .......................... .......................... .......................... .......................... .......................... ........H1234............. ............5............. ............6............. ............7............. ............8............. ............9............. .......................... .......................... ...........s.............. .......................... .......................... .......................... .......................... .......................... == D 3 == .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .........2345............. ........1...6............. ........H...7............. ............8............. ............9............. .......................... .......................... ...........s.............. .......................... .......................... .......................... .......................... .......................... == R 17 == .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... ................987654321H .......................... .......................... .......................... .......................... ...........s.............. .......................... .......................... .......................... .......................... .......................... == D 10 == .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... ...........s.........98765 .........................4 .........................3 .........................2 .........................1 .........................H == L 25 == .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... ...........s.............. .......................... .......................... .......................... .......................... H123456789................ == U 20 == H......................... 1......................... 2......................... 3......................... 4......................... 5......................... 6......................... 7......................... 8......................... 9......................... .......................... .......................... .......................... .......................... .......................... ...........s.............. .......................... .......................... .......................... .......................... .......................... Now, the tail (9) visits 36 positions (including s) at least once:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... .......................... #......................... #.............###......... #............#...#........ .#..........#.....#....... ..#..........#.....#...... ...#........#.......#..... ....#......s.........#.... .....#..............#..... ......#............#...... .......#..........#....... ........#........#........ .........########......... Simulate your complete series of motions on a larger rope with ten knots. How many positions does the tail of the rope visit at least once?\nThe description for part two is really, but essentially we are now dealing with 10 points that are linked together. This is where your basic data structure course from uni comes back to haunt you because this calls for a linked list. However, different from your student days we don\u0026rsquo;t have to create our own linked list, we can just use the .NET LinkedList\u0026lt;T\u0026gt;:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private static int RunPart(IEnumerable\u0026lt;Motion\u0026gt; motions, int knotCount) { var linkedList = new LinkedList\u0026lt;Vector2\u0026gt;(Enumerable.Range(0, knotCount).Select(_ =\u0026gt; Vector2.Zero)); var visitedPositions = motions.SelectMany(motion =\u0026gt; { return Enumerable.Range(0, motion.Steps) .Select(_ =\u0026gt; { // ... }); }).Distinct().Count(); return visitedPositions; } This is almost the same code as before, however instead of having two variables head and tail, we create a LinkedList\u0026lt;T\u0026gt; with x amount of zero vectors, and we need to change the code that updates the positions:\n1 2 3 4 5 6 7 8 var headNode = linkedList.First!; var tailNode = linkedList.Last!; var newHeadPos = NewHeadPosition(headNode.Value, motion.Direction); headNode.Value = newHeadPos; UpdateNodes(headNode.Next!, newHeadPos); return tailNode.Value; The linked list implementation in .NET can have no elements, in which case linkedList.First and linkedList.Last will be null. Normally you\u0026rsquo;d want to check for nullability but using ! at the end we can tell the compiler to trust us and allow this possible null value to be used as a non-null value. The .NET LinkedList\u0026lt;T\u0026gt; also wraps the values in a LinkedListNode\u0026lt;T\u0026gt;, and we can get and set the value via the Value property. What\u0026rsquo;s new with this code is the UpdateNodes method:\n1 2 3 4 5 6 7 8 9 10 11 12 private static void UpdateNodes(LinkedListNode\u0026lt;Vector2\u0026gt; node, Vector2 head) { while (true) { node.Value = NewTailPosition(node.Value, head); if (node.Next is null) break; var node1 = node; node = node.Next; head = node1.Value; } } This is where we call NewTailPosition on all nodes after the head. We know that we reached the end when there isn\u0026rsquo;t a next node. Just in case you haven\u0026rsquo;t seen this before: something is null and something is not null is the preferred way of checking if something is null or not. This was added in C# 7 with Pattern matching and should be used instead of something == null and something != null.\nAside from that, this method is not recursive. The day before yesterday had a puzzle with recursion so this time I want to fresh things up and show what else you can do. Instead of recursively calling UpdateNodes we can use an endless while loop and just re-assign node and head in each iteration until there isn\u0026rsquo;t a next value. Recursion is an easy way of creating stack overflows and should generally be avoided if possible.\nWith that we are done. Here is the final function that works for any positive number of knots, greater than or equal to 2:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private static int RunPart(IEnumerable\u0026lt;Motion\u0026gt; motions, int knotCount) { var linkedList = new LinkedList\u0026lt;Vector2\u0026gt;(Enumerable.Range(0, knotCount).Select(_ =\u0026gt; Vector2.Zero)); var visitedPositions = motions.SelectMany(motion =\u0026gt; { return Enumerable.Range(0, motion.Steps) .Select(_ =\u0026gt; { var headNode = linkedList.First!; var tailNode = linkedList.Last!; var newHeadPos = NewHeadPosition(headNode.Value, motion.Direction); headNode.Value = newHeadPos; UpdateNodes(headNode.Next!, newHeadPos); return tailNode.Value; }); }).Distinct().Count(); return visitedPositions; } Conclusion Another good puzzle. Yesterday\u0026rsquo;s puzzle was also really fun, and I\u0026rsquo;m hoping the puzzles will keep getting better and more difficult. Today was a great time to relearn some basic mathematics and get reacquainted with linked list.\nhttps://www.reddit.com/r/adventofcode/comments/zgofb1/2022_day_9_good_luck_with_that_rope_bridge/\n","permalink":"https://erri120.github.io/posts/2022-12-09/","summary":"Day 9: Rope Bridge","title":"Advent of Code 2022: Day 9"},{"content":"Day 8 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 8: Treetop Tree House Links: Puzzle Page, My Code\nPart One Description The expedition comes across a peculiar patch of tall trees all planted carefully in a grid. The Elves explain that a previous expedition planted these trees as a reforestation effort. Now, they\u0026rsquo;re curious if this would be a good location for a tree house.\nFirst, determine whether there is enough tree cover here to keep a tree house hidden. To do this, you need to count the number of trees that are visible from outside the grid when looking directly along a row or column.\nThe Elves have already launched a quadcopter to generate a map with the height of each tree (your puzzle input). For example:\n1 2 3 4 5 30373 25512 65332 33549 35390 Each tree is represented as a single digit whose value is its height, where 0 is the shortest and 9 is the tallest.\nA tree is visible if all of the other trees between it and an edge of the grid are shorter than it. Only consider trees in the same row or column; that is, only look up, down, left, or right from any given tree.\nAll of the trees around the edge of the grid are visible - since they are already on the edge, there are no trees to block the view. In this example, that only leaves the interior nine trees to consider:\nThe top-left 5 is visible from the left and top. (It isn\u0026rsquo;t visible from the right or bottom since other trees of height 5 are in the way.) The top-middle 5 is visible from the top and right. The top-right 1 is not visible from any direction; for it to be visible, there would need to only be trees of height 0 between it and an edge. The left-middle 5 is visible, but only from the right. The center 3 is not visible from any direction; for it to be visible, there would need to be only trees of at most height 2 between it and an edge. The right-middle 3 is visible from the right. In the bottom row, the middle 5 is visible, but the 3 and 4 are not. With 16 trees visible on the edge and another 5 visible in the interior, a total of 21 trees are visible in this arrangement.\nConsider your map; how many trees are visible from outside the grid?\nThe puzzle input is a simple grid of numbers. Before even thinking about anything else, let\u0026rsquo;s start by converting a bunch of lines into something we can work with:\n1 2 3 4 5 6 7 8 private static int[][] CreateGrid(IEnumerable\u0026lt;string\u0026gt; lines) { return lines .Select(line =\u0026gt; line .Select(c =\u0026gt; int.Parse($\u0026#34;{c}\u0026#34;)) .ToArray()) .ToArray(); } In C# the type int[][] represents a 2D array, meaning an array of arrays. In this case it\u0026rsquo;s an array of rows. A common problem when working with multidimensional arrays is forgetting which dimension represents what. We can make our lives simpler by just creating an iterator method:\n1 2 3 4 5 6 7 8 9 10 11 private static IEnumerable\u0026lt;(int, int)\u0026gt; IterateGrid(int[][] grid) { for (var y = 0; y \u0026lt; grid.Length; y++) { var row = grid[y]; for (var x = 0; x \u0026lt; row.Length; x++) { yield return (x, y); } } } Using the iterator method results in cleaner code and is more idiomatic when working with LINQ in C#:\n1 2 3 4 5 6 7 8 9 10 11 12 foreach (var (x, y) in IterateGrid(grid)) { //.... } // or IterateGrid(grid).Select(tuple =\u0026gt; { var (x, y) = tuple; //... }) We have our grid and can iterate over it, great. Now for the hard part. We essentially just need to count trees that are visible from outside the grid. We need to count something? That calls for Enumerable.Count:\n1 2 3 4 5 6 7 8 9 var totalVisible = IterateGrid(grid) .Count(tuple =\u0026gt; { var (x, y) = tuple; var row = grid[y]; var value = row[x]; return false; }); Enumerable.Count will return the number of elements in a sequence that satisfy the predicate function. The puzzle says we need to count the visible trees, let\u0026rsquo;s figure at what makes a tree visible. A tree is visible if there are no other trees blocking the view. Meaning from the current tree we look at all trees on the left and right as well as up and down. If the current tree height is greater than all the trees in one direction, it is considered visible.\nThis calls for more LINQ methods!\n1 2 3 4 5 6 private static IEnumerable\u0026lt;int\u0026gt; ValuesRight(int[] row, int x) { return row // skip to the first value after the current one .Skip(x + 1); } Let\u0026rsquo;s start with the easiest case: all values to the right, or in other terms, all values after the current one. Enumerable.Skip skips a specified number of elements in a sequence. Don\u0026rsquo;t forget that x is the index into the array meaning we need to add +1 to skip until the next value.\n1 2 3 4 5 6 7 8 private static IEnumerable\u0026lt;int\u0026gt; ValuesLeft(int[] row, int x) { return row // take all values left of the current position in the row .TakeWhile((_, x2) =\u0026gt; x2 \u0026lt; x) // reverse the sequence, so the first element is the first value to the left .Reverse(); } All values to the left is also straightforward. Simply get all values with an index less than the current index. The LINQ extension method Enumerable.TakeWhile has an overload that includes the current index in the predicate. With Enumerable.Reverse we make sure that the first element in the sequence is the first value to the left.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private static IEnumerable\u0026lt;int\u0026gt; ValuesDown(int[][] grid, int x, int y) { return grid // skip to the first row after the current one .Skip(y + 1) // select only the values from the same column .Select(row2 =\u0026gt; row2[x]); } private static IEnumerable\u0026lt;int\u0026gt; ValuesUp(int[][] grid, int x, int y) { return grid // take all rows above the current one .TakeWhile((_, y2) =\u0026gt; y2 \u0026lt; y) // select only the values from the same column .Select(row2 =\u0026gt; row2[x]) // reverse the sequence, so the first element is the first value up .Reverse(); } These two methods are essentially the same as ValuesRight and ValuesLeft but instead of getting values from the current row, we are looking for values in the same column.\nWith those four methods in place, we just need to call them:\n1 2 3 4 5 6 7 8 9 10 11 var isVisibleFromTheLeft = ValuesLeft(row, x).All(other =\u0026gt; other \u0026lt; value); if (isVisibleFromTheLeft) return true; var isVisibleFromTheRight = ValuesRight(row, x).All(other =\u0026gt; other \u0026lt; value); if (isVisibleFromTheRight) return true; var isVisibleFromTheTop = ValuesUp(grid, x, y).All(other =\u0026gt; other \u0026lt; value); if (isVisibleFromTheTop) return true; var isVisibleFromTheBottom = ValuesDown(grid, x, y).All(other =\u0026gt; other \u0026lt; value); if (isVisibleFromTheBottom) return true; Remember that the goal is to find trees that are visible from any direction. The values in the grid represent the height of the tree and a tree is visible when all trees in a direction are smaller. Once again, LINQ has us covered with Enumerable.All that determines whether all elements of a sequence satisfy a condition.\nAll put together the solution for part one looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private static void PartOne(int[][] grid) { var totalVisible = IterateGrid(grid) .Count(tuple =\u0026gt; { var (x, y) = tuple; var row = grid[y]; var value = row[x]; var isVisibleFromTheLeft = ValuesLeft(row, x).All(other =\u0026gt; other \u0026lt; value); if (isVisibleFromTheLeft) return true; var isVisibleFromTheRight = ValuesRight(row, x).All(other =\u0026gt; other \u0026lt; value); if (isVisibleFromTheRight) return true; var isVisibleFromTheTop = ValuesUp(grid, x, y).All(other =\u0026gt; other \u0026lt; value); if (isVisibleFromTheTop) return true; var isVisibleFromTheBottom = ValuesDown(grid, x, y).All(other =\u0026gt; other \u0026lt; value); if (isVisibleFromTheBottom) return true; return false; }); Console.WriteLine($\u0026#34;Total Visible: {totalVisible}\u0026#34;); } Part Two Description Content with the amount of tree cover available, the Elves just need to know the best spot to build their tree house: they would like to be able to see a lot of trees.\nTo measure the viewing distance from a given tree, look up, down, left, and right from that tree; stop if you reach an edge or at the first tree that is the same height or taller than the tree under consideration. (If a tree is right on the edge, at least one of its viewing distances will be zero.)\nThe Elves don\u0026rsquo;t care about distant trees taller than those found by the rules above; the proposed tree house has large eaves to keep it dry, so they wouldn\u0026rsquo;t be able to see higher than the tree house anyway.\nIn the example above, consider the middle 5 in the second row:\n1 2 3 4 5 30373 25512 65332 33549 35390 Looking up, its view is not blocked; it can see 1 tree (of height 3). Looking left, its view is blocked immediately; it can see only 1 tree (of height 5, right next to it). Looking right, its view is not blocked; it can see 2 trees. Looking down, its view is blocked eventually; it can see 2 trees (one of height 3, then the tree of height 5 that blocks its view). A tree\u0026rsquo;s scenic score is found by multiplying together its viewing distance in each of the four directions. For this tree, this is 4 (found by multiplying 1 * 1 * 2 * 2).\nHowever, you can do even better: consider the tree of height 5 in the middle of the fourth row:\n1 2 3 4 5 30373 25512 65332 33549 35390 Looking up, its view is blocked at 2 trees (by another tree with a height of 5). Looking left, its view is not blocked; it can see 2 trees. Looking down, its view is also not blocked; it can see 1 tree. Looking right, its view is blocked at 2 trees (by a massive tree of height 9). This tree\u0026rsquo;s scenic score is 8 (2 * 2 * 1 * 2); this is the ideal spot for the tree house.\nConsider each tree on your map. What is the highest scenic score possible for any tree?\nPart two has us checking all trees, calculating some scenic score and finding the maximum.\n1 2 3 4 5 6 7 8 9 10 11 var highestScenicScore = IterateGrid(grid) .Select(tuple =\u0026gt; { var (x, y) = tuple; var row = grid[y]; var value = row[x]; var scenicScore = 0; return scenicScore; }) .Max(); We can re-use our previous method IterateGrid and use Enumerable.Max to find the highest score. The score is calculated by multiplying the amount of visible trees in each direction.\n1 2 3 4 5 6 var treesVisibleLeft = ValuesLeft(row, x).TakeWhile(left =\u0026gt; left \u0026lt; value).Count(); var treesVisibleRight = ValuesRight(row, x).TakeWhile(right =\u0026gt; right \u0026lt; value).Count(); var treesVisibleUp = ValuesUp(grid, x, y).TakeWhile(up =\u0026gt; up \u0026lt; value).Count(); var treesVisibleDown = ValuesDown(grid, x, y).TakeWhile(down =\u0026gt; down \u0026lt; value).Count(); var scenicScore = treesVisibleLeft * treesVisibleRight * treesVisibleUp * treesVisibleDown; The Values* methods we created will give us all trees in any direction, so let\u0026rsquo;s just use Enumerable.TakeWhile and Enumerable.Count to count the number of visible trees. We can\u0026rsquo;t use Count(left =\u0026gt; left \u0026lt; value) because this would be applied on the entire sequence. We have to count until we either find the edge or a tree that is bigger.\nThe code above will not work as expected. The issue is Enumerable.TakeWhile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Licensed to the .NET Foundation under one or more agreements. // The .NET Foundation licenses this file to you under the MIT license. private static IEnumerable\u0026lt;TSource\u0026gt; TakeWhileIterator\u0026lt;TSource\u0026gt;(IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, bool\u0026gt; predicate) { foreach (TSource element in source) { if (!predicate(element)) { break; } yield return element; } } The puzzle requires that we also include the first taller tree in the count but Enumerable.TakeWhile will not return the element where the predicate is not satisfied. Instead, we have to create our own \u0026ldquo;Take\u0026rdquo; method:\n1 2 3 4 5 6 7 8 9 10 11 12 private static IEnumerable\u0026lt;TSource\u0026gt; TakeUntil\u0026lt;TSource\u0026gt;(this IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, bool\u0026gt; predicate) { foreach (var element in source) { yield return element; if (!predicate(element)) { break; } } } Now the code will work as intended:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private static void PartTwo(int[][] grid) { var highestScenicScore = IterateGrid(grid) .Select(tuple =\u0026gt; { var (x, y) = tuple; var row = grid[y]; var value = row[x]; if (value == 0) return 0; var treesVisibleLeft = ValuesLeft(row, x).TakeUntil(left =\u0026gt; left \u0026lt; value).Count(); var treesVisibleRight = ValuesRight(row, x).TakeUntil(right =\u0026gt; right \u0026lt; value).Count(); var treesVisibleUp = ValuesUp(grid, x, y).TakeUntil(up =\u0026gt; up \u0026lt; value).Count(); var treesVisibleDown = ValuesDown(grid, x, y).TakeUntil(down =\u0026gt; down \u0026lt; value).Count(); var scenicScore = treesVisibleLeft * treesVisibleRight * treesVisibleUp * treesVisibleDown; return scenicScore; }) .Max(); Console.WriteLine($\u0026#34;Highest Scenic Score: {highestScenicScore}\u0026#34;); } Conclusion This puzzle was really fun. By now you should notice that I\u0026rsquo;m a big fan of LINQ and this puzzle perfectly showcases its power and style. Style is really important because you can create the most optimized one liner ever, but nobody will end up understanding what the hell you did. With LINQ you can write fast code that describes itself due to the way extension methods work. Overall I\u0026rsquo;m very pleased with this puzzle and my solution.\nhttps://www.reddit.com/r/adventofcode/comments/zg5u6x/2022_day_8_found_a_nice_spot/\nhttps://www.reddit.com/r/adventofcode/comments/zfqfsh/2022_day_8_im_gonna_make_em_all_visible/\nhttps://www.reddit.com/r/adventofcode/comments/zftey0/2022_day_8_dont_build_your_tree_house_on_the_edge/\n","permalink":"https://erri120.github.io/posts/2022-12-08/","summary":"Day 8: Treetop Tree House","title":"Advent of Code 2022: Day 8"},{"content":"Day 7 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 7: No Space Left On Device Links: Puzzle Page, My Code\nPart One Description You can hear birds chirping and raindrops hitting leaves as the expedition proceeds. Occasionally, you can even hear much louder sounds in the distance; how big do the animals get out here, anyway?\nThe device the Elves gave you has problems with more than just its communication system. You try to run a system update:\n1 2 $ system-update --please --pretty-please-with-sugar-on-top Error: No space left on device Perhaps you can delete some files to make space for the update?\nYou browse around the filesystem to assess the situation and save the resulting terminal output (your puzzle input). For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ cd / $ ls dir a 14848514 b.txt 8504156 c.dat dir d $ cd a $ ls dir e 29116 f 2557 g 62596 h.lst $ cd e $ ls 584 i $ cd .. $ cd .. $ cd d $ ls 4060174 j 8033020 d.log 5626152 d.ext 7214296 k The filesystem consists of a tree of files (plain data) and directories (which can contain other directories or files). The outermost directory is called /. You can navigate around the filesystem, moving into or out of directories and listing the contents of the directory you\u0026rsquo;re currently in.\nWithin the terminal output, lines that begin with $ are commands you executed, very much like some modern computers:\ncd means change directory. This changes which directory is the current directory, but the specific result depends on the argument: cd x moves in one level: it looks in the current directory for the directory named x and makes it the current directory. cd .. moves out one level: it finds the directory that contains the current directory, then makes that directory the current directory. cd / switches the current directory to the outermost directory, /. ls means list. It prints out all of the files and directories immediately contained by the current directory: 123 abc means that the current directory contains a file named abc with size 123. dir xyz means that the current directory contains a directory named xyz. Given the commands and output in the example above, you can determine that the filesystem looks visually like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 - / (dir) - a (dir) - e (dir) - i (file, size=584) - f (file, size=29116) - g (file, size=2557) - h.lst (file, size=62596) - b.txt (file, size=14848514) - c.dat (file, size=8504156) - d (dir) - j (file, size=4060174) - d.log (file, size=8033020) - d.ext (file, size=5626152) - k (file, size=7214296) Here, there are four directories: / (the outermost directory), a and d (which are in /), and e (which is in a). These directories also contain files of various sizes.\nSince the disk is full, your first step should probably be to find directories that are good candidates for deletion. To do this, you need to determine the total size of each directory. The total size of a directory is the sum of the sizes of the files it contains, directly or indirectly. (Directories themselves do not count as having any intrinsic size.)\nThe total sizes of the directories above can be found as follows:\nThe total size of directory e is 584 because it contains a single file i of size 584 and no other directories. The directory a has total size 94853 because it contains files f (size 29116), g (size 2557), and h.lst (size 62596), plus file i indirectly (a contains e which contains i). Directory d has total size 24933642. As the outermost directory, / contains every file. Its total size is 48381165, the sum of the size of every file. To begin, find all of the directories with a total size of at most 100000, then calculate the sum of their total sizes. In the example above, these directories are a and e; the sum of their total sizes is 95437 (94853 + 584). (As in this example, this process can count files more than once!)\nFind all of the directories with a total size of at most 100000. What is the sum of the total sizes of those directories?\nThings are finally starting to get interesting. This problem can be solved in numerous ways, but I decided to go with the simplest solution of building out the filesystem structure with classes and iterating over it with recursion. Because the input is just a list of commands of someone navigating the filesystem, using a dictionary with the path as the key and the entry as the value is another way of doing things.\nWhat does a filesystem have? Directories and Files. You could do something really fancy with inheritance, but this is the most straightforward implementation:\n1 2 3 4 5 6 7 8 9 10 11 public sealed class FileSystem { public DirectoryEntry TopDirectory { get; } public DirectoryEntry CurrentDirectory { get; private set; } public FileSystem() { TopDirectory = new DirectoryEntry(\u0026#34;/\u0026#34;, null); CurrentDirectory = TopDirectory; } } We will use this FileSystem to track the current directory. Directories have a name, subdirectories, files and a parent directory (unless it\u0026rsquo;s the top directory):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public sealed class DirectoryEntry { private readonly List\u0026lt;DirectoryEntry\u0026gt; _subDirectories = new(); private readonly List\u0026lt;FileEntry\u0026gt; _files = new(); public string Name { get; } public DirectoryEntry? Parent { get; } public IEnumerable\u0026lt;DirectoryEntry\u0026gt; SubDirectories =\u0026gt; _subDirectories; public IEnumerable\u0026lt;FileEntry\u0026gt; Files =\u0026gt; _files; public DirectoryEntry(string name, DirectoryEntry? parent) { Name = name; Parent = parent; } public void AddSubDirectory(DirectoryEntry directoryEntry) { _subDirectories.Add(directoryEntry); } public void AddFile(FileEntry fileEntry) { _files.Add(fileEntry); } } Files are much simpler, because they only have a name, a parent directory and a file size:\n1 2 3 4 5 6 7 8 9 10 11 12 13 public sealed class FileEntry { public string Name { get; } public DirectoryEntry Parent { get; } public long Size { get; } public FileEntry(string name, DirectoryEntry parent, long size) { Name = name; Parent = parent; Size = size; } } One thing I want to note here is the use of long. This signed 64-bit integer can range in value from -9,223,372,036,854,775,808 through 9,223,372,036,854,775,807. Assuming that a file size is stored as bytes, the maximum value would be ~9223 Petabytes. This is more than enough for anything this puzzle might throw at us. The .NET class FileInfo also uses long to represent file sizes however other languages such as Rust use usize which is an unsigned 64-bit integer. C# also has ulong, however this type is rarely used because it doesn\u0026rsquo;t have all APIs available that long has, mainly because it is not CLS-compliant.\nBut enough about integers. We have our data types, now we need to parse the input:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private static FileSystem BuildFileSystem(IEnumerable\u0026lt;string\u0026gt; lines) { var fs = new FileSystem(); foreach (var line in lines) { if (line.StartsWith(\u0026#39;$\u0026#39;)) { var fullCommand = line[2..]; var executable = fullCommand[..2]; switch (executable) { case \u0026#34;cd\u0026#34;: { var target = fullCommand[3..]; break; } case \u0026#34;ls\u0026#34;: break; default: throw new UnreachableException(\u0026#34;aoc doesn\u0026#39;t lie\u0026#34;); } } } return fs; } All commands are prefixed with a dollar sign ($) followed by a space, then the name of the executable, another space and then the arguments: $ cd /. Since there are only two commands (cd and ls) and both are 2 characters long, we can just hardcode this.\nLet\u0026rsquo;s start with cd or change directory:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public DirectoryEntry ChangeDirectory(string to) { switch (to) { case \u0026#34;/\u0026#34;: CurrentDirectory = TopDirectory; break; case \u0026#34;..\u0026#34;: CurrentDirectory = CurrentDirectory.Parent ?? TopDirectory; break; default: { var subDirectory = CurrentDirectory .SubDirectories .First(dir =\u0026gt; dir.Name.Equals(to, StringComparison.OrdinalIgnoreCase)); CurrentDirectory = subDirectory; break; } } return CurrentDirectory; } We have 3 possible inputs arguments: / will navigate to the top directory, .. will navigate to the parent directory and anything else to a subdirectory.\n1 2 3 4 5 6 case \u0026#34;cd\u0026#34;: { var target = fullCommand[3..]; fs.ChangeDirectory(target); break; } The ls command is more interesting. In this puzzle, this command is followed by the contents of the current directory. This means the next lines after the command need to be parsed as directory contents, and we have to stop at the next command. A simple running variable keeping track of whether we are parsing directory contents or not is needed:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 var inLs = false; foreach (var line in lines) { if (line.StartsWith(\u0026#39;$\u0026#39;)) { inLs = false; var fullCommand = line[2..]; var executable = fullCommand[..2]; switch (executable) { case \u0026#34;cd\u0026#34;: { var target = fullCommand[3..]; fs.ChangeDirectory(target); break; } case \u0026#34;ls\u0026#34;: inLs = true; break; default: throw new UnreachableException(\u0026#34;aoc doesn\u0026#39;t lie\u0026#34;); } continue; } if (!inLs) throw new UnreachableException(\u0026#34;what is this?\u0026#34;); } As for parsing the output itself, the command will list files and directories. Directories start with a dir and files with their file sizes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 var split = line.Split(\u0026#39; \u0026#39;, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries); if (split.Length != 2) throw new UnreachableException(\u0026#34;aoc please don\u0026#39;t lie\u0026#34;); var firstPart = split[0]; if (firstPart == \u0026#34;dir\u0026#34;) { fs.CurrentDirectory.AddSubDirectory(new DirectoryEntry(split[1], fs.CurrentDirectory)); } else { var fileSize = long.Parse(firstPart); fs.CurrentDirectory.AddFile(new FileEntry(split[1], fs.CurrentDirectory, fileSize)); } With this in place, we can parse the input and create a virtual filesystem. But this isn\u0026rsquo;t the goal. The goal is to calculate the sum of all directories with a total size of at most 100000. To do this we first need a member method to calculate the size of a directory:\n1 2 3 4 5 6 7 8 9 10 11 12 private long _cachedSize; public long CalculateSize() { if (_cachedSize != 0) return _cachedSize; var subDirectorySizes = _subDirectories .Select(subDir =\u0026gt; subDir.CalculateSize()) .Sum(); _cachedSize = _files.Select(file =\u0026gt; file.Size).Sum() + subDirectorySizes; return _cachedSize; } There is a bit of recursion going on here, and I\u0026rsquo;ve also opted into using a cache variable because the size won\u0026rsquo;t change. But this isn\u0026rsquo;t the only recursion in my code, we also need to iterate over all directories:\n1 2 3 4 5 6 7 8 9 10 11 12 public IEnumerable\u0026lt;DirectoryEntry\u0026gt; EnumerateAllDirectories() { foreach (var subDirectory in _subDirectories) { yield return subDirectory; foreach (var directory in subDirectory.EnumerateAllDirectories()) { yield return directory; } } } Now we have all the pieces required for the puzzle and solve part one:\n1 2 3 4 5 6 7 8 9 10 private static void PartOne(FileSystem fs) { var totalSize = fs.TopDirectory .EnumerateAllDirectories() .Select(dir =\u0026gt; dir.CalculateSize()) .Where(size =\u0026gt; size \u0026lt;= 100000) .Sum(); Console.WriteLine($\u0026#34;Total Size: {totalSize}\u0026#34;); } Part Two Description Now, you\u0026rsquo;re ready to choose a directory to delete.\nThe total disk space available to the filesystem is 70000000. To run the update, you need unused space of at least 30000000. You need to find a directory you can delete that will free up enough space to run the update.\nIn the example above, the total size of the outermost directory (and thus the total amount of used space) is 48381165; this means that the size of the unused space must currently be 21618835, which isn\u0026rsquo;t quite the 30000000 required by the update. Therefore, the update still requires a directory with total size of at least 8381165 to be deleted before it can run.\nTo achieve this, you have the following options:\nDelete directory e, which would increase unused space by 584. Delete directory a, which would increase unused space by 94853. Delete directory d, which would increase unused space by 24933642. Delete directory /, which would increase unused space by 48381165. Directories e and a are both too small; deleting them would not free up enough space. However, directories d and / are both big enough! Between these, choose the smallest: d, increasing unused space by 24933642.\nFind the smallest directory that, if deleted, would free up enough space on the filesystem to run the update. What is the total size of that directory?\nThere isn\u0026rsquo;t enough space available for the update, and we need to find the smallest directory that would free up enough space for it. Let\u0026rsquo;s start by knowing how much that is:\n1 2 3 4 5 6 7 8 9 10 const long maxAvailableSpace = 70000000; const long requiredAvailableSpace = 30000000; var totalSize = fs.TopDirectory.CalculateSize(); var currentAvailableSpace = maxAvailableSpace - totalSize; if (currentAvailableSpace \u0026gt;= requiredAvailableSpace) throw new UnreachableException(\u0026#34;aoc doesn\u0026#39;t lie\u0026#34;); var currentSpaceRequired = requiredAvailableSpace - currentAvailableSpace; The directory we have to find must be bigger and or equal to currentSpaceRequired. Thankfully we already have everyything we need and can reuse the previous code:\n1 2 3 4 5 6 7 var (dir, size) = fs.TopDirectory .EnumerateAllDirectories() .Select(dir =\u0026gt; (Dir: dir, Size: dir.CalculateSize())) .OrderBy(pair =\u0026gt; pair.Size) .First(pair =\u0026gt; pair.Size \u0026gt;= currentSpaceRequired); Console.WriteLine($\u0026#34;Directory {dir.Name} needs to be deleted to reclaim {size} bytes\u0026#34;); Conclusion Yesterday\u0026rsquo;s puzzle was way too easy, so I\u0026rsquo;m happy to see something more involving than window sliding. That being said, this puzzle allows for a lot of different solutions and introduces new programmers to recursion.\nhttps://www.reddit.com/r/adventofcode/comments/zettdz/2022_day_7_there_it_is_the_most_dangerous_tree_in/\nhttps://www.reddit.com/r/adventofcode/comments/zeuknv/2022_day_7_the_last_3_days_of_challenges/\n","permalink":"https://erri120.github.io/posts/2022-12-07/","summary":"Day 7: No Space Left On Device","title":"Advent of Code 2022: Day 7"},{"content":"Day 6 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 6: Tuning Trouble Links: Puzzle Page, My Code\nPart One Description The preparations are finally complete; you and the Elves leave camp on foot and begin to make your way toward the star fruit grove.\nAs you move through the dense undergrowth, one of the Elves gives you a handheld device. He says that it has many fancy features, but the most important one to set up right now is the communication system.\nHowever, because he\u0026rsquo;s heard you have significant experience dealing with signal-based systems, he convinced the other Elves that it would be okay to give you their one malfunctioning device - surely you\u0026rsquo;ll have no problem fixing it.\nAs if inspired by comedic timing, the device emits a few colorful sparks.\nTo be able to communicate with the Elves, the device needs to lock on to their signal. The signal is a series of seemingly-random characters that the device receives one at a time.\nTo fix the communication system, you need to add a subroutine to the device that detects a start-of-packet marker in the datastream. In the protocol being used by the Elves, the start of a packet is indicated by a sequence of four characters that are all different.\nThe device will send your subroutine a datastream buffer (your puzzle input); your subroutine needs to identify the first position where the four most recently received characters were all different. Specifically, it needs to report the number of characters from the beginning of the buffer to the end of the first such four-character marker.\nFor example, suppose you receive the following datastream buffer:\n1 mjqjpqmgbljsphdztnvjfqwrcgsmlb After the first three characters (mjq) have been received, there haven\u0026rsquo;t been enough characters received yet to find the marker. The first time a marker could occur is after the fourth character is received, making the most recent four characters mjqj. Because j is repeated, this isn\u0026rsquo;t a marker.\nThe first time a marker appears is after the seventh character arrives. Once it does, the last four characters received are jpqm, which are all different. In this case, your subroutine should report the value 7, because the first start-of-packet marker is complete after 7 characters have been processed.\nHere are a few more examples:\nbvwbjplbgvbhsrlpgdmjqwftvncz: first marker after character 5 nppdvjthqldpwncqszvftbrmjlhg: first marker after character 6 nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg: first marker after character 10 zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw: first marker after character 11 How many characters need to be processed before the first start-of-packet marker is detected?\nThis puzzle is very easy and straightforward. We just need to look for a group of 4 unique characters in a string:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private static void PartOne(string contents) { for (var i = 0; i \u0026lt; contents.Length; i++) { if (i + 4 \u0026gt; contents.Length) continue; var range = new Range(i, i + 4); var group = contents[range]; var onlyUnique = group.Distinct().Count() == 4; if (!onlyUnique) continue; Console.WriteLine($\u0026#34;start-of-packet marker: \u0026#39;{group}\u0026#39; ({range})\u0026#34;); } throw new UnreachableException(); } With Range we can easily do a substring on the input and using LINQ Enumerable.Distinct + Enumerable.Count it is trivial to count the number of unique characters.\nPart Two Description Your device\u0026rsquo;s communication system is correctly detecting packets, but still isn\u0026rsquo;t working. It looks like it also needs to look for messages.\nA start-of-message marker is just like a start-of-packet marker, except it consists of 14 distinct characters rather than 4.\nHere are the first positions of start-of-message markers for all of the above examples:\nmjqjpqmgbljsphdztnvjfqwrcgsmlb: first marker after character 19 bvwbjplbgvbhsrlpgdmjqwftvncz: first marker after character 23 nppdvjthqldpwncqszvftbrmjlhg: first marker after character 23 nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg: first marker after character 29 zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw: first marker after character 26 How many characters need to be processed before the first start-of-message marker is detected?\nPart two is essentially the same thing as part one, expect we are now looking for a substring of unique characters with length 14. We can just refactor the previous solution into a more general purpose method:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private static Range FindMarker(string contents, int markerLength) { for (var i = 0; i \u0026lt; contents.Length; i++) { if (i + markerLength \u0026gt; contents.Length) continue; var range = new Range(i, i + markerLength); var group = contents[range]; var onlyUnique = group.Distinct().Count() == markerLength; if (onlyUnique) return range; } throw new UnreachableException(); } This makes it trivial to find markers of any length.\n1 2 3 4 5 6 7 8 9 10 public static async Task Main() { var contents = await File.ReadAllTextAsync(\u0026#34;input.txt\u0026#34;, Encoding.UTF8); var partOne = FindMarker(contents, 4); var partTwo = FindMarker(contents, 14); Console.WriteLine($\u0026#34;start-of-packet marker: \u0026#39;{contents[partOne]}\u0026#39; ({partOne})\u0026#34;); Console.WriteLine($\u0026#34;start-of-message marker: \u0026#39;{contents[partTwo]}\u0026#39; ({partTwo})\u0026#34;); } Conclusion This has been the second-easiest puzzle so far. The only one easier than this was the first puzzle.\nhttps://www.reddit.com/r/adventofcode/comments/ze1gkc/20152022_any_day_incompetence/\nhttps://www.reddit.com/r/adventofcode/comments/ze65ji/2022_day_6_it_cant_be_that_easy/\n","permalink":"https://erri120.github.io/posts/2022-12-06/","summary":"Day 6: Supply Stacks","title":"Advent of Code 2022: Day 6"},{"content":"Day 5 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 5: Supply Stacks Links: Puzzle Page, My Code\nPart One Description The expedition can depart as soon as the final supplies have been unloaded from the ships. Supplies are stored in stacks of marked crates, but because the needed supplies are buried under many other crates, the crates need to be rearranged.\nThe ship has a giant cargo crane capable of moving crates between stacks. To ensure none of the crates get crushed or fall over, the crane operator will rearrange them in a series of carefully-planned steps. After the crates are rearranged, the desired crates will be at the top of each stack.\nThe Elves don\u0026rsquo;t want to interrupt the crane operator during this delicate procedure, but they forgot to ask her which crate will end up where, and they want to be ready to unload them as soon as possible so they can embark.\nThey do, however, have a drawing of the starting stacks of crates and the rearrangement procedure (your puzzle input). For example:\n1 2 3 4 5 6 7 8 9 [D] [N] [C] [Z] [M] [P] 1 2 3 move 1 from 2 to 1 move 3 from 1 to 3 move 2 from 2 to 1 move 1 from 1 to 2 In this example, there are three stacks of crates. Stack 1 contains two crates: crate Z is on the bottom, and crate N is on top. Stack 2 contains three crates; from bottom to top, they are crates M, C, and D. Finally, stack 3 contains a single crate, P.\nThen, the rearrangement procedure is given. In each step of the procedure, a quantity of crates is moved from one stack to a different stack. In the first step of the above rearrangement procedure, one crate is moved from stack 2 to stack 1, resulting in this configuration:\n1 2 3 4 [D] [N] [C] [Z] [M] [P] 1 2 3 In the second step, three crates are moved from stack 1 to stack 3. Crates are moved one at a time, so the first crate to be moved (D) ends up below the second and third crates:\n1 2 3 4 5 [Z] [N] [C] [D] [M] [P] 1 2 3 Then, both crates are moved from stack 2 to stack 1. Again, because crates are moved one at a time, crate C ends up below crate M:\n1 2 3 4 5 [Z] [N] [M] [D] [C] [P] 1 2 3 Finally, one crate is moved from stack 1 to stack 2:\n1 2 3 4 5 [Z] [N] [D] [C] [M] [P] 1 2 3 The Elves just need to know which crate will end up on top of each stack; in this example, the top crates are C in stack 1, M in stack 2, and Z in stack 3, so you should combine these together and give the Elves the message CMZ.\nAfter the rearrangement procedure completes, what crate ends up on top of each stack?\nThe hardest part about this puzzle is parsing the input file.\n1 2 3 4 5 6 7 8 9 [D] [N] [C] [Z] [M] [P] 1 2 3 move 1 from 2 to 1 move 3 from 1 to 3 move 2 from 2 to 1 move 1 from 1 to 2 The file has two regions, 1) the starting state of the stacks and 2) rearrangement procedures. Let\u0026rsquo;s start by reading the file and separating those two regions.\n1 2 3 4 5 6 var input = await File.ReadAllTextAsync(\u0026#34;input.txt\u0026#34;, Encoding.UTF8); var split = input.Split(\u0026#34;\\n\\n\u0026#34;, StringSplitOptions.RemoveEmptyEntries); var stackDefinitions = split[0]; var procedures = split[1]; Similar to the Day 1 puzzle we use String.Split to separate the input at the empty line. Parsing the stack definitions seems scary, so let\u0026rsquo;s parse the procedures first. Like in the previous day I decided to use a readonly struct that stores the procedures:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public readonly struct RearrangementProcedure { public readonly int Count; public readonly int From; public readonly int To; public RearrangementProcedure(int count, int from, int to) { Count = count; From = from; To = to; } public override string ToString() { return $\u0026#34;move {Count} from {From} to {To}\u0026#34;; } } Parsing move i from a to b is pretty straight forward, and you can use a multitude of solutions. I decided to use a simple regex pattern to match a line.\n1 2 3 4 private static readonly Regex ParseRegex = new( @\u0026#34;move (?\u0026lt;count\u0026gt;\\d+) from (?\u0026lt;from\u0026gt;\\d+) to (?\u0026lt;to\u0026gt;\\d+)\u0026#34;, RegexOptions.Compiled, TimeSpan.FromMilliseconds(500)); The Regex implementation in .NET has quite a lot of nuances and options you can tweak to make it go faster. For one, we can use RegexOptions.Compiled to create a compiled regex. Such a regex is compiled to MSIL code instead of being interpreted, maximizing run-time performance at the expense of some initialization time. This is great since we will be parsing a lot of lines with this. The last parameter of the Regex Constructor is a TimeSpan that specifies a time-out interval. This isn\u0026rsquo;t required but considered good practice when using regex to prevent a denial of service attack.\n1 2 3 4 5 6 7 8 9 10 11 public static RearrangementProcedure FromString(string line) { var match = ParseRegex.Match(line); if (!match.Success) throw new ArgumentException($\u0026#34;Invalid argument: {line}\u0026#34;, nameof(line)); var sCount = match.Groups[\u0026#34;count\u0026#34;].Value; var sFrom = match.Groups[\u0026#34;from\u0026#34;].Value; var sTo = match.Groups[\u0026#34;to\u0026#34;].Value; return new RearrangementProcedure(int.Parse(sCount), int.Parse(sFrom), int.Parse(sTo)); } With our regex in hand, parsing a line is very straight forward. Since the regex includes named groups, we can access them very easily.\nNow it\u0026rsquo;s time to deal with the stacks:\n1 2 3 4 [D] [N] [C] [Z] [M] [P] 1 2 3 Before parsing the input, we need to think about how we are going to represent these stacks. Each stack has a unique identifier and a collection of crates. The crates are just single characters, so we can use char for those. Since each stack has a unique identifier, a Dictionary\u0026lt;TKey, TValue\u0026gt; with an int as the key type allows for easy access. The question is which collection type should we just for the crates. Thankfully .NET already comes with a built-in Stack\u0026lt;T\u0026gt; class. Putting this all together our parsing function will have the following signature:\n1 private static Dictionary\u0026lt;int, Stack\u0026lt;char\u0026gt;\u0026gt; CreateStacks(string input); The beauty of advent of code is how much freedom you have in dealing with problems. Since you need to produce the correct result only once, your code doesn\u0026rsquo;t have to work with every input. We can abuse this fact and create a very simple parser. Let\u0026rsquo;s start by parsing all stack identifiers:\n1 2 3 4 5 6 7 var lines = input.Split(\u0026#39;\\n\u0026#39;, StringSplitOptions.RemoveEmptyEntries); var stackIDLine = lines.Last(); var stackIDs = stackIDLine .Where(char.IsAsciiDigit) .Select(c =\u0026gt; int.Parse($\u0026#34;{c}\u0026#34;)) .ToArray(); Since a C# string also implements IEnumerable\u0026lt;char\u0026gt; we can use LINQ extension methods with it. This code only works if there are less than 10 stacks. My input only had stacks 1 to 9.\n1 2 3 var stacks = stackIDs.ToDictionary( stackID =\u0026gt; stackID, _ =\u0026gt; new Stack\u0026lt;char\u0026gt;(lines.Length - 1)); We want a Dictionary\u0026lt;int, Stack\u0026lt;char\u0026gt;\u0026gt;, and we have already parsed the identifiers and put them into an array. The extension method Enumerable.ToDictionary creates a dictionary from an enumerable according to specified key and element selector functions. The key is going to be the stack identifier but for the element we want a new Stack\u0026lt;T\u0026gt;. The constructor accepts an initial capacity, so I set it to the maximum number of crates.\nNow it\u0026rsquo;s time to talk about stacks. They represent a last-in-first-out (LIFO) collection and the essential stack functions are:\npush: pushes a new value onto the stack pop: removes the first value off the stack and returns it peak: returns the first value without removing it LIFO means if we add A, B and C the value we get by using pop is C because it is the last-in and first-out. That being said, let\u0026rsquo;s parse those crates:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var enumerable = lines.Take(lines.Length - 1).Reverse(); foreach (var line in enumerable) { var i = 0; foreach (var stackID in stackIDs) { var crate = line[i + 1]; i += 4; if (crate == \u0026#39; \u0026#39;) continue; stacks[stackID].Push(crate); } } LIFO means we have to use Enumerable.Reverse and read the crates from bottom to top. This way the last-in and first-out is the top crate. As for parsing I\u0026rsquo;m just using a counter i for the current position in the line and advance it by +4 for every stack. Why 4? Because [A] is 4 characters. Once again we can make our lives very easy because the input only has this format. We don\u0026rsquo;t have to make our code work with every possible input, only the one we have.\nNow let\u0026rsquo;s recap really quick: we have parsed all rearrangement procedures and stacks. Now we just need to iterate over all procedures and apply them on the stacks:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private static void ApplyProceduresOnStacks( IReadOnlyDictionary\u0026lt;int, Stack\u0026lt;char\u0026gt;\u0026gt; stacks, IEnumerable\u0026lt;RearrangementProcedure\u0026gt; procedures) { foreach (var procedure in procedures) { var fromStack = stacks[procedure.From]; var toStack = stacks[procedure.To]; var count = procedure.Count; foreach (var value in fromStack.Take(count)) { fromStack.Pop(); toStack.Push(value); } } } A Stack\u0026lt;T\u0026gt; in .NET implements IEnumerable\u0026lt;T\u0026gt; meaning we can also fully use LINQ on it. Instead of using a for-i loop we can use foreach and Enumerable.Take to take the required number of crates, pop them from the stack and push them onto the other stack.\nThe last thing we need is putting all of this together and printing out the result:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static async Task Main() { var input = await File.ReadAllTextAsync(\u0026#34;input.txt\u0026#34;, Encoding.UTF8); var split = input.Split(\u0026#34;\\n\\n\u0026#34;, StringSplitOptions.RemoveEmptyEntries); var stacks = CreateStacks(split[0]); var procedures = CreateRearrangementProcedures(split[1]); ApplyProceduresOnStacks(stacks, procedures); Console.WriteLine($\u0026#34;Part One: {CreateMessage(stacks)}\u0026#34;); } private static string CreateMessage(IReadOnlyDictionary\u0026lt;int, Stack\u0026lt;char\u0026gt;\u0026gt; stacks) { return stacks .Select(kv =\u0026gt; kv.Value) .Select(stack =\u0026gt; stack.First()) .Aggregate(\u0026#34;\u0026#34;, (a, b) =\u0026gt; $\u0026#34;{a}{b}\u0026#34;); } Part Two Description As you watch the crane operator expertly rearrange the crates, you notice the process isn\u0026rsquo;t following your prediction.\nSome mud was covering the writing on the side of the crane, and you quickly wipe it away. The crane isn\u0026rsquo;t a CrateMover 9000 - it\u0026rsquo;s a CrateMover 9001.\nThe CrateMover 9001 is notable for many new and exciting features: air conditioning, leather seats, an extra cup holder, and the ability to pick up and move multiple crates at once.\nAgain considering the example above, the crates begin in the same configuration:\n1 2 3 4 [D] [N] [C] [Z] [M] [P] 1 2 3 Moving a single crate from stack 2 to stack 1 behaves the same as before:\n1 2 3 4 [D] [N] [C] [Z] [M] [P] 1 2 3 However, the action of moving three crates from stack 1 to stack 3 means that those three moved crates stay in the same order, resulting in this new configuration:\n1 2 3 4 5 [D] [N] [C] [Z] [M] [P] 1 2 3 Next, as both crates are moved from stack 2 to stack 1, they retain their order as well:\n1 2 3 4 5 [D] [N] [C] [Z] [M] [P] 1 2 3 Finally, a single crate is still moved from stack 1 to stack 2, but now it\u0026rsquo;s crate C that gets moved:\n1 2 3 4 5 [D] [N] [Z] [M] [C] [P] 1 2 3 In this example, the CrateMover 9001 has put the crates in a totally different order: MCD.\nBefore the rearrangement process finishes, update your simulation so that the Elves know where they should stand to be ready to unload the final supplies. After the rearrangement procedure completes, what crate ends up on top of each stack?\nThe second part is so easy to implement, we literally just have to change two lines:\n1 2 3 4 5 6 7 var enumerable = isPartOne ? fromStack.Take(count).ToArray() : fromStack.Take(count).Reverse().ToArray(); foreach (var value in enumerable) { fromStack.Pop(); toStack.Push(value); } Conclusion The puzzles are starting to become more interesting. Looking at the subreddit and discussions a lot of people have issues with parsing the input this time around which is unsurprising, given how scary it initially looks.\nhttps://www.reddit.com/r/adventofcode/comments/zcxzdi/2022_day_5_yeah_the_9000_series_was_alright_and/\nhttps://www.reddit.com/r/adventofcode/comments/zd1hqy/2022_day_5_i_know_i_am_overthinking_it/\n","permalink":"https://erri120.github.io/posts/2022-12-05/","summary":"Day 5: Supply Stacks","title":"Advent of Code 2022: Day 5"},{"content":"Day 4 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 4: Camp Cleanup Links: Puzzle Page, My Code\nPart One Description Space needs to be cleared before the last supplies can be unloaded from the ships, and so several Elves have been assigned the job of cleaning up sections of the camp. Every section has a unique ID number, and each Elf is assigned a range of section IDs.\nHowever, as some of the Elves compare their section assignments with each other, they\u0026rsquo;ve noticed that many of the assignments overlap. To try to quickly find overlaps and reduce duplicated effort, the Elves pair up and make a big list of the section assignments for each pair (your puzzle input).\nFor example, consider the following list of section assignment pairs:\n1 2 3 4 5 6 2-4,6-8 2-3,4-5 5-7,7-9 2-8,3-7 6-6,4-6 2-6,4-8 For the first few pairs, this list means:\nWithin the first pair of Elves, the first Elf was assigned sections 2-4 (sections 2, 3, and 4), while the second Elf was assigned sections 6-8 (sections 6, 7, 8). The Elves in the second pair were each assigned two sections. The Elves in the third pair were each assigned three sections: one got sections 5, 6, and 7, while the other also got 7, plus 8 and 9. This example list uses single-digit section IDs to make it easier to draw; your actual list might contain larger numbers. Visually, these pairs of section assignments look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .234..... 2-4 .....678. 6-8 .23...... 2-3 ...45.... 4-5 ....567.. 5-7 ......789 7-9 .2345678. 2-8 ..34567.. 3-7 .....6... 6-6 ...456... 4-6 .23456... 2-6 ...45678. 4-8 Some of the pairs have noticed that one of their assignments fully contains the other. For example, 2-8 fully contains 3-7, and 6-6 is fully contained by 4-6. In pairs where one assignment fully contains the other, one Elf in the pair would be exclusively cleaning sections their partner will already be cleaning, so these seem like the most in need of reconsideration. In this example, there are 2 such pairs.\nIn how many assignment pairs does one range fully contain the other?\nIt is time for ranges. We get a list of pairs of ranges and need to calculate how many pairs have ranges that fully contain the other. Let\u0026rsquo;s start by parsing the input which looks like this: 1-2,3-4\n1 2 3 var commaIndex = line.IndexOf(\u0026#39;,\u0026#39;); var firstPart = line[..commaIndex]; var secondPart = line[(commaIndex + 1)..]; C# 8 added the Range operator which we can use on strings to create substrings. This is essentially the same as using String.Substring. In fact, C# will actually compile s[index..] into s.Substring(...). You can observe this behavior on SharpLab. The only thing you need be careful about are off-by-one errors which this puzzle has a lot of.\nThe code above will split the line 1-2,3-4 into two parts: 1-2 and 3-4. Next I want to create type to encapsulate these values:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public readonly struct AssignmentRange { public readonly int Start; public readonly int End; public AssignmentRange(int start, int end) { Start = start; End = end; } public static AssignmentRange FromString(string s) { var dashIndex = s.IndexOf(\u0026#39;-\u0026#39;); var startIndex = int.Parse(s[..dashIndex]); var endIndex = int.Parse(s[(dashIndex + 1)..]); return new AssignmentRange(startIndex, endIndex); } public override string ToString() { return $\u0026#34;{Start}..{End}\u0026#34;; } } This is a readonly struct meaning the structure type is immutable, and all data members must have the readonly modifier. We don\u0026rsquo;t have to update these values, so a read-only struct makes sense. I also didn\u0026rsquo;t choose a class for this because classes are reference types and allocated on the heap. A structure is a value type and allocated on the stack. This is ideal for read-only small data types and can often lead to great performance improvements.\nThe struct also has a function to convert 1-2 into an assignment range. This is basically the same as before, but this time we split at a dash (-) instead of a comma (,).\nNow we have to add code that compares two ranges with each other:\n1 2 3 4 public bool ContainsOther(AssignmentRange other) { return Start \u0026lt;= other.Start \u0026amp;\u0026amp; End \u0026gt;= other.End; } This is an instance method of the struct and will check if the other range is contained in the current one. Finally, we put everything together:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private static IEnumerable\u0026lt;(AssignmentRange, AssignmentRange)\u0026gt; ToRanges(this IEnumerable\u0026lt;string\u0026gt; lines) { return lines.Select(line =\u0026gt; { var commaIndex = line.IndexOf(\u0026#39;,\u0026#39;); var firstPart = line[..commaIndex]; var secondPart = line[(commaIndex + 1)..]; var first = AssignmentRange.FromString(firstPart); var second = AssignmentRange.FromString(secondPart); return (first, second); }); } private static int PartOne(IEnumerable\u0026lt;string\u0026gt; lines) { var count = lines.ToRanges() .Select(tuple =\u0026gt; { var (first, second) = tuple; return first.ContainsOther(second) || second.ContainsOther(first); }).Count(x =\u0026gt; x); return count; } The method ToRanges is an Extension Method and will just convert the input lines into two assignment ranges. Other than the that the only thing of note is using Enumerable.Count that returns how many elements in the sequence satisfy our condition.\nPart Two Description It seems like there is still quite a bit of duplicate work planned. Instead, the Elves would like to know the number of pairs that overlap at all.\nIn the above example, the first two pairs (2-4,6-8 and 2-3,4-5) don\u0026rsquo;t overlap, while the remaining four pairs (5-7,7-9, 2-8,3-7, 6-6,4-6, and 2-6,4-8) do overlap:\n5-7,7-9 overlaps in a single section, 7. 2-8,3-7 overlaps all of the sections 3 through 7. 6-6,4-6 overlaps in a single section, 6. 2-6,4-8 overlaps in sections 4, 5, and 6. So, in this example, the number of overlapping assignment pairs is 4.\nIn how many assignment pairs do the ranges overlap?\nInstead of knowing if two ranges fully contain the other, we now check if two ranges overlap which is honestly easier:\n1 2 3 4 private static bool RangesOverlap(AssignmentRange a, AssignmentRange b) { return a.Start \u0026lt;= b.End \u0026amp;\u0026amp; b.Start \u0026lt;= a.End; } Conclusion https://www.reddit.com/r/adventofcode/comments/zc19dz/2022_day_4_wait_i_have_to_clear_all_of_your/\nhttps://www.reddit.com/r/adventofcode/comments/zc4sdc/2022_day_4_mount_of_wasted_effort/\n","permalink":"https://erri120.github.io/posts/2022-12-04/","summary":"Day 4: Camp Cleanup","title":"Advent of Code 2022: Day 4"},{"content":"Day 3 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 3: Rucksack Reorganization Links: Puzzle Page, My Code\nPart One Description One Elf has the important job of loading all of the rucksacks with supplies for the jungle journey. Unfortunately, that Elf didn\u0026rsquo;t quite follow the packing instructions, and so a few items now need to be rearranged.\nEach rucksack has two large compartments. All items of a given type are meant to go into exactly one of the two compartments. The Elf that did the packing failed to follow this rule for exactly one item type per rucksack.\nThe Elves have made a list of all of the items currently in each rucksack (your puzzle input), but they need your help finding the errors. Every item type is identified by a single lowercase or uppercase letter (that is, a and A refer to different types of items).\nThe list of items for each rucksack is given as characters all on a single line. A given rucksack always has the same number of items in each of its two compartments, so the first half of the characters represent items in the first compartment, while the second half of the characters represent items in the second compartment.\nFor example, suppose you have the following list of contents from six rucksacks:\n1 2 3 4 5 6 vJrwpWtwJgWrhcsFMMfFFhFp jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL PmmdzqPrVvPwwTWBwg wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn ttgJtRGJQctTZtZT CrZsJsPPZsGzwwsLwLmpwMDw The first rucksack contains the items vJrwpWtwJgWrhcsFMMfFFhFp, which means its first compartment contains the items vJrwpWtwJgWr, while the second compartment contains the items hcsFMMfFFhFp. The only item type that appears in both compartments is lowercase p. The second rucksack\u0026rsquo;s compartments contain jqHRNqRjqzjGDLGL and rsFMfFZSrLrFZsSL. The only item type that appears in both compartments is uppercase L. The third rucksack\u0026rsquo;s compartments contain PmmdzqPrV and vPwwTWBwg; the only common item type is uppercase P. The fourth rucksack\u0026rsquo;s compartments only share item type v. The fifth rucksack\u0026rsquo;s compartments only share item type t. The sixth rucksack\u0026rsquo;s compartments only share item type s. To help prioritize item rearrangement, every item type can be converted to a priority:\nLowercase item types a through z have priorities 1 through 26. Uppercase item types A through Z have priorities 27 through 52. In the above example, the priority of the item type that appears in both compartments of each rucksack is 16 (p), 38 (L), 42 (P), 22 (v), 20 (t), and 19 (s); the sum of these is 157.\nFind the item type that appears in both compartments of each rucksack. What is the sum of the priorities of those item types?\nWe went from calories to rock paper scissors and have now arrived at packing a backpack. The task is simple:\nfor each line: split the line in half find the intersection between the two halves calculate the priority sum up all the priorities This is honestly not much different from the puzzle of the first day and I once again reached for the power of LINQ:\n1 2 3 4 5 6 7 8 9 10 11 12 13 var lines = await File.ReadAllLinesAsync(\u0026#34;input.txt\u0026#34;, Encoding.UTF8); var summedPriorities = lines .Select(line =\u0026gt; { var firstCompartment = line[..(line.Length / 2)].ToHashSet(); var secondCompartment = line[(line.Length / 2)..].ToHashSet(); firstCompartment.IntersectWith(secondCompartment); return ToPriority(firstCompartment.First()); }).Sum(); return summedPriorities; We just do the usual projection with Enumerable.Select but instead of parsing numbers like in the first puzzle, this time we need to work with sets. A set is a collection that contains no duplicate elements, and whose elements are in no particular order. With .NET we have access to HashSet\u0026lt;T\u0026gt; which provides high-performance set operations.\nJust a quick reminder, set operations come from mathematics. The 3 most common set operations are:\nUnion (A ∪ B): produces a set of all things that belong to A or B or both Intersection (A ∩ B): produces a set of all things that belong to A and B Differences (A \\ B): produces a set of all things that belong to A, but not B In our case we want to find the characters that are in both compartments, so we use HashSet\u0026lt;T\u0026gt;.IntersectWith which modifies the current HashSet\u0026lt;T\u0026gt; to contain only elements that are present in itself and the specified collection (the other compartment).\nNow we only need to convert the character to a priority:\n1 2 3 4 5 6 7 8 9 private static int ToPriority(char c) { return c switch { \u0026gt;= \u0026#39;a\u0026#39; and \u0026lt;= \u0026#39;z\u0026#39; =\u0026gt; c - 96, \u0026gt;= \u0026#39;A\u0026#39; and \u0026lt;= \u0026#39;Z\u0026#39; =\u0026gt; c - 38, _ =\u0026gt; throw new UnreachableException() }; } Once again we are using the amazing C# 7 and 8 Pattern matching and the new switch expressions to calculate the right priority depending on the case of the character. A character can be converted to an integer however we need to offset it by a fixed amount. C# strings are UTF-16 encoded meaning a is 95, z is 122, A is 65 and Z is 90. If you don\u0026rsquo;t know how Encoding words, I\u0026rsquo;ve got a great post about it.\nPart Two Description As you finish identifying the misplaced items, the Elves come to you with another issue.\nFor safety, the Elves are divided into groups of three. Every Elf carries a badge that identifies their group. For efficiency, within each group of three Elves, the badge is the only item type carried by all three Elves. That is, if a group\u0026rsquo;s badge is item type B, then all three Elves will have item type B somewhere in their rucksack, and at most two of the Elves will be carrying any other item type.\nThe problem is that someone forgot to put this year\u0026rsquo;s updated authenticity sticker on the badges. All of the badges need to be pulled out of the rucksacks so the new authenticity stickers can be attached.\nAdditionally, nobody wrote down which item type corresponds to each group\u0026rsquo;s badges. The only way to tell which item type is the right one is by finding the one item type that is common between all three Elves in each group.\nEvery set of three lines in your list corresponds to a single group, but each group can have a different badge item type. So, in the above example, the first group\u0026rsquo;s rucksacks are the first three lines:\nvJrwpWtwJgWrhcsFMMfFFhFp jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL PmmdzqPrVvPwwTWBwg And the second group\u0026rsquo;s rucksacks are the next three lines:\nwMqvLMZHhHMvwLHjbvcjnnSBnvTQFn ttgJtRGJQctTZtZT CrZsJsPPZsGzwwsLwLmpwMDw In the first group, the only item type that appears in all three rucksacks is lowercase r; this must be their badges. In the second group, their badge item type must be Z.\nPriorities for these items must still be found to organize the sticker attachment efforts: here, they are 18 (r) for the first group and 52 (Z) for the second group. The sum of these is 70.\nFind the item type that corresponds to the badges of each three-Elf group. What is the sum of the priorities of those item types?\nPart Two requires us to find the intersection of 3 lines at once:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private static int PartTwo(IEnumerable\u0026lt;string\u0026gt; lines) { var result = lines .Chunk(3) .Select(chunk =\u0026gt; chunk .Select(line =\u0026gt; line.ToHashSet()) .Aggregate((accumulate, next) =\u0026gt; { accumulate.IntersectWith(next); return accumulate; }) .Select(ToPriority) .First() ).Sum(); return result; } Aside from utilizing Enumerable.Chunk to split the lines into chunks of size 3, there isn\u0026rsquo;t much to explain here. The real hero is the Enumerable.Aggregate function. With aggregation, you apply an accumulator function over a sequence. Normally you have to specify a starting value of the accumulator but the overload function I used simply uses the first value of the sequence. This accumulator is then modified each iteration using HashSet\u0026lt;T\u0026gt;.IntersectWith, and finally we calculate the priority again and sum it all up.\nConclusion This puzzle was actually easier than the last one and only tests you on your set knowledge. I can definitely imagine how the second part might create some hideous code if you can\u0026rsquo;t properly chunk the lines with whatever language and libraries you might be using. Converting characters into integers is also a classic move and fits an early puzzle such as this perfectly.\nhttps://www.reddit.com/r/adventofcode/comments/zb8dag/2022_day_3_no_get_your_own_rucksack/\nhttps://www.reddit.com/r/adventofcode/comments/zbc2w5/elves_today_be_like/\n","permalink":"https://erri120.github.io/posts/2022-12-03/","summary":"Day 3: Rucksack Reorganization","title":"Advent of Code 2022: Day 3"},{"content":"Day 2 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 2: Rock Paper Scissors Links: Puzzle Page, My Code\nPart One Description The Elves begin to set up camp on the beach. To decide whose tent gets to be closest to the snack storage, a giant Rock Paper Scissors tournament is already in progress.\nRock Paper Scissors is a game between two players. Each game contains many rounds; in each round, the players each simultaneously choose one of Rock, Paper, or Scissors using a hand shape. Then, a winner for that round is selected: Rock defeats Scissors, Scissors defeats Paper, and Paper defeats Rock. If both players choose the same shape, the round instead ends in a draw.\nAppreciative of your help yesterday, one Elf gives you an encrypted strategy guide (your puzzle input) that they say will be sure to help you win. \u0026ldquo;The first column is what your opponent is going to play: A for Rock, B for Paper, and C for Scissors. The second column\u0026ndash;\u0026rdquo; Suddenly, the Elf is called away to help with someone\u0026rsquo;s tent.\nThe second column, you reason, must be what you should play in response: X for Rock, Y for Paper, and Z for Scissors. Winning every time would be suspicious, so the responses must have been carefully chosen.\nThe winner of the whole tournament is the player with the highest score. Your total score is the sum of your scores for each round. The score for a single round is the score for the shape you selected (1 for Rock, 2 for Paper, and 3 for Scissors) plus the score for the outcome of the round (0 if you lost, 3 if the round was a draw, and 6 if you won).\nSince you can\u0026rsquo;t be sure if the Elf is trying to help you or trick you, you should calculate the score you would get if you were to follow the strategy guide.\nFor example, suppose you were given the following strategy guide:\n1 2 3 A Y B X C Z This strategy guide predicts and recommends the following:\nIn the first round, your opponent will choose Rock (A), and you should choose Paper (Y). This ends in a win for you with a score of 8 (2 because you chose Paper + 6 because you won). In the second round, your opponent will choose Paper (B), and you should choose Rock (X). This ends in a loss for you with a score of 1 (1 + 0). The third round is a draw with both players choosing Scissors, giving you a score of 3 + 3 = 6. In this example, if you were to follow the strategy guide, you would get a total score of 15 (8 + 1 + 6).\nWhat would your total score be if everything goes exactly according to your strategy guide?\nIt\u0026rsquo;s time for everyone\u0026rsquo;s favorite game \u0026ldquo;Rock paper scissors\u0026rdquo;/\u0026ldquo;Schere, Stein, Papier\u0026rdquo;/\u0026ldquo;Pierre-papier-ciseaux\u0026rdquo;/\u0026ldquo;Piedra, papel o tijera\u0026rdquo;/\u0026ldquo;じゃんけん\u0026rdquo;/\u0026ldquo;石头、剪子、布.\u0026rdquo;\nOur first objective is using the strategy guide we get from an elf to play in the tournament. The guide contains two columns:\nwhat the opponent plays what we should play For this puzzle we need to calculate the total score if we followed the guide.\nLet\u0026rsquo;s start with the basics and define some Enums:\n1 2 3 4 5 6 7 8 9 10 11 12 13 public enum RoundOutcome { Lost = 0, Draw = 3, Won = 6 } public enum Shape { Rock = 1, Paper = 2, Scissors = 3 } An enumeration type in C# is just a set of named constants that map to an underlying integer value. Normally the compiler will just auto-generate the value but in our case we want to explicitly specify it. For the RoundOutcome I\u0026rsquo;m using points we get when the round is lost, a draw or won and for Shape it\u0026rsquo;s the points we get for playing this shape.\nNext we need a function that calculates the round outcome given the opponent input and our input:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private static RoundOutcome CalculateRoundOutcome(char opponentInput, char playerInput) { var opponentShape = opponentInput switch { \u0026#39;A\u0026#39; =\u0026gt; Shape.Rock, \u0026#39;B\u0026#39; =\u0026gt; Shape.Paper, \u0026#39;C\u0026#39; =\u0026gt; Shape.Scissors, _ =\u0026gt; throw new UnreachableException() }; var playerShape = playerInput switch { \u0026#39;X\u0026#39; =\u0026gt; Shape.Rock, \u0026#39;Y\u0026#39; =\u0026gt; Shape.Paper, \u0026#39;Z\u0026#39; =\u0026gt; Shape.Scissors, _ =\u0026gt; throw new UnreachableException() }; //... } Let\u0026rsquo;s start by mapping the raw input we read from the file to our Shape enum. Notice the UnreachableException at the end of the switch statement? This is a new exception in .NET 7 that is thrown when the program executes an instruction that was thought to be unreachable. In our case we have pre-defined inputs and anything else should not match.\nNext we just need to add the rules of the game:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (opponentShape == playerShape) return RoundOutcome.Draw; return (opponentShape, playerShape) switch { (Shape.Rock, Shape.Paper) =\u0026gt; RoundOutcome.Won, (Shape.Rock, Shape.Scissors) =\u0026gt; RoundOutcome.Lost, (Shape.Paper, Shape.Rock) =\u0026gt; RoundOutcome.Lost, (Shape.Paper, Shape.Scissors) =\u0026gt; RoundOutcome.Won, (Shape.Scissors, Shape.Rock) =\u0026gt; RoundOutcome.Won, (Shape.Scissors, Shape.Paper) =\u0026gt; RoundOutcome.Lost, _ =\u0026gt; throw new UnreachableException() }; These are just the basic rules of the game: Rock beats Scissors, Scissors beat Paper, Paper beats Rock. If the players have the same shape it\u0026rsquo;s a draw. The only cool thing about this code is the utilization of Pattern matching and the new switch expressions we got in C# 7 and 8.\nWith the rules in place we just need to calculate the final round score:\n1 2 3 4 5 private static int RoundScore(RoundOutcome outcome, Shape playedShape) { var shapePoints = (int)playedShape; return shapePoints + (int)outcome; } Our enumeration types are just named integers, and we can freely convert between them. The only thing left to do is read the file and get the total score:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static async Task Main() { var totalScore = (await File.ReadAllLinesAsync(\u0026#34;input.txt\u0026#34;, Encoding.UTF8)) .Where(line =\u0026gt; !string.IsNullOrWhiteSpace(line)) .Select(line =\u0026gt; { var opponentInput = line[0]; var playerInput = line[2]; var outcome = CalculateRoundOutcome(opponentInput, playerInput); return RoundScore(outcome, playerShape); }) .Sum(); Console.WriteLine($\u0026#34;Total Score: {totalScore}\u0026#34;); } This solution is okay. With puzzles like these it\u0026rsquo;s always good to implement a naive solution first in order to understand the problem and figure out the correct value. What I don\u0026rsquo;t like about the code is the massive switch expression where the match the opponent shape and the player shape to figure out the round outcome. So here is a more interesting approach using math:\n1 2 3 4 5 6 7 8 var opponentValue = (int)opponentShape; var playerValue = (int)playerShape; if (opponentValue == playerValue) return RoundOutcome.Draw; return opponentValue % 3 + 1 == playerValue ? RoundOutcome.Won : RoundOutcome.Lost; First we cast the shape enumeration value to an integer (1 for Rock, 2 for Paper, 3 for Scissors). A draw is the easiest case to check for since it\u0026rsquo;s just the same input, but how do know if someone won or lost with just numbers? Let\u0026rsquo;s write out every situation and look at the results:\n1 2 3 4 5 6 7 8 9 10 11 1 1 -\u0026gt; draw 2 2 -\u0026gt; draw 3 3 -\u0026gt; draw 1 2 -\u0026gt; won 2 3 -\u0026gt; won 3 1 -\u0026gt; won 1 3 -\u0026gt; lost 2 1 -\u0026gt; lost 3 2 -\u0026gt; lost There is a pattern for the values that win us the game: if the opponent\u0026rsquo;s value offset by 1 and wrapped around to 1 is equal to the player\u0026rsquo;s value, we win.\nPart Two Description The Elf finishes helping with the tent and sneaks back over to you. \u0026ldquo;Anyway, the second column says how the round needs to end: X means you need to lose, Y means you need to end the round in a draw, and Z means you need to win. Good luck!\u0026rdquo;\nThe total score is still calculated in the same way, but now you need to figure out what shape to choose so the round ends as indicated. The example above now goes like this:\nIn the first round, your opponent will choose Rock (A), and you need the round to end in a draw (Y), so you also choose Rock. This gives you a score of 1 + 3 = 4. In the second round, your opponent will choose Paper (B), and you choose Rock so you lose (X) with a score of 1 + 0 = 1. In the third round, you will defeat your opponent\u0026rsquo;s Scissors with Rock for a score of 1 + 6 = 7. Now that you\u0026rsquo;re correctly decrypting the ultra top secret strategy guide, you would get a total score of 12.\nFollowing the Elf\u0026rsquo;s instructions for the second column, what would your total score be if everything goes exactly according to your strategy guide?\nIn Part Two it turns out we misinterpreted the guide and instead of the second column giving us shape to play, it\u0026rsquo;s the outcome we want. Using our newly gained knowledge from the previous part about numbers, we can easily calculate which shape we need to play to get the desired outcome:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private static int PartTwoScore(char opponent, char predictedOutcome) { var opponentShape = OpponentShape(opponent); var opponentValue = (int)opponentShape; var outcome = predictedOutcome switch { \u0026#39;X\u0026#39; =\u0026gt; RoundOutcome.Lost, \u0026#39;Y\u0026#39; =\u0026gt; RoundOutcome.Draw, \u0026#39;Z\u0026#39; =\u0026gt; RoundOutcome.Won, _ =\u0026gt; throw new UnreachableException() }; var playerValue = outcome switch { RoundOutcome.Lost =\u0026gt; opponentValue == 1 ? 3 : opponentValue - 1, RoundOutcome.Won =\u0026gt; opponentValue % 3 + 1, RoundOutcome.Draw =\u0026gt; (int)opponentShape, _ =\u0026gt; throw new UnreachableException() }; var playerShape = (Shape)playerValue; return RoundScore(outcome, playerShape); } We know the opponent\u0026rsquo;s shape and the round outcome we want. The only thing we need is the player shape which we can get by using the pattern we discovered in part one. The only thing remaining is to update our main function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static async Task Main() { var scores = (await File.ReadAllLinesAsync(\u0026#34;input.txt\u0026#34;, Encoding.UTF8)) .Where(line =\u0026gt; !string.IsNullOrWhiteSpace(line)) .Select(line =\u0026gt; { var a = line[0]; var b = line[2]; var partOne = PartOneScore(a, b); var partTwo = PartTwoScore(a, b); return (partOne, partTwo); }) .ToArray(); var partOneTotalScore = scores.Select(x =\u0026gt; x.partOne).Sum(); var partTwoTotalScore = scores.Select(x =\u0026gt; x.partTwo).Sum(); Console.WriteLine($\u0026#34;Part One - Total Score: {partOneTotalScore}\u0026#34;); Console.WriteLine($\u0026#34;Part Two - Total Score: {partTwoTotalScore}\u0026#34;); } Conclusion This puzzle is very interesting. You can go for the speedrun strategy and use pattern matching to quickly solve this puzzle or take more time to think and realize you can just use numbers. The previous puzzles will likely look similar in every implementation but here you can experiment more and come up with some crazy ideas. It will be interesting to see how the Brainfuck implementation will look like.\nhttps://www.reddit.com/r/adventofcode/comments/zahemk/2022_day_2_data_structures_good_control_flow_bad\n","permalink":"https://erri120.github.io/posts/2022-12-02/","summary":"Day 2: Rock Paper Scissors","title":"Advent of Code 2022: Day 2"},{"content":"Advent of Code is an advent calendar of programming puzzles. Starting on December 1st and ending on December 25th, you will get a puzzle every day and have to solve it. This is the 8th time the event happened, and I will be documenting my solutions here. The code can be found on GitHub.\nDay 1: Calorie Counting Links: Puzzle Page, My Code\nPart One Description The jungle must be too overgrown and difficult to navigate in vehicles or access from the air; the Elves\u0026rsquo; expedition traditionally goes on foot. As your boats approach land, the Elves begin taking inventory of their supplies. One important consideration is food - in particular, the number of Calories each Elf is carrying (your puzzle input).\nThe Elves take turns writing down the number of Calories contained by the various meals, snacks, rations, etc. that they\u0026rsquo;ve brought with them, one item per line. Each Elf separates their own inventory from the previous Elf\u0026rsquo;s inventory (if any) by a blank line.\nFor example, suppose the Elves finish writing their items\u0026rsquo; Calories and end up with the following list:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000 This list represents the Calories of the food carried by five Elves:\nThe first Elf is carrying food with 1000, 2000, and 3000 Calories, a total of 6000 Calories. The second Elf is carrying one food item with 4000 Calories. The third Elf is carrying food with 5000 and 6000 Calories, a total of 11000 Calories. The fourth Elf is carrying food with 7000, 8000, and 9000 Calories, a total of 24000 Calories. The fifth Elf is carrying one food item with 10000 Calories. In case the Elves get hungry and need extra snacks, they need to know which Elf to ask: they\u0026rsquo;d like to know how many Calories are being carried by the Elf carrying the most Calories. In the example above, this is 24000 (carried by the fourth Elf).\nFind the Elf carrying the most Calories. How many total Calories is that Elf carrying?\nThe first puzzle of the event has always been the easiest, but difficulty will ramp up in later puzzles. For now, we are given a text file and need to do some additions. I have chosen to go with C# for this puzzle because LINQ is really powerful and ideal for this situation.\nLet\u0026rsquo;s start with a naive approach to the problem:\nread the text file iterate over every line for each line: add number to counter if the line is empty: add the current counter value to a list reset the counter to 0 take the biggest value of the list as a solution In C# the implementation would look something like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var contents = await File.ReadAllLinesAsync(\u0026#34;input.txt\u0026#34;, Encoding.UTF8); var elves = new List\u0026lt;int\u0026gt;(); var currentCalories = 0; foreach (var line in contents) { if (string.IsNullOrWhiteSpace(line)) { elves.Add(currentCalories); currentCalories = 0; continue; } var calories = int.Parse(line); currentCalories += calories; } Console.WriteLine($\u0026#34;Elf with most Calories: {elves.Max()}\u0026#34;); The LINQ extension method Enumerable.Max returns the maximum value in a sequence of values which is exactly what we need for the puzzle. While this solution works and is easy to understand, we can make it more concise and fully utilize LINQ:\n1 2 3 4 5 6 7 8 9 var mostCalories = (await File.ReadAllTextAsync(\u0026#34;input.txt\u0026#34;, Encoding.UTF8)) .Split(\u0026#34;\\n\\n\u0026#34;) .Select(chunk =\u0026gt; chunk .Split(\u0026#39;\\n\u0026#39;, StringSplitOptions.RemoveEmptyEntries) .Select(line =\u0026gt; int.Parse(line)) .Sum()) .Max(); Console.WriteLine($\u0026#34;Elf with most Calories: {mostCalories}\u0026#34;); Instead of using ReadAllLinesAsync which returns all lines in a string array string[], we can use ReadAllTextAsync and use String.Split to create chunks of the input. Remember that each elf is separated by an empty line, so we can split at \\n\\n to create the chunks we need.\nAfter the split we now have an enumerable sequence of chunks (IEnumerable\u0026lt;string\u0026gt;) which we need to project into something different. The Enumerable.Select does exactly that. The chunk variable within the lambda will look something like this:\n1 2 3 1000 2000 4000 With another use of String.Split we create a sequence of lines where we use Enumerable.Select to parse 1000 into an integer. Finally, we use Enumerable.Sum to compute the sum of the sequence because we don\u0026rsquo;t want a sequence of calories for each elf but the total calories each elf is carrying.\nTo answer the question of how many total calories the elf with the most calories is carrying we can use Enumerable.Max to get the maximum value. This solution showcases the power of LINQ and how you can get very creative with it.\nPart Two Description By the time you calculate the answer to the Elves\u0026rsquo; question, they\u0026rsquo;ve already realized that the Elf carrying the most Calories of food might eventually run out of snacks.\nTo avoid this unacceptable situation, the Elves would instead like to know the total Calories carried by the top three Elves carrying the most Calories. That way, even if one of those Elves runs out of snacks, they still have two backups.\nIn the example above, the top three Elves are the fourth Elf (with 24000 Calories), then the third Elf (with 11000 Calories), then the fifth Elf (with 10000 Calories). The sum of the Calories carried by these three elves is 45000.\nFind the top three Elves carrying the most Calories. How many Calories are those Elves carrying in total?\nMost puzzles in the event will consists of multiple parts. These parts always require the previous solution before being accessible and only require minor code changes. With our LINQ solution we only need to change a little:\n1 2 3 4 5 6 7 8 9 10 11 var elves = (await File.ReadAllTextAsync(\u0026#34;input.txt\u0026#34;, Encoding.UTF8)) .Split(\u0026#34;\\n\\n\u0026#34;) .Select(chunk =\u0026gt; chunk .Split(\u0026#39;\\n\u0026#39;, StringSplitOptions.RemoveEmptyEntries) .Select(line =\u0026gt; int.Parse(line)) .Sum()) .Order() .ToArray(); Console.WriteLine($\u0026#34;Elf with most Calories: {elves.Last()}\u0026#34;); Console.WriteLine($\u0026#34;Top 3 Elves combined: {elves.TakeLast(3).Sum()}\u0026#34;); Instead of only getting the maximum total calories, we also want the combined total calories of the top 3 elves. Since we already have the total calories of each elf, we just need to order the sequence and take the biggest values. Note that Enumerable.Order sorts the elements in ascending order meaning the biggest values are last. This is why we need to use Enumerable.Last to get the last element and Enumerable.TakeLast to get the last 3 values which are the 3 biggest ones.\nConclusion This is just the first and easiest puzzle from the event and a good puzzle for people getting started with programming. It will be interesting to see how hard future puzzles will become.\nhttps://www.reddit.com/r/adventofcode/comments/z9g0i0/ai_imagine_advent_of_code_2022_day_1/\nhttps://www.reddit.com/r/adventofcode/comments/z9fltg/sigh_47000_calories_coming_right_up_sir/\n","permalink":"https://erri120.github.io/posts/2022-12-01/","summary":"Day 1: Calorie Counting","title":"Advent of Code 2022: Day 1"},{"content":"Following my post on Character encodings and Unicode it is now time to talk about i18n with GNU gettext. We will look at i18n and l10n in general and then talk about how gettext can make our live as programmers very easy.\ni18n and l10n - Internationalization and Localization Due to the length of Internationalization and Localization you can just write i18n and l10n which are \u0026ldquo;numeronyms\u0026rdquo;, number based words that are formed by taking the first and last character of the words and putting the amount of letters between these two characters in the middle, so for Internationalization it starts with an i and ends with an n and has 18 letters in-between resulting in i18n.\nFor us software developers these terms mean adapting our code to be locale agnostic. If you create a UI and hard-code all strings then the users won\u0026rsquo;t be able to change the language. Aside from normal translations i18n and l10n also encompasses formatting rules for numbers, date and time, currency and things like text layout. Some languages read left to right, others right to left. Instead of reading horizontally there are also cultures where you read vertically.\nAll of this might seem overwhelming and in reality you will likely never have to deal with this. For Open-Source projects it\u0026rsquo;s often enough to just have everything in English and maybe provide a way to load translations.\nGNU gettext and libintl i18n and l10n is all nice and good, but how should we programmers design our software to support these concepts? This is where gettext and libintl come into play.\nIn 1995 the GNU projects released GNU gettext into the world. The package offers an integrated set of tools as well as the libintl runtime library for dealing with translations. We will take a look at the tools xgettext, msginit, msgmerge and msgfmt, how to use the gettext library in our code and what the process of creating translations is.\nCMake Setup In order for us to use libintl in our code we need to get it from somewhere. In this example we will use CMake and vcpkg.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 cmake_minimum_required(VERSION 3.8) project ( \u0026#34;CppInternationalization\u0026#34; VERSION 1.0.0 LANGUAGES CXX ) # Using C++20 set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_STANDARD_REQUIRED ON) set(CMAKE_CXX_EXTENSIONS OFF) add_executable(${PROJECT_NAME} \u0026#34;main.cpp\u0026#34;) # add libintl find_package(Intl REQUIRED) target_link_libraries(${PROJECT_NAME} PUBLIC ${Intl_LIBRARY}) target_include_directories(${PROJECT_NAME} PUBLIC ${Intl_INCLUDE_DIRS}) This is a very basic CMakeLists.txt file containing one dependency which we will get with vcpkg using vcpkg install gettext[tools]. The tools feature is very important so we can get the programs required for our setup.\nCode Setup 1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return EXIT_SUCCESS; } This is the most basic C++ program possible. In the code we hard-coded the string Hello World!, and now we want to provide translations. The libintl runtime library has exactly what we need:\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;libintl.h\u0026gt; int main() { std::cout \u0026lt;\u0026lt; gettext(\u0026#34;Hello World!\u0026#34;) \u0026lt;\u0026lt; std::endl; return EXIT_SUCCESS; } The gettext function from the libintl.h header will now look for a translation of the string Hello World! for the current locale at runtime. If it does not find a translation it will just use Hello World! which is very nice since we only have to wrap all the strings in gettext(). If gettext is too long you can create a macro:\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;libintl.h\u0026gt; #define _(String) gettext(String) int main() { std::cout \u0026lt;\u0026lt; _(\u0026#34;Hello World!\u0026#34;) \u0026lt;\u0026lt; std::endl; return EXIT_SUCCESS; } This macro is very commonly used in projects that use GNU gettext and even included in frameworks like GTK.\nSo where does gettext() look for my translations? You will have to specify that with bindtextdomain:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;libintl.h\u0026gt; #define _(String) gettext(String) int main() { bindtextdomain(\u0026#34;my-domain\u0026#34;, \u0026#34;locales\u0026#34;); textdomain(\u0026#34;my-domain\u0026#34;); std::cout \u0026lt;\u0026lt; _(\u0026#34;Hello World!\u0026#34;) \u0026lt;\u0026lt; std::endl; return EXIT_SUCCESS; } Now at runtime if the user has the de locale set, gettext() will look at locales/de/LC_MESSAGES/my-domain.mo for a translation. Let\u0026rsquo;s break this path down:\nlocales: the folder specified in bindtextdomain de: the current locale LC_MESSAGES: the category name of the translation my-domain.mo: the binary message catalog containing all translations. The file name is what you specified in bindtextdomain as well as textdomain There are few things that need explaining. The library will first try and find an exact match of the current locale but if that is not possible it will look for similar locales. As an example if the user has de_DE, but you only provided de then the library will first look for de_DE and when it doesn\u0026rsquo;t find it, it will look for an expanded locale like de.\nThe LC_MESSAGES part of the path is the category name of the translation we are looking for. LC stands for locale category and there are various others like LC_CTYPE, LC_NUMERIC, LC_TIME, LC_MONETARY which all specify how to handle various things like numbers, dates and currency. For our purposes we only focus on messages, raw strings or texts we want to translate. gettext will always use LC_MESSAGES as its category. There are other functions that will let you specify which category you want to look for like dcgettext but for this post we won\u0026rsquo;t look at those.\nThe .mo file is the message catalog which has to be generated. So let\u0026rsquo;s look at how that works next.\nInitial Project Setup In our very complex example we have marked the Hello World! string as a translatable string. We can now use xgettext to extract these marked strings:\n1 xgettext main.cpp --keyword=\u0026#34;_\u0026#34; --output=\u0026#34;locales/my-domain.pot\u0026#34; This .pot file is a Portable Object Template file. It can look like this:\n# SOME DESCRIPTIVE TITLE. # FIRST AUTHOR \u0026lt;EMAIL@ADDRESS\u0026gt;, YEAR. # #, fuzzy msgid \u0026#34;\u0026#34; msgstr \u0026#34;\u0026#34; \u0026#34;POT-Creation-Date: 2022-05-05 14:47+0200\\n\u0026#34; \u0026#34;PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\u0026#34; \u0026#34;Last-Translator: FULL NAME \u0026lt;EMAIL@ADDRESS\u0026gt;\\n\u0026#34; \u0026#34;Language-Team: LANGUAGE \u0026lt;LL@li.org\u0026gt;\\n\u0026#34; \u0026#34;Language: \\n\u0026#34; \u0026#34;MIME-Version: 1.0\\n\u0026#34; \u0026#34;Content-Type: text/plain; charset=CHARSET\\n\u0026#34; \u0026#34;Content-Transfer-Encoding: 8bit\\n\u0026#34; #: main.cpp:10 msgid \u0026#34;Hello World!\u0026#34; msgstr \u0026#34;\u0026#34; At the bottom you can find our Hello World! string which comes from main.cpp at line 10. This file can now be used to create .po, Portable Object files using msginit:\n1 msginit --input=\u0026#34;locales/my-domain.pot\u0026#34; --output-file=\u0026#34;locales/de/my-domain.po\u0026#34; --locale=\u0026#34;de\u0026#34; Every language you want to support gets its own .po file. The .pot is just a template used to create the .po files with. The .po file looks almost the same:\nmsgid \u0026#34;\u0026#34; msgstr \u0026#34;\u0026#34; \u0026#34;POT-Creation-Date: 2022-05-05 14:47+0200\\n\u0026#34; \u0026#34;PO-Revision-Date: 2022-05-04 18:41+0200\\n\u0026#34; \u0026#34;Last-Translator: \u0026lt;EMAIL@ADDRESS\u0026gt;\\n\u0026#34; \u0026#34;Language-Team: German\\n\u0026#34; \u0026#34;Language: de\\n\u0026#34; \u0026#34;MIME-Version: 1.0\\n\u0026#34; \u0026#34;Content-Type: text/plain; charset=CP1252\\n\u0026#34; \u0026#34;Content-Transfer-Encoding: 8bit\\n\u0026#34; \u0026#34;Plural-Forms: nplurals=2; plural=(n != 1);\\n\u0026#34; \u0026#34;X-Generator: Poedit 3.0.1\\n\u0026#34; #: main.cpp:10 msgid \u0026#34;Hello World!\u0026#34; msgstr \u0026#34;Hallo Welt!\u0026#34; I already went ahead and translated Hello World! to Hallo Welt! using Poedit, but there are other tools like KBabel, Gtranslator, PO Mode and more which you can use to edit the .po files. The ecosystem is very mature and platforms like transifex also support it.\nNow with your fully or partially translated .po file in hand we will use msgfmt to create our final output file:\n1 msgfmt \u0026#34;locales/de/my-domain.po\u0026#34; --output-file=\u0026#34;locales/de/my-domain.mo\u0026#34; You now have a .mo file that can be loaded at runtime. But what happens when you change your code? How do you update your .pot, .po and .mo files when there are new, removed or changed strings in your code?\nSource changed, what to do? What we looked at so far is the initial setup phase. This is what you do when you have no previous .pot or .po files and generate them for the first time. If you already have them and the code changed you need to run xgettext again:\n1 xgettext main.cpp --keyword=\u0026#34;_\u0026#34; --output=\u0026#34;locales/my-domain.pot\u0026#34; The .pot file can be overwritten as you please since it only holds generated content. The .po files are more important since you don\u0026rsquo;t want to re-do all translations. For this reason we use msgmerge to update the .po files with the new template:\n1 msgmerge \u0026#34;locales/de/my-domain.po\u0026#34; \u0026#34;locales/my-domain.pot\u0026#34; --output-file=\u0026#34;locales/de/my-domain.po\u0026#34; The tool takes the current .po file and the new .pot file as input and spits out an updated .po file that keeps your existing translations as long as they are still used.\nAutomating and integrating with CMake If you found all of this extremely tedious to do by hand then you are not alone. Of course we can automate the generating and updating for all the required files as well as copying the .mo files to our output at build time using a CMake script.\nTo get started, grab a copy this script or add the repository as a submodule. In your CMakeLists.txt file we need to add some lines:\n1 2 3 4 5 6 7 8 9 10 # setup gettext set(GETTEXT_DOMAIN \u0026#34;my-domain\u0026#34;) set(GETTEXT_TARGET \u0026#34;gettext-target\u0026#34;) set(GETTEXT_OUTPUT_DIR \u0026#34;locales\u0026#34;) set(GETTEXT_LANGUAGES \u0026#34;en\u0026#34; \u0026#34;de\u0026#34;) target_compile_definitions(${PROJECT_NAME} PUBLIC \u0026#34;GETTEXT_DOMAIN=\\\u0026#34;${GETTEXT_DOMAIN}\\\u0026#34;\u0026#34;) target_compile_definitions(${PROJECT_NAME} PUBLIC \u0026#34;GETTEXT_OUTPUT_DIR=\\\u0026#34;${GETTEXT_OUTPUT_DIR}\\\u0026#34;\u0026#34;) First we specify some variables and add GETTEXT_DOMAIN and GETTEXT_OUTPUT_DIR as a predefined macro so we can use it in our code. I suggest you change the domain name and the list of languages you want to use.\nNext we want to add the previously downloaded script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 include(\u0026#34;extern/gettext-cmake/Gettext_helpers.cmake\u0026#34;) CONFIGURE_GETTEXT( DOMAIN ${GETTEXT_DOMAIN} TARGET_NAME ${GETTEXT_TARGET} SOURCES \u0026#34;main.cpp\u0026#34; POTFILE_DESTINATION ${GETTEXT_OUTPUT_DIR} XGETTEXT_ARGS \u0026#34;--keyword=_\u0026#34; \u0026#34;--add-comments=TRANSLATORS:\u0026#34; \u0026#34;--package-name=${PROJECT_NAME}\u0026#34; \u0026#34;--package-version=${PROJECT_VERSION}\u0026#34; \u0026#34;--msgid-bugs-address=\u0026lt;https://github.com/erri120/${PROJECT_NAME}/issues\u0026gt;\u0026#34; \u0026#34;--copyright-holder=erri120\u0026#34; LANGUAGES ${GETTEXT_LANGUAGES} BUILD_DESTINATION $\u0026lt;TARGET_FILE_DIR:${PROJECT_NAME}\u0026gt;/${GETTEXT_OUTPUT_DIR} ALL ) There is lots to configure so let\u0026rsquo;s go through it all:\nDOMAIN set the domain name TARGET_NAME: set the CMake target name SOURCES: set a list of all source files that xgettext should look through, I suggest creating some variable that holds all your sources POTFILE_DESTINATION: this is the directory where the .pot file goes XGETTEXT_ARGS: most of the extra arguments supplied are just for flavor like specifying the package name, version as well as the address where you can report bugs and the copyright holder LANGAUGES: set the list of languages we want to support BUILD_DESTINATION: the top-level output folder for the generated .mo files ALL: adds the custom CMake target to the default build target so that it will be run every time And that\u0026rsquo;s it. Doing a CMake configure will generate the .pot and .po files, and you now have some new targets that will generate the .mo files.\nComplete Code Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;libintl.h\u0026gt; #if WIN32 #define WIN32_LEAN_AND_MEAN #include \u0026lt;Windows.h\u0026gt; #endif #define _(STRING) gettext(STRING) static void setup_i18n(const std::string_view locale) { #if WIN32 // LocaleNameToLCID requires a LPCWSTR so we need to convert from char to wchar_t const auto wStringSize = MultiByteToWideChar(CP_UTF8, 0, locale.data(), static_cast\u0026lt;int\u0026gt;(locale.length()), nullptr, 0); std::wstring localeName; localeName.reserve(wStringSize); MultiByteToWideChar(CP_UTF8, 0, locale.data(), static_cast\u0026lt;int\u0026gt;(locale.length()), localeName.data(), wStringSize); _configthreadlocale(_DISABLE_PER_THREAD_LOCALE); const auto localeId = LocaleNameToLCID(localeName.c_str(), LOCALE_ALLOW_NEUTRAL_NAMES); SetThreadLocale(localeId); #else setlocale(LC_MESSAGES, locale.data()); #endif bindtextdomain(GETTEXT_DOMAIN, GETTEXT_OUTPUT_DIR); bind_textdomain_codeset(GETTEXT_DOMAIN, \u0026#34;UTF-8\u0026#34;); textdomain(GETTEXT_DOMAIN); } int main() { setup_i18n(\u0026#34;de\u0026#34;); std::cout \u0026lt;\u0026lt; _(\u0026#34;Hello World!\u0026#34;) \u0026lt;\u0026lt; std::endl; return EXIT_SUCCESS; } Woah, what happened with our 12 lines of code? Things are sadly not as easy as you want them to be. The main function is still the same, we have our marked string Hello World! but now there is the new function setup_i18n.\nThis new function takes a std::string_view as an argument and sets the current locale to something new. In this case I want to change the locale to de so my German translation for Hello World! can be loaded. In your actual code you\u0026rsquo;d want to have some language option the user can change which would call this function with the new locale.\nThe thing that makes this messy is of course the difference between systems. On a POSIX compliant system you can just call setlocale(LC_MESSAGES, \u0026quot;de\u0026quot;), but this doesn\u0026rsquo;t work at all for Windows.\nOn Windows you need to use SetThreadLocale which requires a locale ID that you can get from a name like de using LocaleNameToLCID. The _configthreadlocale(_DISABLE_PER_THREAD_LOCALE) call is important because SetThreadLocale only affects the current thread, who would have thought, so we want to disable this behavior and change the locale of this and all future threads.\nThe code after that uses the new predefined macros we added in our CMake file and I also added a call to the very useful bind_textdomain_codeset function. I suggest reading my Character encodings and Unicode where I explain the mess that is Code Pages and Unicode. With this function call gettext will always return a UTF-8 string. If you don\u0026rsquo;t want that or don\u0026rsquo;t need that you can remove this call but for frameworks like GTK it is required as they accept UTF-8 only.\nAlternatives GNU gettext has been around for over 30 years, it is battle tested, has great support and a matured ecosystem. However, if this is not for you or if you can\u0026rsquo;t use it there are a few alternatives available:\nDIY: always possible but highly discouraged Qt: of course the Qt-ecosystem has a different way of doing translations ICU: International Components for Unicode have ICU4C however it is not easy to use at all Boost.Locale they use ICU as a backend POSIX: catgets this was created back in 1987 before GNU gettext Win32: LoadString with this you can load string resources by ID ","permalink":"https://erri120.github.io/posts/2022-05-05/","summary":"GNU gettext is a very useful i18n and l10n tool that makes it easy to add translations in our code.","title":"Getting started with GNU gettext for C++"},{"content":"Time and Character encoding are the two things a programmer never wants to touch. Thankfully dealing with time has been made very easy, we developed ISO Standards, created standard libraries with good time functions and don\u0026rsquo;t have to worry until 2038 when a signed 32-bit integer is unable to hold the number of seconds elapsed since the Unix epoch.\nCharacter encodings did not receive this kind of treatment until the emergence of Unicode but even then we still have massive issues when dealing with them.\nHistory If you don\u0026rsquo;t want to read through this history class I prepared, you can skip directly to the more interesting topic here: Encoding, Code Pages and Unicode for Programmers.\nElectrical Telegraphy One of the earliest encoding methods is Morse Code which was introduced in the 1840s. The earliest code used commercially was the Cooke and Wheatstone telegraph five needle code, aka C\u0026amp;W5, but no one really used it. Instead, each country went ahead and developed their own code leading to the creation of the American Morse Code:\n1911 Chart of the Standard American Morse Characters from the American School of Correspondence\nThis code had issues so a fellow German named Friedrich Clemens Gerke developed a modified version in 1848 for use on German railways. At that time many central European countries belonged to the German-Austrian Telegraph Union and they quickly decided to adopt this version across all its countries in 1851.\nDue to the widespread use of the Gerke Code it became the International Morse Code in 1865:\nChart of the Morse code letters and numerals by Rhey T. Snodgrass \u0026amp; Victor F. Camp, 1922\nEven though it is called the \u0026ldquo;International\u0026rdquo; Morse Code, US companies refused to adopt it and continued to use the American Morse Code. They didn\u0026rsquo;t want to re-train their operators and because the telegraph was not state controlled but multiple private companies worked together, they never adopted it.\nSo why am I telling you this 180-year-old story? Back then we already were unable to come to a consensus on what standard to use. The Gerke Code was adopted by the German-Austrian Telegraph Union, but each country developed their own Code at some point because they used special characters in their language. This has been the biggest problem throughout the years. In Europe, we mostly use Latin-based alphabets but over in Asia things looked different:\nObsolete Chinese telegraph codes from Septime Auguste Viguier’s New Book for the Telegraph\nThis is one page from the Chinese Telegraph Code book. There are nearly 10 thousand characters in this book.\nThis is another recurring theme across history. Languages use different alphabets or none at all. A Logography uses written characters that represent a word or morpheme, like Chinese characters. This makes creating encodings for use everywhere really hard because now you don\u0026rsquo;t have 26 letters in lower and uppercase and a few syntax characters, but thousands of characters that have their own meaning. Most of the technological advancements in telegraphy and digital computers happened in Europe or USA, Asia was often left out and new encodings would focus on Latin-based alphabets.\nAutomatic Telegraphy In 1846 someone had the genius idea of automatically generating Morse code. Previously if you want to transmit a message, you\u0026rsquo;d go through each letter, look at the Morse Code table and press the required taps.\nBut what if you had a machine with multiple keys where each key corresponds to a different entry in the Morse Code table? A machine with multiple keys where each input corresponds to a different output, where have I heard that before? How about a piano:\nHughes Letter-Printing Telegraph Set built by Siemens and Halske in Saint Petersburg, Russia, ca.1900\nPiano keyboards existed for a long time and are really easy to understand. If you want to transmit an A you just press the key that is marked with an A. No need to look into some weird table and get hand pain by pressing the same key in different intervals for the entire day.\nBut let us not get side-tracked by random history and focus on out main topic: encoding. With these new printing telegraphs the operator stopped sending dots and dashes directly with a single key but instead operated a piano keyboard and a machine which would generated the appropriate Morse Code Point based on the key pressed.\nThe Morse Code was designed to be used by humans meaning common letters were easier to \u0026ldquo;type\u0026rdquo; by requiring fewer inputs. In the 1870s Émile Baudot created a new Code to be used by machines instead of humans to make sending and receiving even easier:\nPart of the patent from 1888 (US388244)\nThe Baudot Code is a 5-bit fixed-length binary code and next most important invention after the Morse Code. It is also known as the International Telegraph Alphabet No. 1 (ITA1).\nIf there is a No. 1, there must be a No. 2, so in 1901 Donal Murray modified Baudot Code to create the Murray Code. This code was used with punched paper tape. Now a reperforator could be used to make a perforated copy of received messages and a tape transmitter can send messages from punched tapes. Instead of directly transmitting to the line, the key presses of the operator would punch holes instead, making transmitting multiple messages from one tape very fast.\nOperator fatigue was no longer an issue, instead Murray focused on minimizing machine wear and had to add control characters to control the machine. These characters are Carriage Return and Line Feed also known as CR and LF. If you every wondered where those came from, now you know.\nIn 1924 the International Telegraph Union created the International Telegraph Alphabet No. 2 (ITA2), based on Murray Code, which became the most widespread code as nearly all 20th-century teleprinter equipment used ITA2 or some variant of it.\n1960s ITA2 was very successful but we were going digital. Here are some inventions from this era to paint a picture: IBM created the IBM 704 in 1954 which was the first mass-produced computer with floating-point arithmetic hardware, the first transatlantic communications cable was laid down in 1956 and MIT and Bell Labs created the first Modem in 1959.\nThings started to become digital and electronics became more important. Teleprinter technology also advanced and people wanted to use lowercase characters and additional punctuations. In 1964 the American Standards Association created the famous 7-bit ASCII Code also known as US-ASCII:\nIBM and Code Pages IBM with their mainframe computers played a very important role for us. They were a chief proponent of the ASCII standardization committee however they did not have enough time to prepare ASCII peripherals to ship with the IBM System/360 in 1964. This was a big problem and the company instead created the Extended Binary Coded Decimal Interchange Code (EBCDIC) which is an 8-bit character set.\nThe IBM System/360 was extremely successful and EBCDIC shared in this success. This was a problem, you now have ASCII which IBM really liked and EBCDIC which was used everywhere because everyone used the IBM System/360. Further complications arose since EBCDIC and ASCII were not compatible with each other which resulted in issues when transferring data between systems.\nWith EBCDIC came these new things called Code Pages. Not everyone speaks English and as we have seen before, some languages use a Latin-based alphabet, some use a non-Latin-based alphabet some don\u0026rsquo;t use an alphabet at all but Logography instead. Not only that but we are currently in the late 20th century when 20-megabyte drives costs 250 USD meaning we have to be space efficient.\nFor these reasons, IBM created code pages for the EBCDIC character set which are represented by a number and change the way you encode certain characters. One important thing I want to mention is that IBM created the code pages but not the standard that was behind it. As an example let\u0026rsquo;s look at JIS X 0201 which is a Japanese Industrial Standard developed in 1969 and was implemented by IBM as Code Page 897. IBM did not create the standard, they only created the code page that implemented it.\n8-bit architecture In the 1980s the 8-bit architecture led to the 8-bit byte becoming the standard unit of computer storage, so ASCII with its 7-bit length was inconvenient for data retrieval. Thus, in 1987 we got the standard ISO 8859-1 aka Extended ASCII which uses the extra bit for more non-English characters like accented vowels and some currency symbols.\nGoing Unicode It is the year 1980 and a company named Xerox created the Xerox Character Code Standard (XCCS) which is 16-bit and encodes the characters required for languages using the Latin, Arabic, Hebrew, Greek and Cyrillic scripts, the Chinese, Japanese and Korean writing systems, and technical symbols.\nA group with members of Xerox and Apple started thinking about a universal character set in 1987 and used the XCCS as an inspiration. This group quickly grew as people from Sun Microsystems, Microsoft and other companies started to join.\nThe Unicode Consortium which was incorporated in early 1991 published the first volume of the Unicode Standard later that year and the second volume in the next year to include a total of 28,327 characters.\nEncoding, Code Pages and Unicode for Programmers Now that the history class is over we can look at some code.\nWindows API If you ever wrote some C/C++ code and had to work with the Windows API you might wonder why there are multiple versions of the same function like MessageBox, MessageBoxA and MessageBoxW:\n1 2 3 4 5 6 7 8 int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType); #ifdef UNICODE #define MessageBox MessageBoxW #else #define MessageBox MessageBoxA #endif The docs say A means ANSI and the W stands for Unicode, but this is a bit misleading so here is an explanation.\nFirst ANSI is just straight up confusing and a \u0026ldquo;misnomer\u0026rdquo;.\nA misnomer is a name that is incorrectly or unsuitably applied.\nMicrosoft themselves said it\u0026rsquo;s stupid:\nANSI: Acronym for the American National Standards Institute. The term “ANSI” as used to signify Windows code pages is a historical reference, but is nowadays a misnomer that continues to persist in the Windows community. The source of this comes from the fact that the Windows code page 1252 was originally based on an ANSI draft—which became International Organization for Standardization (ISO) Standard 8859-1. “ANSI applications” are usually a reference to non-Unicode or code page–based applications.\nSo going forward I\u0026rsquo;m just going to call it \u0026ldquo;Windows Code Pages\u0026rdquo;.\nNext up is the W for Unicode. The W comes from wchar_t which is an implementation-defined wide character type. In the Microsoft compiler, it represents a 16-bit wide character used to store Unicode encoded as UTF-16LE.\nSo let\u0026rsquo;s recap:\nMessageBoxA: accepts the 8-bit char type and uses the Windows Code Pages MessageBoxW: accepts the implementation-defined wide wchar_t type and uses UTF-16 MessageBox: just an alias that will use either MessageBoxA or MessageBoxW The fact that wchar_t is implementation-defined is obviously a problem. Windows adopted Unicode when it fit in a 16-bit long type, but that is not the case anymore.\nNow for some code and some experiments:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define WIN32_LEAN_AND_MEAN #include \u0026lt;iostream\u0026gt; #include \u0026#34;Windows.h\u0026#34; int main() { MessageBoxA(nullptr, \u0026#34;This uses Windows Code Pages\u0026#34;, nullptr, MB_OK); MessageBoxW(nullptr, L\u0026#34;This uses UTF-16\u0026#34;, nullptr, MB_OK); constexpr char helloShiftJis[] = {static_cast\u0026lt;char\u0026gt;(0x82), static_cast\u0026lt;char\u0026gt;(0xB1), static_cast\u0026lt;char\u0026gt;(0x82), static_cast\u0026lt;char\u0026gt;(0xF1), static_cast\u0026lt;char\u0026gt;(0x82), static_cast\u0026lt;char\u0026gt;(0xC9), static_cast\u0026lt;char\u0026gt;(0x82), static_cast\u0026lt;char\u0026gt;(0xBF), static_cast\u0026lt;char\u0026gt;(0x82), static_cast\u0026lt;char\u0026gt;(0xCD), \u0026#39;\\0\u0026#39;}; MessageBoxA(nullptr, helloShiftJis, nullptr, MB_OK); MessageBoxW(nullptr, L\u0026#34;こんにちは\u0026#34;, nullptr, MB_OK); return 0; } The first two calls show what you\u0026rsquo;d expect to see as they only contain Latin characters. The other calls are more interesting. This hideous array initialization contains the bytes of \u0026ldquo;こんにちは\u0026rdquo; encoded in Shift-JIS. My system locale is set to \u0026ldquo;English (United States)\u0026rdquo; which means my Windows uses Code Page 1252 aka windows-1252. This Code Page does not contain any of the Hiragana characters and instead of seeing \u0026ldquo;こんにちは\u0026rdquo; on screen I get \u0026ldquo;‚±‚ñ‚É‚¿‚Í\u0026rdquo;. If change my system locale to \u0026ldquo;Japanese (Japan)\u0026rdquo; then Windows would use Shift-JIS aka windows-932 and display \u0026ldquo;こんにちは\u0026rdquo; correctly. The MessageBoxW call with L\u0026quot;こんにちは\u0026quot; correctly displays \u0026ldquo;こんにちは\u0026rdquo; because it\u0026rsquo;s UTF-16 encoded.\nThe Windows API also provides functions for converting between string types:\n1 2 3 4 5 // convert from a Code Page to UTF-16 int MultiByteToWideChar(UINT CodePage, dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar); // convert from UTF-16 to a Code Page int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar); With the first function we can convert our Shift-JIS encoded string into UTF-16 and correctly display it:\n1 2 3 4 5 6 auto bufferSize = MultiByteToWideChar(932, MB_ERR_INVALID_CHARS, helloShiftJis, -1, nullptr, 0); auto converted = new wchar_t[bufferSize]; MultiByteToWideChar(932, MB_ERR_INVALID_CHARS, helloShiftJis, -1, converted, bufferSize); MessageBoxW(nullptr, converted, nullptr, MB_OK); Current Issues We have looked at the history of character encodings and some examples with the Windows API. Now it\u0026rsquo;s time to take a look the issues we still have.\nThe Web is united under UTF-8 with over 98% of all web pages using it. This is further enforced by standards like JSON which require UTF-8 encoding. As good as this is, the desktops are still far behind UTF-8 adoption.\nWindows started supporting UTF-8 with Windows XP but only since Windows 10 version 1903 is it the default character encoding for Notepad. These editors are the main culprits as they often default to the current Windows Code Page which makes sharing files internationally a pain.\nThankfully everything is starting to or already using UTF-8, newer languages like Go and Rust basically force you to use UTF-8 and even Microsoft said you should start using it.\nWindows Code Pages are legacy but because it\u0026rsquo;s still used in production we continue to have issues with character encoding. If you have some issues I recommend trying Locale Emulator.\nClosing Words Props to you if you read this entire thing. I personally had to deal a lot with encoding issues as a lot of games I play come from Japan and don\u0026rsquo;t work on my machine without a locale emulator.\nI hope this answered some questions you might have around this topic. It is very complex and has a very long history, but this should give you a peak into the issues we still have.\n","permalink":"https://erri120.github.io/posts/2022-04-15/","summary":"An in-depth post detailing the origins of Unicode, Code Pages and Character Encodings.","title":"Everything about Unicode, Code Pages and Character Encoding"},{"content":"Edit (Sep 2022): Update 3.0 has made this post obsolete. This post was written before 3.0 and the proposed solution only works with earlier versions. This post remains available for the sake of preservation and because it\u0026rsquo;s funny reading the ramblings of an angry person.\nI love Anno 2070. The game released in 2011, and I bought the Königsedition, a special deluxe edition containing the base game, the Deep Ocean DLC, a poster and the entire soundtrack on 3 CDs, back in 2013. I played this game to death, it is my most played strategy game and I have often look back at the fun I had while playing. If you never played the game and went on Steam you might notice it has a Mixed rating. This might seem weird considering I just told you how awesome this game is. But the ratings reflect the current state very well: you can\u0026rsquo;t fucking play the game.\nWhy the game is unplayable Did you think Cyberpunk 2077 at launch was bad with all the glitches and bugs? At least you could play that game and somewhat enjoy it. Now look at this 10-year-old game that you can\u0026rsquo;t even fucking play and Ubisoft completely abandoned it. A studio abandoning their games is nothing new and often not a problem. It might suck that the multiplayer servers of your favorite game go offline, but you could at least continue playing the campaign or the community might start hosting servers.\nSo what do I mean with \u0026ldquo;you can\u0026rsquo;t fucking play the game\u0026rdquo;? Let\u0026rsquo;s imagine an obstacle course where the finish is the main menu of the game. To get to the main menu you first have to start the game either through Uplay, Steam or by starting the Anno5.exe directly. The first obstacle is Uplay itself. I can not count the number of times Uplay had some error or bug that lead to me not playing a game. Back when Assassin\u0026rsquo;s Creed Unity came out, Uplay thought my saves were ephemeral, and I had to replay the first 5 hours of the game more than 13 times. The launcher is a complete dumpster fire and worse than the League of Legends client.\nIf you start Anno 2070 then Uplay will also launch and probably kill the process and start the Auto Updater. If that happens you are fucked because now the \u0026ldquo;Auto Updater\u0026rdquo; will try to auto update your game, even though it\u0026rsquo;s already updated. Once it\u0026rsquo;s done updating it will start the game which will start Uplay which will probably start the updater again. If you bought the game on Steam then you have to flip a coin and if it lands on heads you are fucked and Uplay doesn\u0026rsquo;t think you own the game. If you somehow did manage to convince Uplay to work for once you are now faced with the login screen.\nThe login screen: You open a website, click the login button, enter your username + password and log in to your account. But why do you have to log in to your account in Anno 2070? Some time around 2013 Ubisoft had the genius idea of switching up their entire account system. Anno 2070 was caught up in the transition and somehow came out as an abomination where the login is more broken than Fallout 76 on release. So what username + password do you use in Anno 2070? If you think you have to use your Uplay account then you\u0026rsquo;re wrong. If you choose your Steam credentials then you are also wrong. You have to use the credentials of the account you used to register the game. In my case it\u0026rsquo;s not my main Uplay account because it didn\u0026rsquo;t even exist back then. Now here is the fun part: I still own the game on Uplay. It is in my library, but I can\u0026rsquo;t use my account because the key is not linked to my actual Uplay account. I put emphasis on key because that is our next hurdle. Even if you manage to log in you will probably be asked about the key however your key might be linked to another account even though that account doesn\u0026rsquo;t have the game in their Uplay library. I don\u0026rsquo;t even know how this exactly works with Steam users, but I can imagine it doesn\u0026rsquo;t.\nI hope you come to understand how utterly broken the start procedure of Anno 2070 is. Back in the day when Ubisoft used something called SolidShield the process was even more fucked. Your key was not only tied to some random account but also to your hardware directly meaning if you upgraded your GTX 580 to a GTX 590 your key would not work. If you somehow think this is just the rambling of an insane person then you are correct, but I would also like you to check out the Steam reviews and this great post on reddit \u0026ldquo;Ubisoft\u0026rsquo;s Anno 2070 Unplayable Due to DRM\u0026rdquo; for more salt.\nFixing the game Edit (Dec 2021): Before we dive into this I want to tell you that there are other potential fixes to this problem. Some people messaged me and asks why I didn\u0026rsquo;t do X or Y and my answer was always \u0026ldquo;It didn\u0026rsquo;t work\u0026rdquo;. If you have a similar problem with Anno 2070 then there are other solutions you can try. The fix I will propose is guaranteed to work but should be a last resort.\nNow that I cooled off and finished my rant it\u0026rsquo;s time to talk about how we can fix everything. If you want to follow along you need to get the latest version from Uplay or Steam. It has the version number 2.0.7792.0 and the SHA256 hash of Anno5.exe is C76D42E71AF6A7D1786C6846091A5FBDDB13E3A88A72E469F36F9F365645D58A. If you don\u0026rsquo;t want an explanation of how I got here you can skip to the TL;DR but if you want to hear the explanation then knowing assembly and basic programming is recommended.\nThe goal is to force the game into offline mode. Simply changing your firewall settings to block all connections from the executable is not the solution because, as explained earlier, we also need to deal with Uplay. There is actually a single function responsible for launching Uplay. The standard solution would be to either replace the function with NOP instructions or replace the CALL instruction with NOP. This would probably work, however I found something better. This InitializeUplay function gets called only once: during a pre-init function of the game inside a condition. There is actually a JNZ instruction which will skip the function call entirely.\nThe comparison at 004b05bf (80 7e 50 00 bb 10 00 00 00) compares whatever is at ESI+50 with 0 meaning that the JNZ jump at 004b05c8 will be taken if ESI+50 is not 0. This is never the case and I don\u0026rsquo;t really understand what the condition actually represents, but we can exploit this and make sure the jump is always taken. Since ESI+50 is always 0 we can just change the comparison to compare ESI+50 with 1: 80 7e 50 01. With this you can launch the game and Uplay will never start.\nNext up is the login screen. This took me the longest to figure out. I found the Uplay initialization within a few hours, but this took me an entire day. We can\u0026rsquo;t really skip the login screen, trust me I tried that, but instead we just have to trick the game that we are offline and want to play in offline mode. I used to play a lot in offline and back in the day you still had to put your username + password and click login at which point the game will see you are offline and then loads your offline profile. So now it\u0026rsquo;s time to find the callback function of the login button. I did manage to find the callback function and noticed a little function that returns a WebAdapter based on the argument. Let\u0026rsquo;s name this function CreateWebAdapter(int x) with x = 0 returning an offline web adapter and x = 1 the normal one.\nMy spidey senses were tingling, and I knew this was related to the solution. The login button callback function however will always call CreateWebAdapter(1). You could change the 1 to a 0, but I noticed something different. You see, the login frame is created programmatically, and you can clearly see where the username text box, password text box, remember user ID checkbox, register account button and login button get added to the frame. In order to figure out which button has what callback I put a breakpoint on every callback function and clicked every button. However, there was 1 unused button. I\u0026rsquo;m not sure if it\u0026rsquo;s unused or only conditionally used but guess what function the callback calls: CreateWebAdapter(0). This possibly unused callback function was very similar to the login button callback, but it will always use the offline web adapter. I was very excited when I found out about this and immediately changed the callback function of the login button to use the callback function of the unused button by changing the PUSH instruction at 0068a57b from 68 90 9c 68 00 to 68 d0 8f 68 00, and it fucking worked. You can now log in and start in offline mode.\nAnno 2070 Main Menu\nTL;DR if you don\u0026rsquo;t want an explanation Change the CMP instruction at 004b05bf (80 7e 50 00 bb 10 00 00 00) from 80 7e 50 00 to 80 7e 50 01 Change the PUSH instruction at 0068a57b from 68 90 9c 68 00 to 68 d0 8f 68 00 If you did everything right the SHA256 hash of the modified Anno5.exe file should be 01E123A72C3DCB4FB1E018A685692F57B9586FF4F187BB23B09D8B93D754C268. If that is not the case you did something wrong and your game is probably broken so load your backup and try again.\nAnno 2070 setting tips In case you want to play Anno 2070 after reading this post here are some changes you might want to make in your settings file. The file is located in %appdata%/Ubisoft/Anno 2070/Config/Engine.ini\nchange language by editing \u0026lt;LanguageTAG\u0026gt;ger\u0026lt;/LanguageTAG\u0026gt; skip the intro with \u0026lt;SkipIntro\u0026gt;1\u0026lt;/SkipIntro\u0026gt; Afterword This project has been a lot of fun and ended rather suddenly. I initially allotted 3 full days to this endeavor, but I kept finding new leads and getting new ideas, so I ended up only spending around 12.5 hours (I love how x32dbg will tell you how much time you have wasted debugging). The solution is also very simple, and I made it the title of this post. Just 3 bytes to fix the entire start of the game. I thought I would have to modify a lot of functions or write some DLL I\u0026rsquo;d have to inject but no, you just change 3 bytes and be happy :)\nI hope you found this post somewhat interesting, and maybe you can finally play Anno 2070. If this works for you please do tell me below.\n","permalink":"https://erri120.github.io/posts/2021-12-10/","summary":"Anno 2070 has been unplayable for multiple years but you can still buy it. This post will explain how you can fix the game by changing 3 bytes.","title":"Fixing Anno 2070 by changing three bytes"},{"content":"rpgmpacker has been one of my biggest non-modding related projects on GitHub and the only reason people visit my blog:\nTop queries of my blog\nThe developer of the game Star Knightess Aura (NSFW) is the first actual user of this tool and contributed a good amount of issues on GitHub driving the development of this project forward.\nWith some issues still open I stopped working on this project in April 2021 because I knew I had to rework this tool at some point and didn\u0026rsquo;t have the motivation to do so at that time. I used C++ for 1.x because I wanted to finally build something with this language. I had only done small assignments in Uni with C++ but never done anything more with it, mainly because the language sucks ass.\nC/C++ is old, very old, and it clearly shows, not just in the language but the tooling available. Ask 20 C++ developers what build system they use, and you will likely get 10 different answers. Working with dependencies is a nightmare when it comes to C/C++ development. It\u0026rsquo;s actually impossible to count the amount of times I wanted to contribute to a C++ project only to be blocked by some weird build system that only works in a specific environment when the stars align and the moon is in the Waxing Gibbous lunar phase. Once you did get something to work you now have to deal with the language itself. Let me ask you this: how do you represent a string in C++? Did you know that there is std::string which is actually just std::basic_string\u0026lt;char\u0026gt;, std::u16string which is std::basic_string\u0026lt;char16_t\u0026gt;, std::u32string which is std::basic_string\u0026lt;char32_t\u0026gt; and std::wstring which is std::basic_string\u0026lt;wchar_t\u0026gt; but don\u0026rsquo;t let that fool you because there is also char8_t from C++ 20 that introduces std::u8string and don\u0026rsquo;t forget that wchar_t has different sizes depending on the platform, compiler and time of day?\nC++ is a fucking mess. Working with strings in C++ should not be this hard.\nSo lets calm down and look at something different: Rust. I love Rust, it\u0026rsquo;s C++ in way better and more modern. I wanted to rework rpgmpacker in Rust and actually did exactly that for quite some time but soon realized this was also not the way.\nRPG Maker MV/MZ is pure JavaScript with the data files being in JSON. The developers are probably familiar with JavaScript as well so considering the ecosystem, it is more fitting to create a JavaScript tool. Of course, I wouldn\u0026rsquo;t be doing that, fuck vanilla JavaScript, I\u0026rsquo;m using TypeScript.\nI like to use the right tool for the job. Even though I\u0026rsquo;m quite the C# and Rust fanatic I went with TypeScript because it makes life very easy. I don\u0026rsquo;t have to write complex JSON parsers or DTOs, I can just do JSON.parse(...) and access whatever I want. One huge problem was also parsing the plugins for the exclude-unused feature. If you open js/plugins.js in your game, you will find a variable $plugins. With TypeScript I can just use the VM to dynamically load this file and access this variable directly. With any other language I would have to read the file as a string and do some complex string parsing.\nOf course there are some problems with TypeScript. I previously complained about the C++ dependency systems but the huge dependency trees you can get when using NPM are also insane. Before I even started on the rework I set my goal to require the least amount of modules which ended up being only 1: yargs because parsing arguments is not something I want to implement myself.\nI hope the rework will be received pleasantly by the 2 people using the tool.\n","permalink":"https://erri120.github.io/posts/2021-11-18/","summary":"A quick post explaining my decision of moving from C++ to TypeScript for my project rpgmpacker.","title":"Reworking rpgmpacker: Moving from C++ to TypeScript"},{"content":"Time and Frames We have all heard the term FPS, frames per second, which tells us how many frames are rendered on screen within one second. Higher FPS will result in smoother animations because those animations get more frames. The problem with high FPS is that the GPU has to keep up with this demand and be able to produce 30/60/144 or more frames within 1 second. This is where frame times, VSync and a bunch of offer stuff that I won\u0026rsquo;t cover here comes into play.\nThe important takeaway is that you can not reliably calculate a duration based on how many frames where rendered because not every frame takes the same amount of time. This is a problem when you want to smoothly move an object from one position to another. Engines like Unity solve this by providing a delta time which is the interval from the last to the current frame, allowing you to create smooth translations.\nLooking at RPG Maker MV/MZ So what issue does RPG Maker have? I have recently played a game for around 21 hours, but the save menu displayed over 51 hours, more than double. Actually not just more than double but around 2.4 times more than expected. This quickly made me realize that I had been playing the game on my 144Hz monitor, meaning instead of rendering at 60 FPS, the game was rendering at 144 FPS. I hope you notice that 60 x 2.4 equals 144.\nTo further investigate the problem I took a peek inside the js folder, did a quick search for \u0026ldquo;playtime\u0026rdquo; and found the culprits of my frustration:\n1 2 3 4 Game_System.prototype.onBeforeSave = function() { this._framesOnSave = Graphics.frameCount; // ... }; 1 2 3 4 Game_System.prototype.onAfterLoad = function() { Graphics.frameCount = this._framesOnSave; // ... }; 1 2 3 Game_System.prototype.playtime = function() { return Math.floor(Graphics.frameCount / 60); }; 1 2 3 4 5 6 Game_System.prototype.playtimeText = function() { var hour = Math.floor(this.playtime() / 60 / 60); var min = Math.floor(this.playtime() / 60) % 60; var sec = this.playtime() % 60; return hour.padZero(2) + \u0026#39;:\u0026#39; + min.padZero(2) + \u0026#39;:\u0026#39; + sec.padZero(2); }; A quick explanation: whenever you save, the game includes the amount of frames it has rendered in the save file because Game_System is serialized and _framesOnSave is a field of that object. When you load, the save will get deserialized and Graphics.frameCount will be set back to that value. In case you are wondering: Graphics.frameCount gets incremented on each render.\nThis is fine so far, but the real problems are found in the playtime and playtimeText functions where the game assumes you are constantly playing at 60 frames per second. The pure frameCount value gets divided by 60 to get the amount of seconds passed and in playtimeText that result is further processed to the get hours and minutes.\nDue to the multiple issues outlined at the beginning you can see that this is not a good idea. Having said that: let\u0026rsquo;s look at how to fix this.\nPossible Solution This solution is probably the easiest and most straightforward one I can think of:\non load/start: set startTime to the current time on save: get the current time and calculate the difference between now and startTime add the difference to a variable in the save No need for frame count calculations or anything complex, just use Date.now() a few times and get the difference.\nChanging the implementation in RPG Maker MV/MZ Start by opening js/rpg_objects.js and look for the initialize function. Here we want to add two new fields:\n1 2 3 4 5 Game_System.prototype.initialize = function() { this._startTime = Date.now(); this._playtime = 0; // ... } Date.now() returns the current Unix time as an integer that looks like this: 1632928643900.\nWe need to set the start time in the initialize function for when the game starts and in the onAfterLoad function for when the player loads a save file:\n1 2 3 4 Game_System.prototype.onAfterLoad = function() { this._startTime = Date.now(); // ... } The onBeforeSave function gets called before the save is serialized so here we have to calculate the time difference and reset the start time:\n1 2 3 4 5 Game_System.prototype.onBeforeSave = function() { this._playtime += Date.now() - this._startTime; this._startTime = Date.now(); // ... } Assuming the player started at 1632928643900 and played for 1 second till 1632928644900, this._playtime will now be 1000. The only thing remaining is updating the playtime function:\n1 2 3 Game_System.prototype.playtime = function() { return Math.floor(this._playtime / 1000); }; Since this function returns the amount of time passed in seconds we have to divide by 1000 to convert from milliseconds to seconds. While we are at it, I also recommend updating playtimeText:\n1 2 3 4 5 6 7 8 9 10 11 Game_System.prototype.playtimeText = function() { var secondsPassed = this.playtime(); var minutesPassed = Math.floor(secondsPassed / 60); var hoursPassed = Math.floor(minutesPassed / 60); var sec = secondsPassed % 60; var min = minutesPassed % 60; var hour = hoursPassed % 24; return hour.padZero(2) + \u0026#39;:\u0026#39; + min.padZero(2) + \u0026#39;:\u0026#39; + sec.padZero(2); }; The main difference here is that we cache the result from the playtime function and other operations.\nPlugin for MV/MZ If you don\u0026rsquo;t want to mess with the game files directly, which is a good idea, then I suggest taking a look at the PlaytimeFix plugin which I developed that does everything explained in this post.\nAfterword This issue has been bugging me a lot during my playthroughs of longer games because you don\u0026rsquo;t really notice it when your playtime goes from 1h to 2 hours but going from 21 hours to 50+ hours was a bit more in my face. RPG Maker MZ also doesn\u0026rsquo;t fix this, and I have not seen any discussion about this.\n","permalink":"https://erri120.github.io/posts/2021-09-29/","summary":"RPG Maker MV/MZ uses the amount of rendered frames to calculate how long player has been playing the game. This is beyond stupid.","title":"Don't count frames to calculate time"},{"content":"Automation saves time and therefore money. However, you have to ask yourself if it\u0026rsquo;s worth spending hours writing a complex and long script. In the worst case you might end up wasting instead of saving time. Thankfully most programming related tasks can be automated very quickly and each language or framework often has documentation on how to get you up and running.\nThis is sadly not often the case when it comes to game development. Popular engines like Unreal Engine and Unity have automation tools1 and documentation for automating the build process but less popular ones such as RPG Maker don\u0026rsquo;t have those.\nIn this post I will explain what CI/CD means and how to set up a pipeline for RPG Maker MV/MZ with rpgmpacker. A big chunk of this post is explaining CI/CD and how RPG Maker MV/MZ works, if you just want to go to the practical part click here.\nCI/CD for non-programmers RPG Maker is very non-programmer friendly, and you can easily end up not having to write a single line of code when creating a game with it. For this reason I want to make sure we all have the same base level understanding of CI/CD before continuing. That being said, I expect you to know about version control with git so make sure to watch these two amazing videos by Fireship if you are unfamiliar with it:\nLet\u0026rsquo;s get started with Continuous Integration which means running a pipeline on every change you commit to a repository. This pipeline consists of one or multiple jobs where one job could be running some tests or building the project. If you run the tests on every change then you can easily track down the commit where a bug was introduced to the codebase. A common pipeline would look like this:\nsetup (checkout, getting all the tools) running tests building the project packaging uploading an artifact (fancy word for an archive containing the output) The terminology can be different depending on your provider for example a pipeline on GitHub is called a workflow and each workflow has steps instead of jobs. They often mean the same thing so don\u0026rsquo;t let that confuse you.\nContinuous Delivery is about delivering the artifact we produced previously. This artifact can be sent to testers, friends or the QA team. Continuous Deployment is also a thing and means actually deploying the artifact by uploading the next release of a game to itch.io or deploying the software to your servers.\nBig studios often end up with huge pipelines because they have many employees and teams. They might have a CI pipeline that runs the tests and builds the project. The artifact would then send in a CD pipeline to the testers or QA team and when they approve of the build it gets released into the world. This is probably not the case for you or your team and most of the time you can combine all of this into one pipeline.\nIf you are curious how such a pipeline might look like, here is the GitHub Actions workflow file that builds (CI) and deploys (CD) this site to GitHub Pages on every push to the master branch:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 on: push: branches: [ master ] jobs: build: runs-on: ubuntu-latest steps: # setup - uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # building the site (CI) - name: Build run: hugo --minify # deploying the site (CD) - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: gh-pages RPG Maker MV/MZ manual export RPG Maker MV Deployment Window\nThis is the deployment window of RPG Maker MV which you can access in the editor under File -\u0026gt; Deployment. The major issue with this is the fact you have to use it at all. Software developers love the tools they can use from the command line because they can be easily accessed using a script.\nOther engines like Unreal Engine have to compile code before deployment, but RPG Maker is very different: It\u0026rsquo;s only copying files from one place to another.\nThere is no code to compile because all the code is in JavaScript, it doesn\u0026rsquo;t even need to compile an executable because it just uses NW.js. RPG Maker is one of the simplest game engines, not just in terms of usability but how everything is just JSON and JavaScript. You can literally go into the js folder and look at all the source code of the engine. All the data is saved as JSON so if you want to change the name of an item you can open data/Items.json and change the values.\nIf you are curious where all those files come from, open your RPG Maker MV/MZ installation folder and look for folders that start with nw-js-. The files inside those folders are copied over to the output directory. You can also find the default template files in the NewData folders.\nSimply copying files from one place to another can be done with a script. This was exactly what rpgmpacker did in my first prototype, but I soon realized that there was more going on.\nFirst we have file filtering. For audio, you can have .ogg and .m4a files but exporting for Windows/OSX will only copy the .ogg files while exporting for Mobile will only copy .m4a files. Then we have image and audio \u0026ldquo;encryption\u0026rdquo; and the exclude-unused feature which requires parsing of almost all JSON files to figure out which files are actually in use and which are not. There is even more to this which can\u0026rsquo;t be done in a simple script, so I decided to build an entire tool which we are going to use in the pipeline.\nCreating a Release Pipeline for RPG Maker The pipeline we are going to build will do the following:\nrun rpgmpacker zip the output upload the output to itch.io using Butler If your game is not on itch.io then you can leave out the last step or replace it with an upload to MEGA, GDrive or your hosting platform of choice.\nFor the pipeline you can write a Bash or PowerShell script, just pick whatever you like more:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash INPUT=\u0026#34;./MyProject\u0026#34; OUTPUT=\u0026#34;./build\u0026#34; RPGMAKER=\u0026#34;M:\\\\SteamLibrary\\\\steamapps\\\\common\\\\RPG Maker MV\u0026#34; npx rpgmpacker@latest \\ --input \u0026#34;$INPUT\u0026#34; \\ --output \u0026#34;$OUTPUT\u0026#34; \\ --rpgmaker \u0026#34;$RPGMAKER\u0026#34; \\ --exclude \\ --noempty \\ --debug \\ --platforms \u0026#34;Windows\u0026#34; \u0026#34;OSX\u0026#34; \u0026#34;Linux\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 $PROJECT=\u0026#34;./MyProject\u0026#34; $OUTPUT=\u0026#34;./build\u0026#34; $RPGMAKER=\u0026#34;M:\\\\SteamLibrary\\\\steamapps\\\\common\\\\RPG Maker MV\u0026#34; npx rpgmpacker@latest ` --input $PROJECT ` --output $OUTPUT ` --rpgmaker $RPGMAKER ` --exclude ` --noempty ` --debug ` --platforms \u0026#34;Windows\u0026#34; \u0026#34;OSX\u0026#34; \u0026#34;Linux\u0026#34; In my case I have the project in a folder called MyProject next to the script and the output should go into the build folder. I\u0026rsquo;m using the Steam version of RPG Maker MV for this but any version of MV or MZ can be used.\nNext up we want to zip the output. rpgmpacker will create an output folder for each platform you specified so for me I will have build/Windows, build/OSX and a build/Linux folder.\n1 2 3 for platform in $OUTPUT/*; do 7z a -tzip -o$OUTPUT $platform.zip $platform/* done 1 2 3 4 $Platforms = Get-ChildItem -Path $OUTPUT -Directory -Name foreach ($platform in $Platforms) { 7z a -tzip -o$OUTPUT $OUTPUT/$platform.zip $OUTPUT/$platform/* } This is where the difference between PowerShell and Bash start to appear. In Bash, we use a glob to get all top-level items of the output directory and in PowerShell we use the Get-ChildItem function. They look different, but they do the same thing with the main difference being that platform in Bash will be ./build/Windows while $platform in PowerShell will be just Windows. This is why we need to prefix $platform with $OUTPUT/ when calling 7z.\nThe pipeline is almost done at this point. Next is publishing the output with Butler to itch.io but if you are not using that platform you are now done.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # see https://broth.itch.ovh/butler ButlerChannel=\u0026#34;windows-amd64\u0026#34; # darwin-amd64 for Mac and linux-amd64 for Linux ButlerVersion=\u0026#34;15.21.0\u0026#34; ButlerOutput=\u0026#34;butler-$ButlerVersion-$ButlerChannel\u0026#34; if [ ! -d $ButlerOutput ]; then curl -L -o butler.zip https://broth.itch.ovh/butler/$butlerChannel/$butlerVersion/archive/default unzip -o butler.zip -d $ButlerOutput rm butler.zip else echo \u0026#34;Butler version $ButlerVersion ($ButlerChannel) has already been downloaded\u0026#34; fi # change butler.exe to just butler if you are on Unix butler=\u0026#34;$ButlerOutput/butler.exe\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # see https://broth.itch.ovh/butler $ButlerChannel=\u0026#34;windows-amd64\u0026#34; # darwin-amd64 for Mac and linux-amd64 for Linux $ButlerVersion=\u0026#34;15.21.0\u0026#34; $ButlerOutput=\u0026#34;butler-$ButlerVersion-$ButlerChannel\u0026#34; if (![System.IO.Directory]::Exists($ButlerOutput)) { Invoke-WebRequest -OutFile butler.zip \u0026#34;https://broth.itch.ovh/butler/$butlerChannel/$butlerVersion/archive/default\u0026#34; Expand-Archive -Path butler.zip $ButlerOutput Remove-Item -Path butler.zip } else { Write-Output \u0026#34;Butler version $ButlerVersion ($ButlerChannel) has already been downloaded\u0026#34; } # change butler.exe to just butler if you are on Unix $butler=\u0026#34;$ButlerOutput/butler.exe\u0026#34; If you are not on Windows you should change the ButlerChannel variable to darwin-amd64 or linux-amd64 depending on your system. I recommend checking the channel list of Butler if you need something different. I\u0026rsquo;ve added a simple check, so we don\u0026rsquo;t download Butler whenever we call the script. Before we continue you should get an API key from itch.io. You should treat API keys like passwords and should never make them public. A good way of storing API keys is with environment variables and Butler expects the API key to be stored in the BUTLER_API_KEY environment variable.\n1 2 3 4 5 6 7 export BUTLER_API_KEY=\u0026#34;YOUR_KEY\u0026#34; ButlerProject=\u0026#34;YOUR_USERNAME/YOUR_PROJECT_NAME\u0026#34; ./$butler login ./$butler push $OUTPUT/Windows $ButlerProject:windows-beta ./$butler push $OUTPUT/OSX $ButlerProject:osx-beta ./$butler push $OUTPUT/Linux $ButlerProject:linux-beta 1 2 3 4 5 6 7 $env:BUTLER_API_KEY=\u0026#34;YOUR_KEY\u0026#34; $ButlerProject=\u0026#34;YOUR_USERNAME/YOUR_PROJECT_NAME\u0026#34; \u0026amp;$butler login \u0026amp;$butler push $OUTPUT/Windows.zip \u0026#34;${ButlerProject}:windows-beta\u0026#34; \u0026amp;$butler push $OUTPUT/OSX.zip \u0026#34;${ButlerProject}:osx-beta\u0026#34; \u0026amp;$butler push $OUTPUT/Linux.zip \u0026#34;${ButlerProject}:linux-beta\u0026#34; I recommend that you look at the Butler Docs for the different channels you can push to. To recap here are both complete scripts:\nFinished Scripts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #!/bin/bash INPUT=\u0026#34;./MyProject\u0026#34; OUTPUT=\u0026#34;./build\u0026#34; RPGMAKER=\u0026#34;M:\\\\SteamLibrary\\\\steamapps\\\\common\\\\RPG Maker MV\u0026#34; npx rpgmpacker@latest \\ --input \u0026#34;$INPUT\u0026#34; \\ --output \u0026#34;$OUTPUT\u0026#34; \\ --rpgmaker \u0026#34;$RPGMAKER\u0026#34; \\ --exclude \\ --noempty \\ --debug \\ --platforms \u0026#34;Windows\u0026#34; \u0026#34;OSX\u0026#34; \u0026#34;Linux\u0026#34; for platform in $OUTPUT/*; do 7z a -tzip -o$OUTPUT $platform.zip $platform/* done # see https://broth.itch.ovh/butler ButlerChannel=\u0026#34;windows-amd64\u0026#34; # darwin-amd64 for Mac and linux-amd64 for Linux ButlerVersion=\u0026#34;15.21.0\u0026#34; ButlerOutput=\u0026#34;butler-$ButlerVersion-$ButlerChannel\u0026#34; if [ ! -d $ButlerOutput ]; then curl -L -o butler.zip https://broth.itch.ovh/butler/$butlerChannel/$butlerVersion/archive/default unzip -o butler.zip -d $ButlerOutput rm butler.zip else echo \u0026#34;Butler version $ButlerVersion ($ButlerChannel) has already been downloaded\u0026#34; fi # change butler.exe to just butler if you are on Unix butler=\u0026#34;$ButlerOutput/butler.exe\u0026#34; export BUTLER_API_KEY=\u0026#34;YOUR_KEY\u0026#34; ButlerProject=\u0026#34;YOUR_USERNAME/YOUR_PROJECT_NAME\u0026#34; ./$butler login ./$butler push $OUTPUT/Windows $ButlerProject:windows-beta ./$butler push $OUTPUT/OSX $ButlerProject:osx-beta ./$butler push $OUTPUT/Linux $ButlerProject:linux-beta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 $PROJECT=\u0026#34;./MyProject\u0026#34; $OUTPUT=\u0026#34;./build\u0026#34; $RPGMAKER=\u0026#34;M:\\\\SteamLibrary\\\\steamapps\\\\common\\\\RPG Maker MV\u0026#34; npx rpgmpacker@latest ` --input $PROJECT ` --output $OUTPUT ` --rpgmaker $RPGMAKER ` --exclude ` --noempty ` --debug ` --platforms \u0026#34;Windows\u0026#34; \u0026#34;OSX\u0026#34; \u0026#34;Linux\u0026#34; $Platforms = Get-ChildItem -Path $OUTPUT -Directory -Name foreach ($platform in $Platforms) { 7z a -tzip -o$OUTPUT $OUTPUT/$platform.zip $OUTPUT/$platform/* } # see https://broth.itch.ovh/butler $ButlerChannel=\u0026#34;windows-amd64\u0026#34; # darwin-amd64 for Mac and linux-amd64 for Linux $ButlerVersion=\u0026#34;15.21.0\u0026#34; $ButlerOutput=\u0026#34;butler-$ButlerVersion-$ButlerChannel\u0026#34; if (![System.IO.Directory]::Exists($ButlerOutput)) { Invoke-WebRequest -OutFile butler.zip \u0026#34;https://broth.itch.ovh/butler/$butlerChannel/$butlerVersion/archive/default\u0026#34; Expand-Archive -Path butler.zip $ButlerOutput Remove-Item -Path butler.zip } else { Write-Output \u0026#34;Butler version $ButlerVersion ($ButlerChannel) has already been downloaded\u0026#34; } # change butler.exe to just butler if you are on Unix $butler=\u0026#34;$ButlerOutput/butler.exe\u0026#34; $env:BUTLER_API_KEY=\u0026#34;YOUR_KEY\u0026#34; $ButlerProject=\u0026#34;YOUR_USERNAME/YOUR_PROJECT_NAME\u0026#34; \u0026amp;$butler login \u0026amp;$butler push $OUTPUT/Windows.zip \u0026#34;${ButlerProject}:windows-beta\u0026#34; \u0026amp;$butler push $OUTPUT/OSX.zip \u0026#34;${ButlerProject}:osx-beta\u0026#34; \u0026amp;$butler push $OUTPUT/Linux.zip \u0026#34;${ButlerProject}:linux-beta\u0026#34; Conclusion I hope this blog post helped you with getting a CI/CD pipeline up and running for your RPG Maker game. Please let me know if you end up using this tool for your next project. The author of Star Knightess Aura (NSFW) was one of the earliest users, and you can find their pipeline in this repo on gitgud.\nUnreal Engine has Automation Tools and Unity has a CLI\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://erri120.github.io/posts/2021-02-04/","summary":"Learn how to automate content delivery for your RPG Maker game.","title":"CI/CD for RPG Maker Game Development"}]
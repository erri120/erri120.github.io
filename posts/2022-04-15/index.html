<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Everything about Unicode, Code Pages and Character Encoding | erri120's random Blog</title><meta name=keywords content="Character Encoding,C++"><meta name=description content="An in-depth post detailing the origins of Unicode, Code Pages and Character Encodings."><meta name=author content="erri120"><link rel=canonical href=https://erri120.github.io/posts/2022-04-15/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://erri120.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://erri120.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://erri120.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://erri120.github.io/apple-touch-icon.png><link rel=mask-icon href=https://erri120.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta name=google-site-verification content="c-L5KbBKeVyZ9YNKiotqlpl7zsiDRiGcWJa4ZxVpzAo"><meta name=msvalidate.01 content="0E353603CBFC6B4F85D605C4E9F27290"><script data-goatcounter=https://erri120.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet href=/syntax.css><meta property="og:title" content="Everything about Unicode, Code Pages and Character Encoding"><meta property="og:description" content="An in-depth post detailing the origins of Unicode, Code Pages and Character Encodings."><meta property="og:type" content="article"><meta property="og:url" content="https://erri120.github.io/posts/2022-04-15/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-15T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-29T13:34:42+01:00"><meta property="og:site_name" content="erri120's random Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Everything about Unicode, Code Pages and Character Encoding"><meta name=twitter:description content="An in-depth post detailing the origins of Unicode, Code Pages and Character Encodings."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://erri120.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Everything about Unicode, Code Pages and Character Encoding","item":"https://erri120.github.io/posts/2022-04-15/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Everything about Unicode, Code Pages and Character Encoding","name":"Everything about Unicode, Code Pages and Character Encoding","description":"An in-depth post detailing the origins of Unicode, Code Pages and Character Encodings.","keywords":["Character Encoding","C++"],"articleBody":"Time and Character encoding are the two things a programmer never wants to touch. Thankfully dealing with time has been made very easy, we developed ISO Standards, created standard libraries with good time functions and don’t have to worry until 2038 when a signed 32-bit integer is unable to hold the number of seconds elapsed since the Unix epoch.\nCharacter encodings did not receive this kind of treatment until the emergence of Unicode but even then we still have massive issues when dealing with them.\nHistory If you don’t want to read through this history class I prepared, you can skip directly to the more interesting topic here: Encoding, Code Pages and Unicode for Programmers.\nElectrical Telegraphy One of the earliest encoding methods is Morse Code which was introduced in the 1840s. The earliest code used commercially was the Cooke and Wheatstone telegraph five needle code, aka C\u0026W5, but no one really used it. Instead, each country went ahead and developed their own code leading to the creation of the American Morse Code:\n1911 Chart of the Standard American Morse Characters from the American School of Correspondence\nThis code had issues so a fellow German named Friedrich Clemens Gerke developed a modified version in 1848 for use on German railways. At that time many central European countries belonged to the German-Austrian Telegraph Union and they quickly decided to adopt this version across all its countries in 1851.\nDue to the widespread use of the Gerke Code it became the International Morse Code in 1865:\nChart of the Morse code letters and numerals by Rhey T. Snodgrass \u0026 Victor F. Camp, 1922\nEven though it is called the “International” Morse Code, US companies refused to adopt it and continued to use the American Morse Code. They didn’t want to re-train their operators and because the telegraph was not state controlled but multiple private companies worked together, they never adopted it.\nSo why am I telling you this 180-year-old story? Back then we already were unable to come to a consensus on what standard to use. The Gerke Code was adopted by the German-Austrian Telegraph Union, but each country developed their own Code at some point because they used special characters in their language. This has been the biggest problem throughout the years. In Europe, we mostly use Latin-based alphabets but over in Asia things looked different:\nObsolete Chinese telegraph codes from Septime Auguste Viguier’s New Book for the Telegraph\nThis is one page from the Chinese Telegraph Code book. There are nearly 10 thousand characters in this book.\nThis is another recurring theme across history. Languages use different alphabets or none at all. A Logography uses written characters that represent a word or morpheme, like Chinese characters. This makes creating encodings for use everywhere really hard because now you don’t have 26 letters in lower and uppercase and a few syntax characters, but thousands of characters that have their own meaning. Most of the technological advancements in telegraphy and digital computers happened in Europe or USA, Asia was often left out and new encodings would focus on Latin-based alphabets.\nAutomatic Telegraphy In 1846 someone had the genius idea of automatically generating Morse code. Previously if you want to transmit a message, you’d go through each letter, look at the Morse Code table and press the required taps.\nBut what if you had a machine with multiple keys where each key corresponds to a different entry in the Morse Code table? A machine with multiple keys where each input corresponds to a different output, where have I heard that before? How about a piano:\nHughes Letter-Printing Telegraph Set built by Siemens and Halske in Saint Petersburg, Russia, ca.1900\nPiano keyboards existed for a long time and are really easy to understand. If you want to transmit an A you just press the key that is marked with an A. No need to look into some weird table and get hand pain by pressing the same key in different intervals for the entire day.\nBut let us not get side-tracked by random history and focus on out main topic: encoding. With these new printing telegraphs the operator stopped sending dots and dashes directly with a single key but instead operated a piano keyboard and a machine which would generated the appropriate Morse Code Point based on the key pressed.\nThe Morse Code was designed to be used by humans meaning common letters were easier to “type” by requiring fewer inputs. In the 1870s Émile Baudot created a new Code to be used by machines instead of humans to make sending and receiving even easier:\nPart of the patent from 1888 (US388244)\nThe Baudot Code is a 5-bit fixed-length binary code and next most important invention after the Morse Code. It is also known as the International Telegraph Alphabet No. 1 (ITA1).\nIf there is a No. 1, there must be a No. 2, so in 1901 Donal Murray modified Baudot Code to create the Murray Code. This code was used with punched paper tape. Now a reperforator could be used to make a perforated copy of received messages and a tape transmitter can send messages from punched tapes. Instead of directly transmitting to the line, the key presses of the operator would punch holes instead, making transmitting multiple messages from one tape very fast.\nOperator fatigue was no longer an issue, instead Murray focused on minimizing machine wear and had to add control characters to control the machine. These characters are Carriage Return and Line Feed also known as CR and LF. If you every wondered where those came from, now you know.\nIn 1924 the International Telegraph Union created the International Telegraph Alphabet No. 2 (ITA2), based on Murray Code, which became the most widespread code as nearly all 20th-century teleprinter equipment used ITA2 or some variant of it.\n1960s ITA2 was very successful but we were going digital. Here are some inventions from this era to paint a picture: IBM created the IBM 704 in 1954 which was the first mass-produced computer with floating-point arithmetic hardware, the first transatlantic communications cable was laid down in 1956 and MIT and Bell Labs created the first Modem in 1959.\nThings started to become digital and electronics became more important. Teleprinter technology also advanced and people wanted to use lowercase characters and additional punctuations. In 1964 the American Standards Association created the famous 7-bit ASCII Code also known as US-ASCII:\nIBM and Code Pages IBM with their mainframe computers played a very important role for us. They were a chief proponent of the ASCII standardization committee however they did not have enough time to prepare ASCII peripherals to ship with the IBM System/360 in 1964. This was a big problem and the company instead created the Extended Binary Coded Decimal Interchange Code (EBCDIC) which is an 8-bit character set.\nThe IBM System/360 was extremely successful and EBCDIC shared in this success. This was a problem, you now have ASCII which IBM really liked and EBCDIC which was used everywhere because everyone used the IBM System/360. Further complications arose since EBCDIC and ASCII were not compatible with each other which resulted in issues when transferring data between systems.\nWith EBCDIC came these new things called Code Pages. Not everyone speaks English and as we have seen before, some languages use a Latin-based alphabet, some use a non-Latin-based alphabet some don’t use an alphabet at all but Logography instead. Not only that but we are currently in the late 20th century when 20-megabyte drives costs 250 USD meaning we have to be space efficient.\nFor these reasons, IBM created code pages for the EBCDIC character set which are represented by a number and change the way you encode certain characters. One important thing I want to mention is that IBM created the code pages but not the standard that was behind it. As an example let’s look at JIS X 0201 which is a Japanese Industrial Standard developed in 1969 and was implemented by IBM as Code Page 897. IBM did not create the standard, they only created the code page that implemented it.\n8-bit architecture In the 1980s the 8-bit architecture led to the 8-bit byte becoming the standard unit of computer storage, so ASCII with its 7-bit length was inconvenient for data retrieval. Thus, in 1987 we got the standard ISO 8859-1 aka Extended ASCII which uses the extra bit for more non-English characters like accented vowels and some currency symbols.\nGoing Unicode It is the year 1980 and a company named Xerox created the Xerox Character Code Standard (XCCS) which is 16-bit and encodes the characters required for languages using the Latin, Arabic, Hebrew, Greek and Cyrillic scripts, the Chinese, Japanese and Korean writing systems, and technical symbols.\nA group with members of Xerox and Apple started thinking about a universal character set in 1987 and used the XCCS as an inspiration. This group quickly grew as people from Sun Microsystems, Microsoft and other companies started to join.\nThe Unicode Consortium which was incorporated in early 1991 published the first volume of the Unicode Standard later that year and the second volume in the next year to include a total of 28,327 characters.\nEncoding, Code Pages and Unicode for Programmers Now that the history class is over we can look at some code.\nWindows API If you ever wrote some C/C++ code and had to work with the Windows API you might wonder why there are multiple versions of the same function like MessageBox, MessageBoxA and MessageBoxW:\n1 2 3 4 5 6 7 8 int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType); #ifdef UNICODE #define MessageBox MessageBoxW #else #define MessageBox MessageBoxA #endif The docs say A means ANSI and the W stands for Unicode, but this is a bit misleading so here is an explanation.\nFirst ANSI is just straight up confusing and a “misnomer”.\nA misnomer is a name that is incorrectly or unsuitably applied.\nMicrosoft themselves said it’s stupid:\nANSI: Acronym for the American National Standards Institute. The term “ANSI” as used to signify Windows code pages is a historical reference, but is nowadays a misnomer that continues to persist in the Windows community. The source of this comes from the fact that the Windows code page 1252 was originally based on an ANSI draft—which became International Organization for Standardization (ISO) Standard 8859-1. “ANSI applications” are usually a reference to non-Unicode or code page–based applications.\nSo going forward I’m just going to call it “Windows Code Pages”.\nNext up is the W for Unicode. The W comes from wchar_t which is an implementation-defined wide character type. In the Microsoft compiler, it represents a 16-bit wide character used to store Unicode encoded as UTF-16LE.\nSo let’s recap:\nMessageBoxA: accepts the 8-bit char type and uses the Windows Code Pages MessageBoxW: accepts the implementation-defined wide wchar_t type and uses UTF-16 MessageBox: just an alias that will use either MessageBoxA or MessageBoxW The fact that wchar_t is implementation-defined is obviously a problem. Windows adopted Unicode when it fit in a 16-bit long type, but that is not the case anymore.\nNow for some code and some experiments:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define WIN32_LEAN_AND_MEAN #include #include \"Windows.h\" int main() { MessageBoxA(nullptr, \"This uses Windows Code Pages\", nullptr, MB_OK); MessageBoxW(nullptr, L\"This uses UTF-16\", nullptr, MB_OK); constexpr char helloShiftJis[] = {static_cast\u003cchar\u003e(0x82), static_cast\u003cchar\u003e(0xB1), static_cast\u003cchar\u003e(0x82), static_cast\u003cchar\u003e(0xF1), static_cast\u003cchar\u003e(0x82), static_cast\u003cchar\u003e(0xC9), static_cast\u003cchar\u003e(0x82), static_cast\u003cchar\u003e(0xBF), static_cast\u003cchar\u003e(0x82), static_cast\u003cchar\u003e(0xCD), '\\0'}; MessageBoxA(nullptr, helloShiftJis, nullptr, MB_OK); MessageBoxW(nullptr, L\"こんにちは\", nullptr, MB_OK); return 0; } The first two calls show what you’d expect to see as they only contain Latin characters. The other calls are more interesting. This hideous array initialization contains the bytes of “こんにちは” encoded in Shift-JIS. My system locale is set to “English (United States)” which means my Windows uses Code Page 1252 aka windows-1252. This Code Page does not contain any of the Hiragana characters and instead of seeing “こんにちは” on screen I get “‚±‚ñ‚É‚¿‚Í”. If change my system locale to “Japanese (Japan)” then Windows would use Shift-JIS aka windows-932 and display “こんにちは” correctly. The MessageBoxW call with L\"こんにちは\" correctly displays “こんにちは” because it’s UTF-16 encoded.\nThe Windows API also provides functions for converting between string types:\n1 2 3 4 5 // convert from a Code Page to UTF-16 int MultiByteToWideChar(UINT CodePage, dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar); // convert from UTF-16 to a Code Page int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar); With the first function we can convert our Shift-JIS encoded string into UTF-16 and correctly display it:\n1 2 3 4 5 6 auto bufferSize = MultiByteToWideChar(932, MB_ERR_INVALID_CHARS, helloShiftJis, -1, nullptr, 0); auto converted = new wchar_t[bufferSize]; MultiByteToWideChar(932, MB_ERR_INVALID_CHARS, helloShiftJis, -1, converted, bufferSize); MessageBoxW(nullptr, converted, nullptr, MB_OK); Current Issues We have looked at the history of character encodings and some examples with the Windows API. Now it’s time to take a look the issues we still have.\nThe Web is united under UTF-8 with over 98% of all web pages using it. This is further enforced by standards like JSON which require UTF-8 encoding. As good as this is, the desktops are still far behind UTF-8 adoption.\nWindows started supporting UTF-8 with Windows XP but only since Windows 10 version 1903 is it the default character encoding for Notepad. These editors are the main culprits as they often default to the current Windows Code Page which makes sharing files internationally a pain.\nThankfully everything is starting to or already using UTF-8, newer languages like Go and Rust basically force you to use UTF-8 and even Microsoft said you should start using it.\nWindows Code Pages are legacy but because it’s still used in production we continue to have issues with character encoding. If you have some issues I recommend trying Locale Emulator.\nClosing Words Props to you if you read this entire thing. I personally had to deal a lot with encoding issues as a lot of games I play come from Japan and don’t work on my machine without a locale emulator.\nI hope this answered some questions you might have around this topic. It is very complex and has a very long history, but this should give you a peak into the issues we still have.\n","wordCount":"2404","inLanguage":"en","datePublished":"2022-04-15T00:00:00Z","dateModified":"2022-11-29T13:34:42+01:00","author":{"@type":"Person","name":"erri120"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://erri120.github.io/posts/2022-04-15/"},"publisher":{"@type":"Organization","name":"erri120's random Blog","logo":{"@type":"ImageObject","url":"https://erri120.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://erri120.github.io accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://erri120.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://erri120.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://erri120.github.io/archives/ title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://erri120.github.io>Home</a>&nbsp;»&nbsp;<a href=https://erri120.github.io/posts/>Posts</a></div><h1 class=post-title>Everything about Unicode, Code Pages and Character Encoding</h1><div class=post-meta><span title='2022-04-15 00:00:00 +0000 UTC'>2022-04-15</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2404 words&nbsp;·&nbsp;erri120&nbsp;|&nbsp;<a href=https://github.com/erri120/erri120.github.io/edit/master/content/posts/2022-04-15.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#history>History</a><ul><li><a href=#electrical-telegraphy>Electrical Telegraphy</a></li><li><a href=#automatic-telegraphy>Automatic Telegraphy</a></li><li><a href=#1960s>1960s</a></li><li><a href=#ibm-and-code-pages>IBM and Code Pages</a></li><li><a href=#8-bit-architecture>8-bit architecture</a></li><li><a href=#going-unicode>Going Unicode</a></li></ul></li><li><a href=#encoding-code-pages-and-unicode-for-programmers>Encoding, Code Pages and Unicode for Programmers</a><ul><li><a href=#windows-api>Windows API</a></li><li><a href=#current-issues>Current Issues</a></li></ul></li><li><a href=#closing-words>Closing Words</a></li></ul></nav></div></details></div><div class=post-content><p>Time and Character encoding are the two things a programmer never wants to touch. Thankfully dealing with time has been made very easy, we developed ISO Standards, created standard libraries with good time functions and don&rsquo;t have to worry until 2038 when a signed 32-bit integer is unable to hold the number of seconds elapsed since the Unix epoch.</p><p>Character encodings did not receive this kind of treatment until the emergence of Unicode but even then we still have massive issues when dealing with them.</p><h2 id=history>History<a hidden class=anchor aria-hidden=true href=#history>#</a></h2><p>If you don&rsquo;t want to read through this history class I prepared, you can skip directly to the more interesting topic here: <a href=#encoding-code-pages-and-unicode-for-programmers>Encoding, Code Pages and Unicode for Programmers</a>.</p><h3 id=electrical-telegraphy>Electrical Telegraphy<a hidden class=anchor aria-hidden=true href=#electrical-telegraphy>#</a></h3><p>One of the earliest encoding methods is Morse Code which was introduced in the 1840s. The earliest code used commercially was the Cooke and Wheatstone telegraph five needle code, aka <em>C&W5</em>, but no one really used it. Instead, each country went ahead and developed their own code leading to the creation of the American Morse Code:</p><figure class=align-center><img loading=lazy src=/img/posts/2022-04-15/American_Morse_Code.png#center alt="Image of the 1911 Chart of the Standard American Morse Characters"><figcaption><p>1911 Chart of the Standard American Morse Characters from the American School of Correspondence</p></figcaption></figure><p>This code had issues so a fellow German named Friedrich Clemens Gerke developed a modified version in 1848 for use on German railways. At that time many central European countries belonged to the German-Austrian Telegraph Union and they quickly decided to adopt this version across all its countries in 1851.</p><p>Due to the widespread use of the Gerke Code it became the International Morse Code in 1865:</p><figure class=align-center><img loading=lazy src=/img/posts/2022-04-15/International_Morse_Code.png#center alt="Chart of the Morse code letters and numerals."><figcaption><p>Chart of the Morse code letters and numerals by Rhey T. Snodgrass & Victor F. Camp, 1922</p></figcaption></figure><p>Even though it is called the &ldquo;International&rdquo; Morse Code, US companies refused to adopt it and continued to use the American Morse Code. They didn&rsquo;t want to re-train their operators and because the telegraph was not state controlled but multiple private companies worked together, they never adopted it.</p><p>So why am I telling you this 180-year-old story? Back then we already were unable to come to a consensus on what standard to use. The Gerke Code was adopted by the German-Austrian Telegraph Union, but each country developed their own Code at some point because they used special characters in their language. This has been the biggest problem throughout the years. In Europe, we mostly use Latin-based alphabets but over in Asia things looked different:</p><figure class=align-center><img loading=lazy src=/img/posts/2022-04-15/chinese_telegraph_code.jpg#center alt="Obsolete Chinese telegraph codes from 0001 to 0200. Each cell of the table shows a four-digit numerical code written in Chinese, and a Chinese character corresponding to the code."><figcaption><p>Obsolete Chinese telegraph codes from Septime Auguste Viguier’s <em>New Book for the Telegraph</em></p></figcaption></figure><p>This is <strong>one page</strong> from the Chinese Telegraph Code book. There are nearly <strong>10 thousand characters</strong> in this book.</p><p>This is another recurring theme across history. Languages use different alphabets or none at all. A Logography uses written characters that represent a word or morpheme, like Chinese characters. This makes creating encodings for use everywhere really hard because now you don&rsquo;t have 26 letters in lower and uppercase and a few syntax characters, but thousands of characters that have their own meaning. Most of the technological advancements in telegraphy and digital computers happened in Europe or USA, Asia was often left out and new encodings would focus on Latin-based alphabets.</p><h3 id=automatic-telegraphy>Automatic Telegraphy<a hidden class=anchor aria-hidden=true href=#automatic-telegraphy>#</a></h3><p>In 1846 someone had the genius idea of automatically generating Morse code. Previously if you want to transmit a message, you&rsquo;d go through each letter, look at the Morse Code table and press the required taps.</p><p>But what if you had a machine with multiple keys where each key corresponds to a different entry in the Morse Code table? A machine with multiple keys where each input corresponds to a different output, where have I heard that before? How about a piano:</p><figure class=align-center><img loading=lazy src=/img/posts/2022-04-15/Printing_Telegraph.jpg#center alt="Hughes Letter-Printing Telegraph Set built by Siemens and Halske in Saint Petersburg, Russia, ca.1900"><figcaption><p>Hughes Letter-Printing Telegraph Set built by Siemens and Halske in Saint Petersburg, Russia, ca.1900</p></figcaption></figure><p>Piano keyboards existed for a long time and are really easy to understand. If you want to transmit an <code>A</code> you just press the key that is marked with an <code>A</code>. No need to look into some weird table and get hand pain by pressing the same key in different intervals for the entire day.</p><p>But let us not get side-tracked by random history and focus on out main topic: encoding. With these new printing telegraphs the operator stopped sending dots and dashes directly with a single key but instead operated a piano keyboard and a machine which would generated the appropriate Morse Code Point based on the key pressed.</p><p>The Morse Code was designed to be used by humans meaning common letters were easier to &ldquo;type&rdquo; by requiring fewer inputs. In the 1870s Émile Baudot created a new Code to be used by machines instead of humans to make sending and receiving even easier:</p><figure class=align-center><img loading=lazy src=/img/posts/2022-04-15/Baudot_Code.png#center alt="Baudot Code"><figcaption><p>Part of the patent from 1888
<a href=https://patents.google.com/patent/US388244>(US388244)</a></p></figcaption></figure><p>The Baudot Code is a 5-bit fixed-length binary code and next most important invention after the Morse Code. It is also known as the International Telegraph Alphabet No. 1 (ITA1).</p><p>If there is a No. 1, there must be a No. 2, so in 1901 Donal Murray modified Baudot Code to create the Murray Code. This code was used with punched paper tape. Now a reperforator could be used to make a perforated copy of received messages and a tape transmitter can send messages from punched tapes. Instead of directly transmitting to the line, the key presses of the operator would punch holes instead, making transmitting multiple messages from one tape very fast.</p><p>Operator fatigue was no longer an issue, instead Murray focused on minimizing machine wear and had to add <em>control characters</em> to control the machine. These characters are <em>Carriage Return</em> and <em>Line Feed</em> also known as CR and LF. If you every wondered where those came from, now you know.</p><p>In 1924 the International Telegraph Union created the International Telegraph Alphabet No. 2 (ITA2), based on Murray Code, which became the most widespread code as nearly all 20th-century teleprinter equipment used ITA2 or some variant of it.</p><h3 id=1960s>1960s<a hidden class=anchor aria-hidden=true href=#1960s>#</a></h3><p>ITA2 was very successful but we were going digital. Here are some inventions from this era to paint a picture: IBM created the IBM 704 in 1954 which was the first mass-produced computer with floating-point arithmetic hardware, the first transatlantic communications cable was laid down in 1956 and MIT and Bell Labs created the first Modem in 1959.</p><p>Things started to become digital and electronics became more important. Teleprinter technology also advanced and people wanted to use lowercase characters and additional punctuations. In 1964 the American Standards Association created the famous 7-bit ASCII Code also known as US-ASCII:</p><figure class=align-center><img loading=lazy src=/img/posts/2022-04-15/ASCII_Code_Chart.png#center alt="ASCII Code Chart"></figure><h3 id=ibm-and-code-pages>IBM and Code Pages<a hidden class=anchor aria-hidden=true href=#ibm-and-code-pages>#</a></h3><p>IBM with their mainframe computers played a very important role for us. They were a chief proponent of the ASCII standardization committee however they did not have enough time to prepare ASCII peripherals to ship with the IBM System/360 in 1964. This was a big problem and the company instead created the Extended Binary Coded Decimal Interchange Code (EBCDIC) which is an 8-bit character set.</p><p>The IBM System/360 was extremely successful and EBCDIC shared in this success. This was a problem, you now have ASCII which IBM really liked and EBCDIC which was used everywhere because everyone used the IBM System/360. Further complications arose since EBCDIC and ASCII were not compatible with each other which resulted in issues when transferring data between systems.</p><p>With EBCDIC came these new things called <em>Code Pages</em>. Not everyone speaks English and as we have seen before, some languages use a Latin-based alphabet, some use a non-Latin-based alphabet some don&rsquo;t use an alphabet at all but Logography instead. Not only that but we are currently in the late 20th century when 20-megabyte drives costs 250 USD meaning we have to be space efficient.</p><p>For these reasons, IBM created code pages for the EBCDIC character set which are represented by a number and change the way you encode certain characters. One important thing I want to mention is that IBM created the code pages but not the standard that was behind it. As an example let&rsquo;s look at JIS X 0201 which is a Japanese Industrial Standard developed in 1969 and was implemented by IBM as Code Page 897. IBM did not create the standard, they only created the code page that implemented it.</p><h3 id=8-bit-architecture>8-bit architecture<a hidden class=anchor aria-hidden=true href=#8-bit-architecture>#</a></h3><p>In the 1980s the 8-bit architecture led to the 8-bit byte becoming the standard unit of computer storage, so ASCII with its 7-bit length was inconvenient for data retrieval. Thus, in 1987 we got the standard ISO 8859-1 aka Extended ASCII which uses the extra bit for more non-English characters like accented vowels and some currency symbols.</p><h3 id=going-unicode>Going Unicode<a hidden class=anchor aria-hidden=true href=#going-unicode>#</a></h3><p>It is the year 1980 and a company named Xerox created the Xerox Character Code Standard (XCCS) which is 16-bit and encodes the characters required for languages using the Latin, Arabic, Hebrew, Greek and Cyrillic scripts, the Chinese, Japanese and Korean writing systems, and technical symbols.</p><p>A group with members of Xerox and Apple started thinking about a universal character set in 1987 and used the XCCS as an inspiration. This group quickly grew as people from Sun Microsystems, Microsoft and other companies started to join.</p><p>The Unicode Consortium which was incorporated in early 1991 published the first volume of the Unicode Standard later that year and the second volume in the next year to include a total of 28,327 characters.</p><h2 id=encoding-code-pages-and-unicode-for-programmers>Encoding, Code Pages and Unicode for Programmers<a hidden class=anchor aria-hidden=true href=#encoding-code-pages-and-unicode-for-programmers>#</a></h2><p>Now that the history class is over we can look at some code.</p><h3 id=windows-api>Windows API<a hidden class=anchor aria-hidden=true href=#windows-api>#</a></h3><p>If you ever wrote some C/C++ code and had to work with the Windows API you might wonder why there are multiple versions of the same function like <code>MessageBox</code>, <code>MessageBoxA</code> and <code>MessageBoxW</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>MessageBoxA</span><span class=p>(</span><span class=n>HWND</span> <span class=n>hWnd</span><span class=p>,</span> <span class=n>LPCSTR</span> <span class=n>lpText</span><span class=p>,</span> <span class=n>LPCSTR</span> <span class=n>lpCaption</span><span class=p>,</span> <span class=n>UINT</span> <span class=n>uType</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>MessageBoxW</span><span class=p>(</span><span class=n>HWND</span> <span class=n>hWnd</span><span class=p>,</span> <span class=n>LPCWSTR</span> <span class=n>lpText</span><span class=p>,</span> <span class=n>LPCWSTR</span> <span class=n>lpCaption</span><span class=p>,</span> <span class=n>UINT</span> <span class=n>uType</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef UNICODE
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cp>#define MessageBox  MessageBoxW
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cp>#define MessageBox  MessageBoxA
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><p>The <a href=https://docs.microsoft.com/en-us/windows/win32/intl/conventions-for-function-prototypes>docs</a> say <code>A</code> means <em>ANSI</em> and the <code>W</code> stands for <em>Unicode</em>, but this is a bit misleading so here is an explanation.</p><p>First <em>ANSI</em> is just straight up confusing and a &ldquo;misnomer&rdquo;.</p><blockquote><p>A misnomer is a name that is incorrectly or unsuitably applied.</p></blockquote><p>Microsoft themselves said <a href=https://web.archive.org/web/20181208141313/https://msdn.microsoft.com/en-us/goglobal/bb964658.aspx#a>it&rsquo;s stupid</a>:</p><blockquote><p><strong>ANSI</strong>: Acronym for the American National Standards Institute. The term “ANSI” as used to signify Windows code pages is a historical reference, but is nowadays a misnomer that continues to persist in the Windows community. The source of this comes from the fact that the Windows code page 1252 was originally based on an ANSI draft—which became International Organization for Standardization (ISO) Standard 8859-1. “ANSI applications” are usually a reference to non-Unicode or code page–based applications.</p></blockquote><p>So going forward I&rsquo;m just going to call it &ldquo;Windows Code Pages&rdquo;.</p><p>Next up is the <code>W</code> for <em>Unicode</em>. The <code>W</code> comes from <code>wchar_t</code> which is an <strong>implementation-defined</strong> wide character type. In the Microsoft compiler, it represents a 16-bit wide character used to store Unicode encoded as UTF-16LE.</p><p>So let&rsquo;s recap:</p><ul><li><code>MessageBoxA</code>: accepts the 8-bit <code>char</code> type and uses the Windows Code Pages</li><li><code>MessageBoxW</code>: accepts the implementation-defined wide <code>wchar_t</code> type and uses UTF-16</li><li><code>MessageBox</code>: just an alias that will use either <code>MessageBoxA</code> or <code>MessageBoxW</code></li></ul><p>The fact that <code>wchar_t</code> is implementation-defined is obviously a problem. Windows adopted Unicode when it fit in a 16-bit long type, but that is not the case anymore.</p><p>Now for some code and some experiments:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define WIN32_LEAN_AND_MEAN
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Windows.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MessageBoxA</span><span class=p>(</span><span class=k>nullptr</span><span class=p>,</span> <span class=s>&#34;This uses Windows Code Pages&#34;</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=n>MB_OK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>MessageBoxW</span><span class=p>(</span><span class=k>nullptr</span><span class=p>,</span> <span class=sa>L</span><span class=s>&#34;This uses UTF-16&#34;</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=n>MB_OK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>char</span> <span class=n>helloShiftJis</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0x82</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0xB1</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0x82</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0xF1</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0x82</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0xC9</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0x82</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0xBF</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0x82</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>(</span><span class=mh>0xCD</span><span class=p>),</span> <span class=sc>&#39;\0&#39;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>MessageBoxA</span><span class=p>(</span><span class=k>nullptr</span><span class=p>,</span> <span class=n>helloShiftJis</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=n>MB_OK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>MessageBoxW</span><span class=p>(</span><span class=k>nullptr</span><span class=p>,</span> <span class=sa>L</span><span class=s>&#34;こんにちは&#34;</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=n>MB_OK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The first two calls show what you&rsquo;d expect to see as they only contain Latin characters. The other calls are more interesting. This hideous array initialization contains the bytes of &ldquo;こんにちは&rdquo; encoded in Shift-JIS. My system locale is set to &ldquo;English (United States)&rdquo; which means my Windows uses Code Page 1252 aka <code>windows-1252</code>. This Code Page does not contain any of the Hiragana characters and instead of seeing &ldquo;こんにちは&rdquo; on screen I get &ldquo;‚±‚ñ‚É‚¿‚Í&rdquo;. If change my system locale to &ldquo;Japanese (Japan)&rdquo; then Windows would use Shift-JIS aka <code>windows-932</code> and display &ldquo;こんにちは&rdquo; correctly. The <code>MessageBoxW</code> call with <code>L"こんにちは"</code> correctly displays &ldquo;こんにちは&rdquo; because it&rsquo;s UTF-16 encoded.</p><p>The Windows API also provides functions for converting between string types:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// convert from a Code Page to UTF-16
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>MultiByteToWideChar</span><span class=p>(</span><span class=n>UINT</span> <span class=n>CodePage</span><span class=p>,</span> <span class=n>dwFlags</span><span class=p>,</span> <span class=n>LPCCH</span> <span class=n>lpMultiByteStr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cbMultiByte</span><span class=p>,</span> <span class=n>LPWSTR</span> <span class=n>lpWideCharStr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cchWideChar</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// convert from UTF-16 to a Code Page
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>WideCharToMultiByte</span><span class=p>(</span><span class=n>UINT</span> <span class=n>CodePage</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>dwFlags</span><span class=p>,</span> <span class=n>LPCWCH</span> <span class=n>lpWideCharStr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cchWideChar</span><span class=p>,</span> <span class=n>LPSTR</span> <span class=n>lpMultiByteStr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cbMultiByte</span><span class=p>,</span> <span class=n>LPCCH</span> <span class=n>lpDefaultChar</span><span class=p>,</span> <span class=n>LPBOOL</span> <span class=n>lpUsedDefaultChar</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>With the first function we can convert our Shift-JIS encoded string into UTF-16 and correctly display it:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=n>MultiByteToWideChar</span><span class=p>(</span><span class=mi>932</span><span class=p>,</span> <span class=n>MB_ERR_INVALID_CHARS</span><span class=p>,</span> <span class=n>helloShiftJis</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>converted</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>wchar_t</span><span class=p>[</span><span class=n>bufferSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>MultiByteToWideChar</span><span class=p>(</span><span class=mi>932</span><span class=p>,</span> <span class=n>MB_ERR_INVALID_CHARS</span><span class=p>,</span> <span class=n>helloShiftJis</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>converted</span><span class=p>,</span> <span class=n>bufferSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>MessageBoxW</span><span class=p>(</span><span class=k>nullptr</span><span class=p>,</span> <span class=n>converted</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=n>MB_OK</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=current-issues>Current Issues<a hidden class=anchor aria-hidden=true href=#current-issues>#</a></h3><p>We have looked at the history of character encodings and some examples with the Windows API. Now it&rsquo;s time to take a look the issues we still have.</p><p>The Web is united under UTF-8 with <a href=https://w3techs.com/technologies/cross/character_encoding/ranking>over 98% of all web pages using it</a>. This is further enforced by standards like JSON which require UTF-8 encoding. As good as this is, the desktops are still far behind UTF-8 adoption.</p><p>Windows started supporting UTF-8 with Windows XP but only since Windows 10 version 1903 is it the <a href=https://www.winhelponline.com/blog/set-default-encoding-notepad-ansi-utf-8/>default character encoding for Notepad</a>. These editors are the main culprits as they often default to the current Windows Code Page which makes sharing files internationally a pain.</p><p>Thankfully everything is starting to or already using UTF-8, newer languages like Go and Rust basically force you to use UTF-8 and even Microsoft said <a href=https://docs.microsoft.com/en-us/windows/apps/design/globalizing/use-utf8-code-page>you should start using it</a>.</p><p>Windows Code Pages are legacy but because it&rsquo;s still used in production we continue to have issues with character encoding. If you have some issues I recommend trying <a href=https://github.com/xupefei/Locale-Emulator>Locale Emulator</a>.</p><h2 id=closing-words>Closing Words<a hidden class=anchor aria-hidden=true href=#closing-words>#</a></h2><p>Props to you if you read this entire thing. I personally had to deal a lot with encoding issues as a lot of games I play come from Japan and don&rsquo;t work on my machine without a locale emulator.</p><p>I hope this answered some questions you might have around this topic. It is very complex and has a very long history, but this should give you a peak into the issues we still have.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://erri120.github.io/tags/character-encoding/>Character Encoding</a></li><li><a href=https://erri120.github.io/tags/c++/>C++</a></li></ul><nav class=paginav><a class=prev href=https://erri120.github.io/posts/2022-05-05/><span class=title>« Prev</span><br><span>Getting started with GNU gettext for C++</span></a>
<a class=next href=https://erri120.github.io/posts/2021-12-10/><span class=title>Next »</span><br><span>Fixing Anno 2070 by changing three bytes</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Everything about Unicode, Code Pages and Character Encoding on twitter" href="https://twitter.com/intent/tweet/?text=Everything%20about%20Unicode%2c%20Code%20Pages%20and%20Character%20Encoding&url=https%3a%2f%2ferri120.github.io%2fposts%2f2022-04-15%2f&hashtags=CharacterEncoding%2cC%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Everything about Unicode, Code Pages and Character Encoding on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ferri120.github.io%2fposts%2f2022-04-15%2f&title=Everything%20about%20Unicode%2c%20Code%20Pages%20and%20Character%20Encoding"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=erri120/erri120.github.io issue-term=pathname label=site-comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://erri120.github.io>erri120's random Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
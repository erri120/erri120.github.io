<!doctype html><html lang=en><head><title>Everything about Unicode, Code Pages and Character Encoding :: erri120's very random Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="An in-depth post detailing the origins of Unicode, Code Pages and Character Encodings."><meta name=keywords content="Character Encoding"><meta name=robots content="noodp"><link rel=canonical href=https://erri120.github.io/posts/2022-04-15/><link rel=stylesheet href=https://erri120.github.io/assets/style.css><link rel=stylesheet href=https://erri120.github.io/assets/organe.css><link rel=apple-touch-icon href=https://erri120.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://erri120.github.io/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="erri120"><meta name=twitter:creator content="erri120"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Everything about Unicode, Code Pages and Character Encoding"><meta property="og:description" content="An in-depth post detailing the origins of Unicode, Code Pages and Character Encodings."><meta property="og:url" content="https://erri120.github.io/posts/2022-04-15/"><meta property="og:site_name" content="erri120's very random Blog"><meta property="article:published_time" content="2022-04-15 00:00:00 +0000 UTC"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","name":"Everything about Unicode, Code Pages and Character Encoding","description":"An in-depth post detailing the origins of Unicode, Code Pages and Character Encodings.","author":{"@type":"Person","name":"erri120"},"datePublished":"2022-04-15","headling":"Everything about Unicode, Code Pages and Character Encoding","keywords":"Character Encoding"}</script><link href=/posts/2022-04-15/index.xml rel=alternate type=application/rss+xml title="erri120's very random Blog"><meta name=google-site-verification content="c-L5KbBKeVyZ9YNKiotqlpl7zsiDRiGcWJa4ZxVpzAo"><meta name=msvalidate.01 content="0E353603CBFC6B4F85D605C4E9F27290"><script data-goatcounter=https://erri120.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body class=organe><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>erri120's Blog</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li></ul></nav></header><div class=content><main class=post><article><h1 class=post-title><a href=https://erri120.github.io/posts/2022-04-15/>Everything about Unicode, Code Pages and Character Encoding</a></h1><div class=post-meta><span class=post-date><time datetime=2022-04-15>2022-04-15</time></span>
<span class=post-author>:: erri120</span></div><span class=post-tags>#<a href=https://erri120.github.io/tags/other/>Other</a>&nbsp;</span><div class=post-content><div><p>Time and Encodings are the two things a programmer never wants to touch. Thankfully dealing with time has been made very easy, we developed ISO Standards, created standard libraries with good time functions and don&rsquo;t have to worry until 2038 when a signed 32-bit integer is unable to hold the number of seconds elapsed since the Unix epoch.</p><p>Encodings did not receive this kind of treatment until the emergence of Unicode but even then we still have massive issues when dealing with them.</p><h2 id=history>History<a href=#history class=hanchor arialabel=Anchor>&#8983;</a></h2><p>If you don&rsquo;t want to read through this history class I prepared, you can skip directly to the more interesting topic here: <a href=#encoding-code-pages-and-unicode-for-programmers>Encoding, Code Pages and Unicode for Programmers</a></p><h3 id=electrical-telegraphy>Electrical Telegraphy<a href=#electrical-telegraphy class=hanchor arialabel=Anchor>&#8983;</a></h3><p>One of the earliest encoding methods is Morse Code which was introduced in the 1840s. The earliest code used commercially was the Cooke and Wheatstone telegraph five needle code, aka <em>C&W5</em>, but no one really used it. Instead each country went ahead and developed their own code leading to the creation of the American Morse Code:</p><img src=/img/posts/2022-04-15/American_Morse_Code.png alt="American Morse Code" class=left><p>This code had issues so a fellow German named Friedrich Clemens Gerke developed a modified version in 1848 for use on German railways. At that time many central European countries belonged to the German-Austrian Telegraph Union so they quickly decided to adopt this version across all its countries in 1851.</p><p>Due to the widespread use of the Gerke Code it became the International Morse Code in 1865:</p><img src=/img/posts/2022-04-15/International_Morse_Code.png alt="International Morse Code" class=left><p>Even though it is called the &ldquo;International&rdquo; Morse Code, US companies refused to adopt it and continued to use the American Morse Code. They didn&rsquo;t want to re-train their operators and because the telegraph was not state controlled but multiple private companies worked together, they never adopted it.</p><p>So why am I telling you this 180 year old story? Back then we already were unable to come to a consensus on what standard to use. The Gerke Code was adopted by the German-Austrian Telegraph Union but each country developed their own Code at some point because they used special characters in their language. This has been the biggest problem throughout the years. In Europe we mostly use Latin-based alphabets but over in Asia things looked different:</p><img src=/img/posts/2022-04-15/chinese_telegraph_code.jpg alt="Chinese Telegraph Code" class=left><p>This is <strong>one page</strong> from the Chinese Telegraph Code book. There are nearly <strong>10 thousand characters</strong> in this book.</p><p>This is another recurring theme across history. Languages use different alphabets or non at all. A Logography uses written characters that represent a word or morpheme, like Chinese characters. This makes creating encodings for use everywhere really hard because now you don&rsquo;t have 26 letters in lower and uppercase and a few syntax characters but thousands of characters that have their own meaning. Most of the technological advancements in telegraphy and digital computers happend in Europe or USA, Asia was often left out and new encodings would focus on Latin-based alphabets.</p><h3 id=automatic-telegraphy>Automatic Telegraphy<a href=#automatic-telegraphy class=hanchor arialabel=Anchor>&#8983;</a></h3><p>In 1846 someone had the genius idea of automatically generating morse code. Previously if you want to transmit a message, you&rsquo;d go through each letter, look at the Morse Code table and press the required taps.</p><p>But what if you had a machine with multiple keys where each key corresponds to a different entry in the Morse Code table? A machine with multiple keys where each input corresponds to a different output, where have I heard that before? How about a piano:</p><img src=/img/posts/2022-04-15/Printing_Telegraph.jpg alt="Printing Telegraph" class=left><p>Piano keyboards existed for a long time and are really easy to understand. If you want to transmit an <code>A</code> you just press the key that is marked with an <code>A</code>. No need to look into some weird table and get hand pain by pressing the same key in different intervals for the entire day.</p><p>But let us not get side-tracked by random history and focus on out main topic: encoding. With these new printing telegraphs the operator stopped sending dots and dashes directly with a single key but instead operated a piano keyboard and a machine which would generated the appropriate Morse Code Point based on the key pressed.</p><p>The Morse Code was designed to be used by humans so common letters were easier to &ldquo;type&rdquo; by requiring less inputs. In the 1870s Émile Baudot created a new Code to be used by machines instead of humans to make sending and receiving even easier:</p><img src=/img/posts/2022-04-15/Baudot_Code.png alt="Baudot Code" class=left><p>The Baudot Code is a 5-bit fixed-length binary code and next most important invention after the Morse Code. It is also known as the International Telegraph Alphabet No. 1 (ITA1).</p><p>If there is a No. 1, there must be a No. 2 so in 1901 Donal Murray modified Baudot Code to create the Murray Code. This code was used with punched paper tape so now a reperforator could be used to make a perforated copy of received messages and a tape transmitter can send messages from punched tapes. Instead of directly transmitting to the line, the keypresses of the operator would punch holes instead, making transmitting multiple messages from one tape very fast.</p><p>Operator fatigue was no longer an issue so Murray focused on minimising machine wear and had to add <em>control characters</em> to control the machine. These characters are <em>Carriage Return</em> and <em>Line Feed</em> also known as CR and LF. If you every wondered where those came from, now you know.</p><p>In 1924 the International Telegraph Union created the International Telegraph Alphabet No. 2 (ITA2), based on Murray Code, which became the most widespread code as nearly all 20th-century teleprinter equipment used ITA2 or some variant of it.</p><h3 id=1960s>1960s<a href=#1960s class=hanchor arialabel=Anchor>&#8983;</a></h3><p>ITA2 was very successful but we were going digital. Here are some inventions from this era to paint a picture: IBM created the IBM 704 in 1954 which was the first mass-produced computer with floating-point arithmetic hardware, the first transatlantic communications cable was laid down in 1956 and MIT and Bell Labs created the first Modem in 1959.</p><p>Things started to become digital and electronics became more important. Teleprinter technology also advanced and people wanted to use lowercase characters and additional punctuations so in 1964 the American Standards Association created the famous 7-bit ASCII Code also known as US-ASCII:</p><img src=/img/posts/2022-04-15/ASCII_Code_Chart.png alt="ASCII Code Chart" class=left><h3 id=ibm-and-code-pages>IBM and Code Pages<a href=#ibm-and-code-pages class=hanchor arialabel=Anchor>&#8983;</a></h3><p>IBM with their mainframe computers played a very important role for us. IBM was a chief proponent of the ASCII standardization committee however they did not have enough time to prepare ASCII peripherals to ship with the IBM System/360 in 1964. This was a big problem so the company created the Extended Binary Coded Decimal Interchange Code (EBCDIC) which is an 8-bit character set.</p><p>The IBM System/360 was extremely successful so EBCDIC was as well. This was a problem, you now have ASCII which IBM really liked and EBCDIC which was used everywhere because everyone used the IBM System/360.</p><p>EBCDIC and ASCII were not compatible with each other which resulted in issues when transferring data to a system that uses the other encoding.</p><p>With EBCDIC came these new things called <em>Code Pages</em>. Not everyone speaks English and as we have seen before, some languages use a Latin-based alphabet, some use a non-Latin-based alphabet some don&rsquo;t use an alphabet at all but logography instead. Not only that but we are currently in the late 20th century where 20-megabyte drives costs 250 USD so we have to be space efficient.</p><p>For these reasons, IBM created code pages for the EBCDIC character set which are represented by a number and change the way you encode certain characters. One important thing I want to mention is that IBM created the code pages but not the standard that was behind it. As an example let&rsquo;s look at JIS X 0201 which is a Japanese Industrial Standard developed in 1969 and was implemented by IBM as Code Page 897. IBM did not create the standard, they only created the code page that implemented it.</p><h3 id=8-bit-architecture>8-bit architecture<a href=#8-bit-architecture class=hanchor arialabel=Anchor>&#8983;</a></h3><p>In 1980s the 8-bit architecture led to the 8-bit byte becoming the standard unit of computer storage so ASCII with it&rsquo;s 7-bit length was inconvenient for data retrieval. Thus in 1987 we got the standard ISO 8859-1 aka Extended ASCII which uses the extra bit for more non-English characters like accented vowels and some currency symbols.</p><h3 id=going-unicode>Going Unicode<a href=#going-unicode class=hanchor arialabel=Anchor>&#8983;</a></h3><p>It is the year 1980 and a company named Xerox created the Xerox Character Code Standard (XCCS) which is 16-bit in length and encodes the characters required for languages using the Latin, Arabic, Hebrew, Greek and Cyrillic scripts, the Chinese, Japanese and Korean writing systems, and technical symbols.</p><p>A group with members of Xerox and Apple started thinking about a universal character set in 1987 and used the XCCS as an inspiration. This group quickly grew as people from Sun Microsystems, Microsoft and other companies started to join.</p><p>The Unicode Consortium which was incorporated in early 1991 published the first volume of the Unicode Standard later that year and the second volume in the next year to include a total of 28,327 characters.</p><h2 id=encoding-code-pages-and-unicode-for-programmers>Encoding, Code Pages and Unicode for Programmers<a href=#encoding-code-pages-and-unicode-for-programmers class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Now that the history class is over we can look at some code.</p><h3 id=windows-api>Windows API<a href=#windows-api class=hanchor arialabel=Anchor>&#8983;</a></h3><p>If you ever wrote some C/C++ code and had to work with the Windows API you might wonder why there are multiple versions of the same function like <code>MessageBox</code>, <code>MessageBoxA</code> and <code>MessageBoxW</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>MessageBoxA</span>(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>MessageBoxW</span>(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef UNICODE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#define MessageBox  MessageBoxW
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#define MessageBox  MessageBoxA
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div><p>The <a href=https://docs.microsoft.com/en-us/windows/win32/intl/conventions-for-function-prototypes>docs</a> say <code>A</code> means <em>ANSI</em> and the <code>W</code> stands for <em>Unicode</em> but this is a bit misleading so here is an explanation.</p><p>First <em>ANSI</em> is just straight up confusing and a &ldquo;misnomer&rdquo;.</p><blockquote><p>A misnomer is a name that is incorrectly or unsuitably applied.</p></blockquote><p>Microsoft themselves said it&rsquo;s stupid<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>:</p><blockquote><p>ANSI: Acronym for the American National Standards Institute. The term “ANSI” as used to signify Windows code pages is a historical reference, but is nowadays a misnomer that continues to persist in the Windows community. The source of this comes from the fact that the Windows code page 1252 was originally based on an ANSI draft—which became International Organization for Standardization (ISO) Standard 8859-1. “ANSI applications” are usually a reference to non-Unicode or code page–based applications.</p></blockquote><p>So going forward I&rsquo;m just going to call it &ldquo;Windows Code Pages&rdquo;.</p><p>Next up is the <code>W</code> for <em>Unicode</em>. The <code>W</code> comes from <code>wchar_t</code> which is an <strong>implementation-defined</strong> wide character type. In the Microsoft compiler, it represents a 16-bit wide character used to store Unicode encoded as UTF-16LE.</p><p>So let&rsquo;s recap:</p><ul><li><code>MessageBoxA</code>: accepts the 8-bit <code>char</code> type and uses the Windows Code Pages</li><li><code>MessageBoxW</code>: accepts the implementation-defined wide <code>wchar_t</code> type and uses UTF-16</li><li><code>MessageBox</code>: just an alias that will use either <code>MessageBoxA</code> or <code>MessageBoxW</code></li></ul><p>The fact that <code>wchar_t</code> is implementation-defined is obviously a problem. Windows adopted Unicode when it fit in a 16-bit long type but that is not the case anymore.</p><p>Now for some code and some experiments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define WIN32_LEAN_AND_MEAN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;Windows.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  MessageBoxA(<span style=color:#66d9ef>nullptr</span>, <span style=color:#e6db74>&#34;This uses Windows Code Pages&#34;</span>, <span style=color:#66d9ef>nullptr</span>, MB_OK);
</span></span><span style=display:flex><span>  MessageBoxW(<span style=color:#66d9ef>nullptr</span>, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;This uses UTF-16&#34;</span>, <span style=color:#66d9ef>nullptr</span>, MB_OK);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>char</span> helloShiftJis[] <span style=color:#f92672>=</span> {<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0x82</span>), <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0xB1</span>), <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0x82</span>), <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0xF1</span>), <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0x82</span>), <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0xC9</span>), <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0x82</span>), <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0xBF</span>), <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0x82</span>), <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>0xCD</span>), <span style=color:#e6db74>&#39;\0&#39;</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  MessageBoxA(<span style=color:#66d9ef>nullptr</span>, helloShiftJis, <span style=color:#66d9ef>nullptr</span>, MB_OK);
</span></span><span style=display:flex><span>  MessageBoxW(<span style=color:#66d9ef>nullptr</span>, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;こんにちは&#34;</span>, <span style=color:#66d9ef>nullptr</span>, MB_OK);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The first two calls show what you&rsquo;d expect to see as they only contain Latin characters. The other calls are more interesting. This hideous array initialization contains the bytes of &ldquo;こんにちは&rdquo; encoded in Shift-JIS. My system locale is set to &ldquo;English (United States)&rdquo; which means my Windows uses Code Page 1252 aka <code>windows-1252</code>. This Code Page does not contain any of the Hiragana characters so instead of seeing &ldquo;こんにちは&rdquo; on screen I get &ldquo;‚±‚ñ‚É‚¿‚Í&rdquo;. If change my system locale to &ldquo;Japanese (Japan)&rdquo; then Windows would use Shift-JIS aka <code>windows-932</code> and display &ldquo;こんにちは&rdquo; correctly. The <code>MessageBoxW</code> call with <code>L"こんにちは"</code> correctly displays &ldquo;こんにちは&rdquo; because it&rsquo;s UTF-16 encoded.</p><p>The Windows API also provides functions for converting between string types:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// convert from a Code Page to UTF-16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>MultiByteToWideChar</span>(UINT CodePage, dwFlags, LPCCH lpMultiByteStr, <span style=color:#66d9ef>int</span> cbMultiByte, LPWSTR lpWideCharStr, <span style=color:#66d9ef>int</span> cchWideChar);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// convert from UTF-16 to a Code Page
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>WideCharToMultiByte</span>(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, <span style=color:#66d9ef>int</span> cchWideChar, LPSTR lpMultiByteStr, <span style=color:#66d9ef>int</span> cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
</span></span></code></pre></div><p>With the first function we can convert our Shift-JIS encoded string into UTF-16 and correctly display it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> bufferSize <span style=color:#f92672>=</span> MultiByteToWideChar(<span style=color:#ae81ff>932</span>, MB_ERR_INVALID_CHARS, helloShiftJis, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>nullptr</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> converted <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>wchar_t</span>[bufferSize];
</span></span><span style=display:flex><span>  MultiByteToWideChar(<span style=color:#ae81ff>932</span>, MB_ERR_INVALID_CHARS, helloShiftJis, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, converted, bufferSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  MessageBoxW(<span style=color:#66d9ef>nullptr</span>, converted, <span style=color:#66d9ef>nullptr</span>, MB_OK);
</span></span></code></pre></div><h3 id=current-issues>Current Issues<a href=#current-issues class=hanchor arialabel=Anchor>&#8983;</a></h3><p>We have looked at the history of character encodings and some examples with the Windows API. Now it&rsquo;s time to take a look some of the issues we still have.</p><p>The Web is united under UTF-8 with over 98% of all web pages using it<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. This is further enforced by standards like JSON which require UTF-8 encoding. As good as this is, the desktops are still far behind UTF-8 adoption.</p><p>Windows started supporting UTF-8 with Windows XP but only since Windows 10 version 1903 is it the default character encoding for Notepad<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. These editors are the main culprits as they often default to the current Windows Code Page which makes sharing files internationally a pain.</p><p>Thankfully everything is starting to or already using UTF-8, most newer languages like Go and Rust basically force you to use UTF-8 and even Microsoft said you should start using it<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><p>Windows Code Pages are legacy but because it&rsquo;s still used in production we continue to have issues with character encoding. If you have some issues I recommend trying <a href=https://github.com/xupefei/Locale-Emulator>Locale Emulator</a>.</p><h2 id=closing-words>Closing Words<a href=#closing-words class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Props to you if you read this entire thing. I personally had to deal a lot with encoding issues as a lot of games I play come from Japan and don&rsquo;t work on my machine without a locale emulator.</p><p>I hope this answered some questions you might had around this topic. It is very complex and has a very long history but this should give you a peak into the issues we still have.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://web.archive.org/web/20181208141313/https://msdn.microsoft.com/en-us/goglobal/bb964658.aspx#a>https://web.archive.org/web/20181208141313/https://msdn.microsoft.com/en-us/goglobal/bb964658.aspx#a</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://w3techs.com/technologies/cross/character_encoding/ranking>https://w3techs.com/technologies/cross/character_encoding/ranking</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://www.winhelponline.com/blog/set-default-encoding-notepad-ansi-utf-8/>https://www.winhelponline.com/blog/set-default-encoding-notepad-ansi-utf-8/</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://docs.microsoft.com/en-us/windows/apps/design/globalizing/use-utf8-code-page>https://docs.microsoft.com/en-us/windows/apps/design/globalizing/use-utf8-code-page</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div></article><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://erri120.github.io/posts/2022-05-05/><span class=button__icon>←</span>
<span class=button__text>Getting started with GNU gettext for C++</span></a></span>
<span class="button next"><a href=https://erri120.github.io/posts/2021-12-10/><span class=button__text>Fixing Anno 2070 by changing three bytes</span>
<span class=button__icon>→</span></a></span></div></div><hr><div style=margin-top:16px;margin-bottom:8px;display:flex;justify-content:center><script type=text/javascript src=https://storage.ko-fi.com/cdn/widget/Widget_2.js></script><script type=text/javascript>kofiwidget2.init("Support Me on Ko-fi","#29abe0","P5P03UIPI"),kofiwidget2.draw()</script></div><script src=https://utteranc.es/client.js repo=erri120/erri120.github.io issue-term=pathname label=site-comment theme=github-dark-orange crossorigin=anonymous async></script></main></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>CC BY 4.0</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a> and modified by me</span></div></div></footer><script src=https://erri120.github.io/assets/main.js></script>
<script src=https://erri120.github.io/assets/prism.js></script></div></body></html>
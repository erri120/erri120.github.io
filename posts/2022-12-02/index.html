<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of Code 2022: Day 2 | erri120's random Blog</title><meta name=keywords content="Advent of Code 2022,C#"><meta name=description content="Day 2: Rock Paper Scissors"><meta name=author content="erri120"><link rel=canonical href=https://erri120.github.io/posts/2022-12-02/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://erri120.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://erri120.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://erri120.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://erri120.github.io/apple-touch-icon.png><link rel=mask-icon href=https://erri120.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta name=google-site-verification content="c-L5KbBKeVyZ9YNKiotqlpl7zsiDRiGcWJa4ZxVpzAo"><meta name=msvalidate.01 content="0E353603CBFC6B4F85D605C4E9F27290"><script data-goatcounter=https://erri120.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet href=/syntax.css><meta property="og:title" content="Advent of Code 2022: Day 2"><meta property="og:description" content="Day 2: Rock Paper Scissors"><meta property="og:type" content="article"><meta property="og:url" content="https://erri120.github.io/posts/2022-12-02/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-02T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-02T14:15:02+01:00"><meta property="og:site_name" content="erri120's random Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code 2022: Day 2"><meta name=twitter:description content="Day 2: Rock Paper Scissors"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://erri120.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Advent of Code 2022: Day 2","item":"https://erri120.github.io/posts/2022-12-02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of Code 2022: Day 2","name":"Advent of Code 2022: Day 2","description":"Day 2: Rock Paper Scissors","keywords":["Advent of Code 2022","C#"],"articleBody":"Day 2 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 2: Rock Paper Scissors Links: Puzzle Page, My Code\nPart One Description The Elves begin to set up camp on the beach. To decide whose tent gets to be closest to the snack storage, a giant Rock Paper Scissors tournament is already in progress.\nRock Paper Scissors is a game between two players. Each game contains many rounds; in each round, the players each simultaneously choose one of Rock, Paper, or Scissors using a hand shape. Then, a winner for that round is selected: Rock defeats Scissors, Scissors defeats Paper, and Paper defeats Rock. If both players choose the same shape, the round instead ends in a draw.\nAppreciative of your help yesterday, one Elf gives you an encrypted strategy guide (your puzzle input) that they say will be sure to help you win. “The first column is what your opponent is going to play: A for Rock, B for Paper, and C for Scissors. The second column–” Suddenly, the Elf is called away to help with someone’s tent.\nThe second column, you reason, must be what you should play in response: X for Rock, Y for Paper, and Z for Scissors. Winning every time would be suspicious, so the responses must have been carefully chosen.\nThe winner of the whole tournament is the player with the highest score. Your total score is the sum of your scores for each round. The score for a single round is the score for the shape you selected (1 for Rock, 2 for Paper, and 3 for Scissors) plus the score for the outcome of the round (0 if you lost, 3 if the round was a draw, and 6 if you won).\nSince you can’t be sure if the Elf is trying to help you or trick you, you should calculate the score you would get if you were to follow the strategy guide.\nFor example, suppose you were given the following strategy guide:\n1 2 3 A Y B X C Z This strategy guide predicts and recommends the following:\nIn the first round, your opponent will choose Rock (A), and you should choose Paper (Y). This ends in a win for you with a score of 8 (2 because you chose Paper + 6 because you won). In the second round, your opponent will choose Paper (B), and you should choose Rock (X). This ends in a loss for you with a score of 1 (1 + 0). The third round is a draw with both players choosing Scissors, giving you a score of 3 + 3 = 6. In this example, if you were to follow the strategy guide, you would get a total score of 15 (8 + 1 + 6).\nWhat would your total score be if everything goes exactly according to your strategy guide?\nIt’s time for everyone’s favorite game “Rock paper scissors”/“Schere, Stein, Papier”/“Pierre-papier-ciseaux”/“Piedra, papel o tijera”/“じゃんけん”/“石头、剪子、布.”\nOur first objective is using the strategy guide we get from an elf to play in the tournament. The guide contains two columns:\nwhat the opponent plays what we should play For this puzzle we need to calculate the total score if we followed the guide.\nLet’s start with the basics and define some Enums:\n1 2 3 4 5 6 7 8 9 10 11 12 13 public enum RoundOutcome { Lost = 0, Draw = 3, Won = 6 } public enum Shape { Rock = 1, Paper = 2, Scissors = 3 } An enumeration type in C# is just a set of named constants that map to an underlying integer value. Normally the compiler will just auto-generate the value but in our case we want to explicitly specify it. For the RoundOutcome I’m using points we get when the round is lost, a draw or won and for Shape it’s the points we get for playing this shape.\nNext we need a function that calculates the round outcome given the opponent input and our input:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private static RoundOutcome CalculateRoundOutcome(char opponentInput, char playerInput) { var opponentShape = opponentInput switch { 'A' =\u003e Shape.Rock, 'B' =\u003e Shape.Paper, 'C' =\u003e Shape.Scissors, _ =\u003e throw new UnreachableException() }; var playerShape = playerInput switch { 'X' =\u003e Shape.Rock, 'Y' =\u003e Shape.Paper, 'Z' =\u003e Shape.Scissors, _ =\u003e throw new UnreachableException() }; //... } Let’s start by mapping the raw input we read from the file to our Shape enum. Notice the UnreachableException at the end of the switch statement? This is a new exception in .NET 7 that is thrown when the program executes an instruction that was thought to be unreachable. In our case we have pre-defined inputs and anything else should not match.\nNext we just need to add the rules of the game:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (opponentShape == playerShape) return RoundOutcome.Draw; return (opponentShape, playerShape) switch { (Shape.Rock, Shape.Paper) =\u003e RoundOutcome.Won, (Shape.Rock, Shape.Scissors) =\u003e RoundOutcome.Lost, (Shape.Paper, Shape.Rock) =\u003e RoundOutcome.Lost, (Shape.Paper, Shape.Scissors) =\u003e RoundOutcome.Won, (Shape.Scissors, Shape.Rock) =\u003e RoundOutcome.Won, (Shape.Scissors, Shape.Paper) =\u003e RoundOutcome.Lost, _ =\u003e throw new UnreachableException() }; These are just the basic rules of the game: Rock beats Scissors, Scissors beat Paper, Paper beats Rock. If the players have the same shape it’s a draw. The only cool thing about this code is the utilization of Pattern matching and the new switch expressions we got in C# 8.\nWith the rules in place we just need to calculate the final round score:\n1 2 3 4 5 private static int RoundScore(RoundOutcome outcome, Shape playedShape) { var shapePoints = (int)playedShape; return shapePoints + (int)outcome; } Our enumeration types are just named integers, and we can freely convert between them. The only thing left to do is read the file and get the total score:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static async Task Main() { var totalScore = (await File.ReadAllLinesAsync(\"input.txt\", Encoding.UTF8)) .Where(line =\u003e !string.IsNullOrWhiteSpace(line)) .Select(line =\u003e { var opponentInput = line[0]; var playerInput = line[2]; var outcome = CalculateRoundOutcome(opponentInput, playerInput); return RoundScore(outcome, playerShape); }) .Sum(); Console.WriteLine($\"Total Score: {totalScore}\"); } This solution is okay. With puzzles like these it’s always good to implement a naive solution first in order to understand the problem and figure out the correct value. What I don’t like about the code is the massive switch expression where the match the opponent shape and the player shape to figure out the round outcome. So here is a more interesting approach using math:\n1 2 3 4 5 6 7 8 var opponentValue = (int)opponentShape; var playerValue = (int)playerShape; if (opponentValue == playerValue) return RoundOutcome.Draw; return (opponentValue == 3 ? 1 : opponentValue + 1) == playerValue ? RoundOutcome.Won : RoundOutcome.Lost; First we cast the shape enumeration value to an integer (1 for Rock, 2 for Paper, 3 for Scissors). A draw is the easiest case to check for since it’s just the same input, but how do know if someone won or lost with just numbers? Let’s write out every situation and look at the results:\n1 2 3 4 5 6 7 8 9 10 11 1 1 -\u003e draw 2 2 -\u003e draw 3 3 -\u003e draw 1 2 -\u003e won 2 3 -\u003e won 3 1 -\u003e won 1 3 -\u003e lost 2 1 -\u003e lost 3 2 -\u003e lost There is a pattern for the values that win us the game: if the opponent’s value offset by 1 and wrapped around to 1 is equal to the player’s value, we win. You could probably get fancier and use modulo for wrapping around, but I just choose a simple comparison.\nPart Two Description The Elf finishes helping with the tent and sneaks back over to you. “Anyway, the second column says how the round needs to end: X means you need to lose, Y means you need to end the round in a draw, and Z means you need to win. Good luck!”\nThe total score is still calculated in the same way, but now you need to figure out what shape to choose so the round ends as indicated. The example above now goes like this:\nIn the first round, your opponent will choose Rock (A), and you need the round to end in a draw (Y), so you also choose Rock. This gives you a score of 1 + 3 = 4. In the second round, your opponent will choose Paper (B), and you choose Rock so you lose (X) with a score of 1 + 0 = 1. In the third round, you will defeat your opponent’s Scissors with Rock for a score of 1 + 6 = 7. Now that you’re correctly decrypting the ultra top secret strategy guide, you would get a total score of 12.\nFollowing the Elf’s instructions for the second column, what would your total score be if everything goes exactly according to your strategy guide?\nIn Part Two it turns out we misinterpreted the guide and instead of the second column giving us shape to play, it’s the outcome we want. Using our newly gained knowledge from the previous part about numbers, we can easily calculate which shape we need to play to get the desired outcome:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private static int PartTwoScore(char opponent, char predictedOutcome) { var opponentShape = OpponentShape(opponent); var opponentValue = (int)opponentShape; var outcome = predictedOutcome switch { 'X' =\u003e RoundOutcome.Lost, 'Y' =\u003e RoundOutcome.Draw, 'Z' =\u003e RoundOutcome.Won, _ =\u003e throw new UnreachableException() }; var playerValue = outcome switch { RoundOutcome.Lost =\u003e opponentValue == 1 ? 3 : opponentValue - 1, RoundOutcome.Won =\u003e opponentValue == 3 ? 1 : opponentValue + 1, RoundOutcome.Draw =\u003e (int)opponentShape, _ =\u003e throw new UnreachableException() }; var playerShape = (Shape)playerValue; return RoundScore(outcome, playerShape); } We know the opponent’s shape and the round outcome we want. The only thing we need is the player shape which we can get by using the pattern we discovered in part one. The only thing remaining is to update our main function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static async Task Main() { var scores = (await File.ReadAllLinesAsync(\"input.txt\", Encoding.UTF8)) .Where(line =\u003e !string.IsNullOrWhiteSpace(line)) .Select(line =\u003e { var a = line[0]; var b = line[2]; var partOne = PartOneScore(a, b); var partTwo = PartTwoScore(a, b); return (partOne, partTwo); }) .ToArray(); var partOneTotalScore = scores.Select(x =\u003e x.partOne).Sum(); var partTwoTotalScore = scores.Select(x =\u003e x.partTwo).Sum(); Console.WriteLine($\"Part One - Total Score: {partOneTotalScore}\"); Console.WriteLine($\"Part Two - Total Score: {partTwoTotalScore}\"); } Conclusion This puzzle is very interesting. You can go for the speedrun strategy and use pattern matching to quickly solve this puzzle or take more time to think and realize you can just use numbers. The previous puzzles will likely look similar in every implementation but here you can experiment more and come up with some crazy ideas. It will be interesting to see how the Brainfuck implementation will look like.\nhttps://www.reddit.com/r/adventofcode/comments/zahemk/2022_day_2_data_structures_good_control_flow_bad\n","wordCount":"1889","inLanguage":"en","datePublished":"2022-12-02T00:00:00Z","dateModified":"2022-12-02T14:15:02+01:00","author":{"@type":"Person","name":"erri120"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://erri120.github.io/posts/2022-12-02/"},"publisher":{"@type":"Organization","name":"erri120's random Blog","logo":{"@type":"ImageObject","url":"https://erri120.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://erri120.github.io accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://erri120.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://erri120.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://erri120.github.io/archives/ title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://erri120.github.io>Home</a>&nbsp;»&nbsp;<a href=https://erri120.github.io/posts/>Posts</a></div><h1 class=post-title>Advent of Code 2022: Day 2</h1><div class=post-meta><span title='2022-12-02 00:00:00 +0000 UTC'>2022-12-02</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1889 words&nbsp;·&nbsp;erri120&nbsp;|&nbsp;<a href=https://github.com/erri120/erri120.github.io/edit/master/content/posts/2022-12-02.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#part-one>Part One</a></li><li><a href=#part-two>Part Two</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>Day 2 of the <a href=https://adventofcode.com>Advent of Code</a>. If you have no idea what this is, check my <a href=https://erri120.github.io/posts/2022-12-01/>post of the first day</a>.</p><h1 id=day-2-rock-paper-scissors>Day 2: Rock Paper Scissors<a hidden class=anchor aria-hidden=true href=#day-2-rock-paper-scissors>#</a></h1><p>Links: <a href=https://adventofcode.com/2022/day/2>Puzzle Page</a>, <a href=https://github.com/erri120/advent-of-code-2022/tree/master/day-2>My Code</a></p><h2 id=part-one>Part One<a hidden class=anchor aria-hidden=true href=#part-one>#</a></h2><details><summary>Description</summary><p>The Elves begin to set up camp on the beach. To decide whose tent gets to be closest to the snack storage, a giant <a href=https://en.wikipedia.org/wiki/Rock_paper_scissors>Rock Paper Scissors</a> tournament is already in progress.</p><p>Rock Paper Scissors is a game between two players. Each game contains many rounds; in each round, the players each simultaneously choose one of Rock, Paper, or Scissors using a hand shape. Then, a winner for that round is selected: Rock defeats Scissors, Scissors defeats Paper, and Paper defeats Rock. If both players choose the same shape, the round instead ends in a draw.</p><p>Appreciative of your help yesterday, one Elf gives you an <strong>encrypted strategy guide</strong> (your puzzle input) that they say will be sure to help you win. &ldquo;The first column is what your opponent is going to play: <code>A</code> for Rock, <code>B</code> for Paper, and <code>C</code> for Scissors. The second column&ndash;&rdquo; Suddenly, the Elf is called away to help with someone&rsquo;s tent.</p><p>The second column, you reason, must be what you should play in response: <code>X</code> for Rock, <code>Y</code> for Paper, and <code>Z</code> for Scissors. Winning every time would be suspicious, so the responses must have been carefully chosen.</p><p>The winner of the whole tournament is the player with the highest score. Your <strong>total score</strong> is the sum of your scores for each round. The score for a single round is the score for the <strong>shape you selected</strong> (<code>1</code> for Rock, <code>2</code> for Paper, and <code>3</code> for Scissors) plus the score for the <strong>outcome of the round</strong> (<code>0</code> if you lost, <code>3</code> if the round was a draw, and <code>6</code> if you won).</p><p>Since you can&rsquo;t be sure if the Elf is trying to help you or trick you, you should calculate the score you would get if you were to follow the strategy guide.</p><p>For example, suppose you were given the following strategy guide:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>A Y
</span></span><span class=line><span class=cl>B X
</span></span><span class=line><span class=cl>C Z
</span></span></code></pre></td></tr></table></div></div><p>This strategy guide predicts and recommends the following:</p><ul><li>In the first round, your opponent will choose Rock (<code>A</code>), and you should choose Paper (<code>Y</code>). This ends in a win for you with a score of <strong><code>8</code></strong> (<code>2</code> because you chose Paper + <code>6</code> because you won).</li><li>In the second round, your opponent will choose Paper (<code>B</code>), and you should choose Rock (<code>X</code>). This ends in a loss for you with a score of <strong><code>1</code></strong> (<code>1</code> + <code>0</code>).</li><li>The third round is a draw with both players choosing Scissors, giving you a score of <code>3</code> + <code>3</code> = <strong><code>6</code></strong>.</li></ul><p>In this example, if you were to follow the strategy guide, you would get a total score of <strong><code>15</code></strong> (<code>8</code> + <code>1</code> + <code>6</code>).</p><p><strong>What would your total score be if everything goes exactly according to your strategy guide?</strong></p></details><p>It&rsquo;s time for everyone&rsquo;s favorite game &ldquo;Rock paper scissors&rdquo;/&ldquo;Schere, Stein, Papier&rdquo;/&ldquo;Pierre-papier-ciseaux&rdquo;/&ldquo;Piedra, papel o tijera&rdquo;/&ldquo;じゃんけん&rdquo;/&ldquo;石头、剪子、布.&rdquo;</p><p>Our first objective is using the strategy guide we get from an elf to play in the tournament. The guide contains two columns:</p><ol><li>what the opponent plays</li><li>what we should play</li></ol><p>For this puzzle we need to calculate the total score if we followed the guide.</p><p>Let&rsquo;s start with the basics and define some <a href=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum>Enums</a>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>enum</span> <span class=n>RoundOutcome</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Lost</span> <span class=p>=</span> <span class=m>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Draw</span> <span class=p>=</span> <span class=m>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Won</span> <span class=p>=</span> <span class=m>6</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>enum</span> <span class=n>Shape</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Rock</span> <span class=p>=</span> <span class=m>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Paper</span> <span class=p>=</span> <span class=m>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Scissors</span> <span class=p>=</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>An enumeration type in C# is just a set of named constants that map to an underlying integer value. Normally the compiler will just auto-generate the value but in our case we want to explicitly specify it. For the <code>RoundOutcome</code> I&rsquo;m using points we get when the round is lost, a draw or won and for <code>Shape</code> it&rsquo;s the points we get for playing this shape.</p><p>Next we need a function that calculates the round outcome given the opponent input and our input:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=n>RoundOutcome</span> <span class=n>CalculateRoundOutcome</span><span class=p>(</span><span class=kt>char</span> <span class=n>opponentInput</span><span class=p>,</span> <span class=kt>char</span> <span class=n>playerInput</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>opponentShape</span> <span class=p>=</span> <span class=n>opponentInput</span> <span class=k>switch</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=sc>&#39;A&#39;</span> <span class=p>=&gt;</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Rock</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=sc>&#39;B&#39;</span> <span class=p>=&gt;</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Paper</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=sc>&#39;C&#39;</span> <span class=p>=&gt;</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Scissors</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>_</span> <span class=p>=&gt;</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>UnreachableException</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>playerShape</span> <span class=p>=</span> <span class=n>playerInput</span> <span class=k>switch</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=sc>&#39;X&#39;</span> <span class=p>=&gt;</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Rock</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=sc>&#39;Y&#39;</span> <span class=p>=&gt;</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Paper</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=sc>&#39;Z&#39;</span> <span class=p>=&gt;</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Scissors</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>_</span> <span class=p>=&gt;</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>UnreachableException</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Let&rsquo;s start by mapping the raw input we read from the file to our <code>Shape</code> enum. Notice the <a href=https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.unreachableexception><code>UnreachableException</code></a> at the end of the switch statement? This is a new exception in .NET 7 that is thrown when the program executes an instruction that was thought to be unreachable. In our case we have pre-defined inputs and anything else <em>should not</em> match.</p><p>Next we just need to add the rules of the game:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>opponentShape</span> <span class=p>==</span> <span class=n>playerShape</span><span class=p>)</span> <span class=k>return</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Draw</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=p>(</span><span class=n>opponentShape</span><span class=p>,</span> <span class=n>playerShape</span><span class=p>)</span> <span class=k>switch</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>Shape</span><span class=p>.</span><span class=n>Rock</span><span class=p>,</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Paper</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Won</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>Shape</span><span class=p>.</span><span class=n>Rock</span><span class=p>,</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Scissors</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Lost</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>Shape</span><span class=p>.</span><span class=n>Paper</span><span class=p>,</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Rock</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Lost</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>Shape</span><span class=p>.</span><span class=n>Paper</span><span class=p>,</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Scissors</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Won</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>Shape</span><span class=p>.</span><span class=n>Scissors</span><span class=p>,</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Rock</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Won</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>Shape</span><span class=p>.</span><span class=n>Scissors</span><span class=p>,</span> <span class=n>Shape</span><span class=p>.</span><span class=n>Paper</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Lost</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>_</span> <span class=p>=&gt;</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>UnreachableException</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>These are just the basic rules of the game: Rock beats Scissors, Scissors beat Paper, Paper beats Rock. If the players have the same shape it&rsquo;s a draw. The only cool thing about this code is the utilization of <a href=https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/patterns>Pattern matching</a> and the new <a href=https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression>switch expressions</a> we got in C# 8.</p><p>With the rules in place we just need to calculate the final round score:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>RoundScore</span><span class=p>(</span><span class=n>RoundOutcome</span> <span class=n>outcome</span><span class=p>,</span> <span class=n>Shape</span> <span class=n>playedShape</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>shapePoints</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>playedShape</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>shapePoints</span> <span class=p>+</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>outcome</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Our enumeration types are just named integers, and we can freely convert between them. The only thing left to do is read the file and get the total score:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>async</span> <span class=n>Task</span> <span class=n>Main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>totalScore</span> <span class=p>=</span> <span class=p>(</span><span class=k>await</span> <span class=n>File</span><span class=p>.</span><span class=n>ReadAllLinesAsync</span><span class=p>(</span><span class=s>&#34;input.txt&#34;</span><span class=p>,</span> <span class=n>Encoding</span><span class=p>.</span><span class=n>UTF8</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Where</span><span class=p>(</span><span class=n>line</span> <span class=p>=&gt;</span> <span class=p>!</span><span class=kt>string</span><span class=p>.</span><span class=n>IsNullOrWhiteSpace</span><span class=p>(</span><span class=n>line</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Select</span><span class=p>(</span><span class=n>line</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>opponentInput</span> <span class=p>=</span> <span class=n>line</span><span class=p>[</span><span class=m>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>playerInput</span> <span class=p>=</span> <span class=n>line</span><span class=p>[</span><span class=m>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>outcome</span> <span class=p>=</span> <span class=n>CalculateRoundOutcome</span><span class=p>(</span><span class=n>opponentInput</span><span class=p>,</span> <span class=n>playerInput</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>RoundScore</span><span class=p>(</span><span class=n>outcome</span><span class=p>,</span> <span class=n>playerShape</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Sum</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Total Score: {totalScore}&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This solution is <em>okay</em>. With puzzles like these it&rsquo;s always good to implement a <em>naive</em> solution first in order to understand the problem and figure out the correct value. What I don&rsquo;t like about the code is the massive switch expression where the match the opponent shape and the player shape to figure out the round outcome. So here is a more interesting approach using <em>math</em>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>var</span> <span class=n>opponentValue</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>opponentShape</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>playerValue</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>playerShape</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>opponentValue</span> <span class=p>==</span> <span class=n>playerValue</span><span class=p>)</span> <span class=k>return</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Draw</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=p>(</span><span class=n>opponentValue</span> <span class=p>==</span> <span class=m>3</span> <span class=p>?</span> <span class=m>1</span> <span class=p>:</span> <span class=n>opponentValue</span> <span class=p>+</span> <span class=m>1</span><span class=p>)</span> <span class=p>==</span> <span class=n>playerValue</span>
</span></span><span class=line><span class=cl>    <span class=p>?</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Won</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Lost</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>First we cast the shape enumeration value to an integer (<code>1</code> for Rock, <code>2</code> for Paper, <code>3</code> for Scissors). A draw is the easiest case to check for since it&rsquo;s just the same input, but how do know if someone won or lost with just numbers? Let&rsquo;s write out every situation and look at the results:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>1 1 -&gt; draw
</span></span><span class=line><span class=cl>2 2 -&gt; draw
</span></span><span class=line><span class=cl>3 3 -&gt; draw
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1 2 -&gt; won
</span></span><span class=line><span class=cl>2 3 -&gt; won
</span></span><span class=line><span class=cl>3 1 -&gt; won
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1 3 -&gt; lost
</span></span><span class=line><span class=cl>2 1 -&gt; lost
</span></span><span class=line><span class=cl>3 2 -&gt; lost
</span></span></code></pre></td></tr></table></div></div><p>There is a pattern for the values that win us the game: if the opponent&rsquo;s value offset by <code>1</code> and wrapped around to <code>1</code> is equal to the player&rsquo;s value, we win. You could probably get fancier and use modulo for wrapping around, but I just choose a simple comparison.</p><h2 id=part-two>Part Two<a hidden class=anchor aria-hidden=true href=#part-two>#</a></h2><details><summary>Description</summary><p>The Elf finishes helping with the tent and sneaks back over to you. &ldquo;Anyway, the second column says how the round needs to end: <code>X</code> means you need to lose, <code>Y</code> means you need to end the round in a draw, and <code>Z</code> means you need to win. Good luck!&rdquo;</p><p>The total score is still calculated in the same way, but now you need to figure out what shape to choose so the round ends as indicated. The example above now goes like this:</p><ul><li>In the first round, your opponent will choose Rock (<code>A</code>), and you need the round to end in a draw (<code>Y</code>), so you also choose Rock. This gives you a score of <code>1</code> + <code>3</code> = <strong><code>4</code></strong>.</li><li>In the second round, your opponent will choose Paper (<code>B</code>), and you choose Rock so you lose (<code>X</code>) with a score of <code>1</code> + <code>0</code> = <strong><code>1</code></strong>.</li><li>In the third round, you will defeat your opponent&rsquo;s Scissors with Rock for a score of <code>1</code> + <code>6</code> = <strong><code>7</code></strong>.</li></ul><p>Now that you&rsquo;re correctly decrypting the ultra top secret strategy guide, you would get a total score of <strong><code>12</code></strong>.</p><p>Following the Elf&rsquo;s instructions for the second column, <strong>what would your total score be if everything goes exactly according to your strategy guide?</strong></p></details><p>In Part Two it turns out we misinterpreted the guide and instead of the second column giving us shape to play, it&rsquo;s the outcome we want. Using our newly gained knowledge from the previous part about numbers, we can easily calculate which shape we need to play to get the desired outcome:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>PartTwoScore</span><span class=p>(</span><span class=kt>char</span> <span class=n>opponent</span><span class=p>,</span> <span class=kt>char</span> <span class=n>predictedOutcome</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>opponentShape</span> <span class=p>=</span> <span class=n>OpponentShape</span><span class=p>(</span><span class=n>opponent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>opponentValue</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>opponentShape</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>outcome</span> <span class=p>=</span> <span class=n>predictedOutcome</span> <span class=k>switch</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=sc>&#39;X&#39;</span> <span class=p>=&gt;</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Lost</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=sc>&#39;Y&#39;</span> <span class=p>=&gt;</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Draw</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=sc>&#39;Z&#39;</span> <span class=p>=&gt;</span> <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Won</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>_</span> <span class=p>=&gt;</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>UnreachableException</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>playerValue</span> <span class=p>=</span> <span class=n>outcome</span> <span class=k>switch</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Lost</span> <span class=p>=&gt;</span> <span class=n>opponentValue</span> <span class=p>==</span> <span class=m>1</span> <span class=p>?</span> <span class=m>3</span> <span class=p>:</span> <span class=n>opponentValue</span> <span class=p>-</span> <span class=m>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Won</span> <span class=p>=&gt;</span> <span class=n>opponentValue</span> <span class=p>==</span> <span class=m>3</span> <span class=p>?</span> <span class=m>1</span> <span class=p>:</span> <span class=n>opponentValue</span> <span class=p>+</span> <span class=m>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>RoundOutcome</span><span class=p>.</span><span class=n>Draw</span> <span class=p>=&gt;</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>opponentShape</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>_</span> <span class=p>=&gt;</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>UnreachableException</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>playerShape</span> <span class=p>=</span> <span class=p>(</span><span class=n>Shape</span><span class=p>)</span><span class=n>playerValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>RoundScore</span><span class=p>(</span><span class=n>outcome</span><span class=p>,</span> <span class=n>playerShape</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>We know the opponent&rsquo;s shape and the round outcome we want. The only thing we need is the player shape which we can get by using the pattern we discovered in part one. The only thing remaining is to update our main function:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>async</span> <span class=n>Task</span> <span class=n>Main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>scores</span> <span class=p>=</span> <span class=p>(</span><span class=k>await</span> <span class=n>File</span><span class=p>.</span><span class=n>ReadAllLinesAsync</span><span class=p>(</span><span class=s>&#34;input.txt&#34;</span><span class=p>,</span> <span class=n>Encoding</span><span class=p>.</span><span class=n>UTF8</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Where</span><span class=p>(</span><span class=n>line</span> <span class=p>=&gt;</span> <span class=p>!</span><span class=kt>string</span><span class=p>.</span><span class=n>IsNullOrWhiteSpace</span><span class=p>(</span><span class=n>line</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Select</span><span class=p>(</span><span class=n>line</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>a</span> <span class=p>=</span> <span class=n>line</span><span class=p>[</span><span class=m>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>b</span> <span class=p>=</span> <span class=n>line</span><span class=p>[</span><span class=m>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>partOne</span> <span class=p>=</span> <span class=n>PartOneScore</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>partTwo</span> <span class=p>=</span> <span class=n>PartTwoScore</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>partOne</span><span class=p>,</span> <span class=n>partTwo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>ToArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>partOneTotalScore</span> <span class=p>=</span> <span class=n>scores</span><span class=p>.</span><span class=n>Select</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>x</span><span class=p>.</span><span class=n>partOne</span><span class=p>).</span><span class=n>Sum</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>partTwoTotalScore</span> <span class=p>=</span> <span class=n>scores</span><span class=p>.</span><span class=n>Select</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>x</span><span class=p>.</span><span class=n>partTwo</span><span class=p>).</span><span class=n>Sum</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Part One - Total Score: {partOneTotalScore}&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Part Two - Total Score: {partTwoTotalScore}&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This puzzle is very interesting. You can go for the speedrun strategy and use pattern matching to quickly solve this puzzle or take more time to think and realize you can just use numbers. The previous puzzles will likely look similar in every implementation but here you can experiment more and come up with some crazy ideas. It will be interesting to see how the <a href=https://en.wikipedia.org/wiki/Brainfuck>Brainfuck</a> implementation will look like.</p><figure class=align-center><img loading=lazy src=https://i.redd.it/exey890xhg3a1.png#center alt="Data structures good control flow bad"><figcaption><p><a href=https://www.reddit.com/r/adventofcode/comments/zahemk/2022_day_2_data_structures_good_control_flow_bad>https://www.reddit.com/r/adventofcode/comments/zahemk/2022_day_2_data_structures_good_control_flow_bad</a></p></figcaption></figure></div><footer class=post-footer><ul class=post-tags><li><a href=https://erri120.github.io/tags/advent-of-code-2022/>Advent of Code 2022</a></li><li><a href=https://erri120.github.io/tags/c#/>C#</a></li></ul><nav class=paginav><a class=next href=https://erri120.github.io/posts/2022-12-01/><span class=title>Next »</span><br><span>Advent of Code 2022: Day 1</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2022: Day 2 on twitter" href="https://twitter.com/intent/tweet/?text=Advent%20of%20Code%202022%3a%20Day%202&url=https%3a%2f%2ferri120.github.io%2fposts%2f2022-12-02%2f&hashtags=AdventofCode2022%2cC%23"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2022: Day 2 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ferri120.github.io%2fposts%2f2022-12-02%2f&title=Advent%20of%20Code%202022%3a%20Day%202"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=erri120/erri120.github.io issue-term=pathname label=site-comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://erri120.github.io>erri120's random Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
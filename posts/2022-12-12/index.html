<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of Code 2022: Day 12 | erri120's random Blog</title><meta name=keywords content="Advent of Code 2022,C#"><meta name=description content="Day 12: Hill Climbing Algorithm"><meta name=author content="erri120"><link rel=canonical href=https://erri120.github.io/posts/2022-12-12/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://erri120.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://erri120.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://erri120.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://erri120.github.io/apple-touch-icon.png><link rel=mask-icon href=https://erri120.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta name=google-site-verification content="c-L5KbBKeVyZ9YNKiotqlpl7zsiDRiGcWJa4ZxVpzAo"><meta name=msvalidate.01 content="0E353603CBFC6B4F85D605C4E9F27290"><script data-goatcounter=https://erri120.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet href=/syntax.css><meta property="og:title" content="Advent of Code 2022: Day 12"><meta property="og:description" content="Day 12: Hill Climbing Algorithm"><meta property="og:type" content="article"><meta property="og:url" content="https://erri120.github.io/posts/2022-12-12/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-12T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-12T11:59:50+01:00"><meta property="og:site_name" content="erri120's random Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code 2022: Day 12"><meta name=twitter:description content="Day 12: Hill Climbing Algorithm"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://erri120.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Advent of Code 2022: Day 12","item":"https://erri120.github.io/posts/2022-12-12/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of Code 2022: Day 12","name":"Advent of Code 2022: Day 12","description":"Day 12: Hill Climbing Algorithm","keywords":["Advent of Code 2022","C#"],"articleBody":"Day 12 of the Advent of Code. If you have no idea what this is, check my post of the first day.\nDay 12: Hill Climbing Algorithm Links: Puzzle Page, My Code\nPart One Description You try contacting the Elves using your handheld device, but the river you’re following must be too low to get a decent signal.\nYou ask the device for a heightmap of the surrounding area (your puzzle input). The heightmap shows the local area from above broken into a grid; the elevation of each square of the grid is given by a single lowercase letter, where a is the lowest elevation, b is the next-lowest, and so on up to the highest elevation, z.\nAlso included on the heightmap are marks for your current position (S) and the location that should get the best signal (E). Your current position (S) has elevation a, and the location that should get the best signal (E) has elevation z.\nYou’d like to reach E, but to save energy, you should do it in as few steps as possible. During each step, you can move exactly one square up, down, left, or right. To avoid needing to get out your climbing gear, the elevation of the destination square can be at most one higher than the elevation of your current square; that is, if your current elevation is m, you could step to elevation n, but not to elevation o. (This also means that the elevation of the destination square can be much lower than the elevation of your current square.)\nFor example:\n1 2 3 4 5 Sabqponm abcryxxl accszExk acctuvwj abdefghi Here, you start in the top-left corner; your goal is near the middle. You could start by moving down or right, but eventually you’ll need to head toward the e at the bottom. From there, you can spiral around to the goal:\nv..v\u003c\u003c\u003c\u003c \u003ev.vv\u003c\u003c^ .\u003evv\u003eE^^ ..v\u003e\u003e\u003e^^ ..\u003e\u003e\u003e\u003e\u003e^ In the above diagram, the symbols indicate whether the path exits each square moving up (^), down (v), left (\u003c), or right (\u003e). The location that should get the best signal is still E, and . marks unvisited squares.\nThis path reaches the goal in 31 steps, the fewest possible.\nWhat is the fewest steps required to move from your current position to the location that should get the best signal?\nIt’s path finding time. Finding the shortest path is such a common coding puzzle I don’t really have to explain much. The only interesting thing is that you can’t move in any direction on the grid and can go to an elevation that is at most one higher than your current one.\nAs for the usual parsing, we can just convert char to int by casting:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private static int[][] CreateGrid(IEnumerable\u003cstring\u003e lines, out Point start, out Point end) { var startPoint = Point.Empty; var endPoint = Point.Empty; var grid = lines.Select((line, y) =\u003e { return line.Select((c, x) =\u003e { switch (c) { case 'S': startPoint = new Point(x, y); break; case 'E': endPoint = new Point(x, y); break; } return c switch { 'S' =\u003e 'a', 'E' =\u003e 'z', _ =\u003e (int)c }; }).ToArray(); }).ToArray(); start = startPoint; end = endPoint; return grid; } For moving, we can quickly create some small helper functions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private static bool GetLeft(Point current, out Point left) { left = current with { X = current.X - 1 }; return left.X \u003e= 0; } private static bool GetRight(IReadOnlyList\u003cint[]\u003e grid, Point current, out Point right) { right = current with { X = current.X + 1 }; return right.X \u003c grid[0].Length; } private static bool GetUp(Point current, out Point up) { up = current with { Y = current.Y - 1 }; return up.Y \u003e= 0; } private static bool GetDown(IReadOnlyCollection\u003cint[]\u003e grid, Point current, out Point down) { down = current with { Y = current.Y + 1 }; return down.Y \u003c grid.Count; } As for the actual path finding, we obviously have to go with Dijkstra. It’s the classic algorithm everyone learns in their data structures and algorithms class. Thankfully we don’t have to implement any additional data types because .NET already comes with a PriorityQueue:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private static int Dijkstra(int[][] grid, Point start, Point end, bool partOne) { var distances = new Dictionary\u003cPoint, int\u003e(); var queue = new PriorityQueue\u003cPoint, int\u003e(); queue.Enqueue(start, 0); while (queue.TryDequeue(out var current, out var currentDistance)) { if (distances.ContainsKey(current)) continue; distances[current] = currentDistance; var foundEnd = false; void CheckNeighbor(Point neighbor) { //... } if (GetLeft(current, out var left)) CheckNeighbor(left); if (GetRight(grid, current, out var right)) CheckNeighbor(right); if (GetUp(current, out var up)) CheckNeighbor(up); if (GetDown(grid, current, out var down)) CheckNeighbor(down); if (foundEnd) break; } return distances[end]; } The only interesting thing in this code is the use of the inline function CheckNeighbor:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void CheckNeighbor(Point neighbor) { var currentValue = grid[current.Y][current.X]; var neighborValue = grid[neighbor.Y][neighbor.X]; if (neighborValue - currentValue \u003e 1) return; var newDistance = currentDistance + 1; if (neighbor == end) { distances[end] = newDistance; foundEnd = true; return; } queue.Enqueue(neighbor, newDistance); } This is basically it. It’s just Dijkstra but without actually getting the path, we just need the amount of steps.\nPart Two Description As you walk up the hill, you suspect that the Elves will want to turn this into a hiking trail. The beginning isn’t very scenic, though; perhaps you can find a better starting point.\nTo maximize exercise while hiking, the trail should start as low as possible: elevation a. The goal is still the square marked E. However, the trail should still be direct, taking the fewest steps to reach its goal. So, you’ll need to find the shortest path from any square at elevation a to the square marked E.\nAgain consider the example from above:\nSabqponm abcryxxl accszExk acctuvwj abdefghi Now, there are six choices for starting position (five marked a, plus the square marked S that counts as being at elevation a). If you start at the bottom-left square, you can reach the goal most quickly:\n...v\u003c\u003c\u003c\u003c ...vv\u003c\u003c^ ...v\u003eE^^ .\u003ev\u003e\u003e\u003e^^ \u003e^\u003e\u003e\u003e\u003e\u003e^ This path reaches the goal in only 29 steps, the fewest possible.\nWhat is the fewest steps required to move starting from any square with elevation a to the location that should get the best signal?\nPart two looks more complex than it is. We want the shortest path from any square with at elevation a to the end point. You could brute force this by doing the same thing as before but with every square at elevation a, or we can just use the end point as the start point:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void CheckNeighbor(Point neighbor) { var currentValue = grid[current.Y][current.X]; var neighborValue = grid[neighbor.Y][neighbor.X]; switch (partOne) { case true when neighborValue - currentValue \u003e 1: case false when currentValue - neighborValue \u003e 1: return; } var newDistance = currentDistance + 1; if (partOne \u0026\u0026 neighbor == end || !partOne \u0026\u0026 neighborValue == 'a') { distances[end] = newDistance; foundEnd = true; return; } queue.Enqueue(neighbor, newDistance); } With this we don’t have to pass an end point. The end point is just any point with elevation a.\n1 2 3 4 5 var partOne = Dijkstra(grid, start, end, true); var partTwo = Dijkstra(grid, end, Point.Empty, false); Console.WriteLine($\"Part One - Steps needed: {partOne}\"); Console.WriteLine($\"Part Two - Steps needed: {partTwo}\"); Conclusion It’s a path finding puzzle, there was bound to be one, and now it happened. This puzzle only serves to remind you that Dijkstra is a thing, and you should use it. There is nothing hard about this and if you know the algorithm, you can do solve in your sleep.\nhttps://www.reddit.com/r/adventofcode/comments/zjqz5y/2022_day_12_is_my_input_invalid_or/\nhttps://www.reddit.com/r/adventofcode/comments/zjqjqb/2022_day_12_apparently_long_fall_boots_are/\nhttps://www.reddit.com/r/adventofcode/comments/zjpp38/2022_day_12_its_that_time_of_the_year_again/\n","wordCount":"1381","inLanguage":"en","datePublished":"2022-12-12T00:00:00Z","dateModified":"2022-12-12T11:59:50+01:00","author":{"@type":"Person","name":"erri120"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://erri120.github.io/posts/2022-12-12/"},"publisher":{"@type":"Organization","name":"erri120's random Blog","logo":{"@type":"ImageObject","url":"https://erri120.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://erri120.github.io accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://erri120.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://erri120.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://erri120.github.io/archives/ title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://erri120.github.io>Home</a>&nbsp;»&nbsp;<a href=https://erri120.github.io/posts/>Posts</a></div><h1 class=post-title>Advent of Code 2022: Day 12</h1><div class=post-meta><span title='2022-12-12 00:00:00 +0000 UTC'>2022-12-12</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1381 words&nbsp;·&nbsp;erri120&nbsp;|&nbsp;<a href=https://github.com/erri120/erri120.github.io/edit/master/content/posts/2022-12-12.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#part-one>Part One</a></li><li><a href=#part-two>Part Two</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>Day 12 of the <a href=https://adventofcode.com>Advent of Code</a>. If you have no idea what this is, check my <a href=https://erri120.github.io/posts/2022-12-01/>post of the first day</a>.</p><h1 id=day-12-hill-climbing-algorithm>Day 12: Hill Climbing Algorithm<a hidden class=anchor aria-hidden=true href=#day-12-hill-climbing-algorithm>#</a></h1><p>Links: <a href=https://adventofcode.com/2022/day/12>Puzzle Page</a>, <a href=https://github.com/erri120/advent-of-code-2022/tree/master/day-12>My Code</a></p><h2 id=part-one>Part One<a hidden class=anchor aria-hidden=true href=#part-one>#</a></h2><details><summary>Description</summary><p>You try contacting the Elves using your handheld device, but the river you&rsquo;re following must be too low to get a decent signal.</p><p>You ask the device for a heightmap of the surrounding area (your puzzle input). The heightmap shows the local area from above broken into a grid; the elevation of each square of the grid is given by a single lowercase letter, where <code>a</code> is the lowest elevation, <code>b</code> is the next-lowest, and so on up to the highest elevation, <code>z</code>.</p><p>Also included on the heightmap are marks for your current position (<code>S</code>) and the location that should get the best signal (<code>E</code>). Your current position (<code>S</code>) has elevation <code>a</code>, and the location that should get the best signal (<code>E</code>) has elevation <code>z</code>.</p><p>You&rsquo;d like to reach <code>E</code>, but to save energy, you should do it in <strong>as few steps as possible</strong>. During each step, you can move exactly one square up, down, left, or right. To avoid needing to get out your climbing gear, the elevation of the destination square can be <strong>at most one higher</strong> than the elevation of your current square; that is, if your current elevation is <code>m</code>, you could step to elevation <code>n</code>, but not to elevation <code>o</code>. (This also means that the elevation of the destination square can be much lower than the elevation of your current square.)</p><p>For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Sabqponm
</span></span><span class=line><span class=cl>abcryxxl
</span></span><span class=line><span class=cl>accszExk
</span></span><span class=line><span class=cl>acctuvwj
</span></span><span class=line><span class=cl>abdefghi
</span></span></code></pre></td></tr></table></div></div><p>Here, you start in the top-left corner; your goal is near the middle. You could start by moving down or right, but eventually you&rsquo;ll need to head toward the e at the bottom. From there, you can spiral around to the goal:</p><pre tabindex=0><code>v..v&lt;&lt;&lt;&lt;
&gt;v.vv&lt;&lt;^
.&gt;vv&gt;E^^
..v&gt;&gt;&gt;^^
..&gt;&gt;&gt;&gt;&gt;^
</code></pre><p>In the above diagram, the symbols indicate whether the path exits each square moving up (<code>^</code>), down (<code>v</code>), left (<code>&lt;</code>), or right (<code>></code>). The location that should get the best signal is still <code>E</code>, and <code>.</code> marks unvisited squares.</p><p>This path reaches the goal in <strong><code>31</code></strong> steps, the fewest possible.</p><p><strong>What is the fewest steps required to move from your current position to the location that should get the best signal?</strong></p></details><p>It&rsquo;s path finding time. Finding the shortest path is such a common coding puzzle I don&rsquo;t really have to explain much. The only interesting thing is that you can&rsquo;t move in any direction on the grid and can go to an elevation that is at most one higher than your current one.</p><p>As for the usual parsing, we can just convert <code>char</code> to <code>int</code> by casting:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=kt>int</span><span class=p>[][]</span> <span class=n>CreateGrid</span><span class=p>(</span><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>lines</span><span class=p>,</span> <span class=k>out</span> <span class=n>Point</span> <span class=n>start</span><span class=p>,</span> <span class=k>out</span> <span class=n>Point</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>startPoint</span> <span class=p>=</span> <span class=n>Point</span><span class=p>.</span><span class=n>Empty</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>endPoint</span> <span class=p>=</span> <span class=n>Point</span><span class=p>.</span><span class=n>Empty</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>grid</span> <span class=p>=</span> <span class=n>lines</span><span class=p>.</span><span class=n>Select</span><span class=p>((</span><span class=n>line</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>line</span><span class=p>.</span><span class=n>Select</span><span class=p>((</span><span class=n>c</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>switch</span> <span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=sc>&#39;S&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>startPoint</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=sc>&#39;E&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>endPoint</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>c</span> <span class=k>switch</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=sc>&#39;S&#39;</span> <span class=p>=&gt;</span> <span class=sc>&#39;a&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=sc>&#39;E&#39;</span> <span class=p>=&gt;</span> <span class=sc>&#39;z&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>_</span> <span class=p>=&gt;</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>c</span>
</span></span><span class=line><span class=cl>            <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=p>}).</span><span class=n>ToArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}).</span><span class=n>ToArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=p>=</span> <span class=n>startPoint</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=p>=</span> <span class=n>endPoint</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>grid</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>For moving, we can quickly create some small helper functions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=kt>bool</span> <span class=n>GetLeft</span><span class=p>(</span><span class=n>Point</span> <span class=n>current</span><span class=p>,</span> <span class=k>out</span> <span class=n>Point</span> <span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=p>=</span> <span class=n>current</span> <span class=n>with</span> <span class=p>{</span> <span class=n>X</span> <span class=p>=</span> <span class=n>current</span><span class=p>.</span><span class=n>X</span> <span class=p>-</span> <span class=m>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>left</span><span class=p>.</span><span class=n>X</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=kt>bool</span> <span class=n>GetRight</span><span class=p>(</span><span class=n>IReadOnlyList</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>[]&gt;</span> <span class=n>grid</span><span class=p>,</span> <span class=n>Point</span> <span class=n>current</span><span class=p>,</span> <span class=k>out</span> <span class=n>Point</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=p>=</span> <span class=n>current</span> <span class=n>with</span> <span class=p>{</span> <span class=n>X</span> <span class=p>=</span> <span class=n>current</span><span class=p>.</span><span class=n>X</span> <span class=p>+</span> <span class=m>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>right</span><span class=p>.</span><span class=n>X</span> <span class=p>&lt;</span> <span class=n>grid</span><span class=p>[</span><span class=m>0</span><span class=p>].</span><span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=kt>bool</span> <span class=n>GetUp</span><span class=p>(</span><span class=n>Point</span> <span class=n>current</span><span class=p>,</span> <span class=k>out</span> <span class=n>Point</span> <span class=n>up</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>up</span> <span class=p>=</span> <span class=n>current</span> <span class=n>with</span> <span class=p>{</span> <span class=n>Y</span> <span class=p>=</span> <span class=n>current</span><span class=p>.</span><span class=n>Y</span> <span class=p>-</span> <span class=m>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>up</span><span class=p>.</span><span class=n>Y</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=kt>bool</span> <span class=n>GetDown</span><span class=p>(</span><span class=n>IReadOnlyCollection</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>[]&gt;</span> <span class=n>grid</span><span class=p>,</span> <span class=n>Point</span> <span class=n>current</span><span class=p>,</span> <span class=k>out</span> <span class=n>Point</span> <span class=n>down</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>down</span> <span class=p>=</span> <span class=n>current</span> <span class=n>with</span> <span class=p>{</span> <span class=n>Y</span> <span class=p>=</span> <span class=n>current</span><span class=p>.</span><span class=n>Y</span> <span class=p>+</span> <span class=m>1</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>down</span><span class=p>.</span><span class=n>Y</span> <span class=p>&lt;</span> <span class=n>grid</span><span class=p>.</span><span class=n>Count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>As for the actual path finding, we obviously have to go with Dijkstra. It&rsquo;s the classic algorithm everyone learns in their data structures and algorithms class. Thankfully we don&rsquo;t have to implement any additional data types because .NET already comes with a <a href=https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.priorityqueue-2><code>PriorityQueue&lt;TElement,TPriority></code></a>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>Dijkstra</span><span class=p>(</span><span class=kt>int</span><span class=p>[][]</span> <span class=n>grid</span><span class=p>,</span> <span class=n>Point</span> <span class=n>start</span><span class=p>,</span> <span class=n>Point</span> <span class=n>end</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>partOne</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>distances</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Dictionary</span><span class=p>&lt;</span><span class=n>Point</span><span class=p>,</span> <span class=kt>int</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>queue</span> <span class=p>=</span> <span class=k>new</span> <span class=n>PriorityQueue</span><span class=p>&lt;</span><span class=n>Point</span><span class=p>,</span> <span class=kt>int</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=p>.</span><span class=n>Enqueue</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=m>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>queue</span><span class=p>.</span><span class=n>TryDequeue</span><span class=p>(</span><span class=k>out</span> <span class=kt>var</span> <span class=n>current</span><span class=p>,</span> <span class=k>out</span> <span class=kt>var</span> <span class=n>currentDistance</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>distances</span><span class=p>.</span><span class=n>ContainsKey</span><span class=p>(</span><span class=n>current</span><span class=p>))</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>distances</span><span class=p>[</span><span class=n>current</span><span class=p>]</span> <span class=p>=</span> <span class=n>currentDistance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>foundEnd</span> <span class=p>=</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>void</span> <span class=n>CheckNeighbor</span><span class=p>(</span><span class=n>Point</span> <span class=n>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//...</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>GetLeft</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=k>out</span> <span class=kt>var</span> <span class=n>left</span><span class=p>))</span> <span class=n>CheckNeighbor</span><span class=p>(</span><span class=n>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>GetRight</span><span class=p>(</span><span class=n>grid</span><span class=p>,</span> <span class=n>current</span><span class=p>,</span> <span class=k>out</span> <span class=kt>var</span> <span class=n>right</span><span class=p>))</span> <span class=n>CheckNeighbor</span><span class=p>(</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>GetUp</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=k>out</span> <span class=kt>var</span> <span class=n>up</span><span class=p>))</span> <span class=n>CheckNeighbor</span><span class=p>(</span><span class=n>up</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>GetDown</span><span class=p>(</span><span class=n>grid</span><span class=p>,</span> <span class=n>current</span><span class=p>,</span> <span class=k>out</span> <span class=kt>var</span> <span class=n>down</span><span class=p>))</span> <span class=n>CheckNeighbor</span><span class=p>(</span><span class=n>down</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>foundEnd</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distances</span><span class=p>[</span><span class=n>end</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The only interesting thing in this code is the use of the inline function <code>CheckNeighbor</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>void</span> <span class=n>CheckNeighbor</span><span class=p>(</span><span class=n>Point</span> <span class=n>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>currentValue</span> <span class=p>=</span> <span class=n>grid</span><span class=p>[</span><span class=n>current</span><span class=p>.</span><span class=n>Y</span><span class=p>][</span><span class=n>current</span><span class=p>.</span><span class=n>X</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>neighborValue</span> <span class=p>=</span> <span class=n>grid</span><span class=p>[</span><span class=n>neighbor</span><span class=p>.</span><span class=n>Y</span><span class=p>][</span><span class=n>neighbor</span><span class=p>.</span><span class=n>X</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>neighborValue</span> <span class=p>-</span> <span class=n>currentValue</span> <span class=p>&gt;</span> <span class=m>1</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>newDistance</span> <span class=p>=</span> <span class=n>currentDistance</span> <span class=p>+</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>neighbor</span> <span class=p>==</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>distances</span><span class=p>[</span><span class=n>end</span><span class=p>]</span> <span class=p>=</span> <span class=n>newDistance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>foundEnd</span> <span class=p>=</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=p>.</span><span class=n>Enqueue</span><span class=p>(</span><span class=n>neighbor</span><span class=p>,</span> <span class=n>newDistance</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This is basically it. It&rsquo;s just Dijkstra but without actually getting the path, we just need the amount of steps.</p><h2 id=part-two>Part Two<a hidden class=anchor aria-hidden=true href=#part-two>#</a></h2><details><summary>Description</summary><p>As you walk up the hill, you suspect that the Elves will want to turn this into a hiking trail. The beginning isn&rsquo;t very scenic, though; perhaps you can find a better starting point.</p><p>To maximize exercise while hiking, the trail should start as low as possible: elevation <code>a</code>. The goal is still the square marked <code>E</code>. However, the trail should still be direct, taking the fewest steps to reach its goal. So, you&rsquo;ll need to find the shortest path from <strong>any square at elevation <code>a</code></strong> to the square marked <code>E</code>.</p><p>Again consider the example from above:</p><pre tabindex=0><code>Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
</code></pre><p>Now, there are six choices for starting position (five marked <code>a</code>, plus the square marked <code>S</code> that counts as being at elevation <code>a</code>). If you start at the bottom-left square, you can reach the goal most quickly:</p><pre tabindex=0><code>...v&lt;&lt;&lt;&lt;
...vv&lt;&lt;^
...v&gt;E^^
.&gt;v&gt;&gt;&gt;^^
&gt;^&gt;&gt;&gt;&gt;&gt;^
</code></pre><p>This path reaches the goal in only <strong><code>29</code></strong> steps, the fewest possible.</p><p><strong>What is the fewest steps required to move starting from any square with elevation a to the location that should get the best signal?</strong></p></details><p>Part two looks more complex than it is. We want the shortest path from any square with at elevation <code>a</code> to the end point. You could brute force this by doing the same thing as before but with every square at elevation <code>a</code>, or we can just use the end point as the start point:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>void</span> <span class=n>CheckNeighbor</span><span class=p>(</span><span class=n>Point</span> <span class=n>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>currentValue</span> <span class=p>=</span> <span class=n>grid</span><span class=p>[</span><span class=n>current</span><span class=p>.</span><span class=n>Y</span><span class=p>][</span><span class=n>current</span><span class=p>.</span><span class=n>X</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>neighborValue</span> <span class=p>=</span> <span class=n>grid</span><span class=p>[</span><span class=n>neighbor</span><span class=p>.</span><span class=n>Y</span><span class=p>][</span><span class=n>neighbor</span><span class=p>.</span><span class=n>X</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>partOne</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=k>true</span> <span class=n>when</span> <span class=n>neighborValue</span> <span class=p>-</span> <span class=n>currentValue</span> <span class=p>&gt;</span> <span class=m>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=k>false</span> <span class=n>when</span> <span class=n>currentValue</span> <span class=p>-</span> <span class=n>neighborValue</span> <span class=p>&gt;</span> <span class=m>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>newDistance</span> <span class=p>=</span> <span class=n>currentDistance</span> <span class=p>+</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>partOne</span> <span class=p>&amp;&amp;</span> <span class=n>neighbor</span> <span class=p>==</span> <span class=n>end</span> <span class=p>||</span> <span class=p>!</span><span class=n>partOne</span> <span class=p>&amp;&amp;</span> <span class=n>neighborValue</span> <span class=p>==</span> <span class=sc>&#39;a&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>distances</span><span class=p>[</span><span class=n>end</span><span class=p>]</span> <span class=p>=</span> <span class=n>newDistance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>foundEnd</span> <span class=p>=</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=p>.</span><span class=n>Enqueue</span><span class=p>(</span><span class=n>neighbor</span><span class=p>,</span> <span class=n>newDistance</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>With this we don&rsquo;t have to pass an end point. The end point is just <strong>any</strong> point with elevation <code>a</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>var</span> <span class=n>partOne</span> <span class=p>=</span> <span class=n>Dijkstra</span><span class=p>(</span><span class=n>grid</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=k>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>partTwo</span> <span class=p>=</span> <span class=n>Dijkstra</span><span class=p>(</span><span class=n>grid</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>Point</span><span class=p>.</span><span class=n>Empty</span><span class=p>,</span> <span class=k>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Part One - Steps needed: {partOne}&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Part Two - Steps needed: {partTwo}&#34;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>It&rsquo;s a path finding puzzle, there was bound to be one, and now it happened. This puzzle only serves to remind you that Dijkstra is a thing, and you should use it. There is nothing hard about this and if you know the algorithm, you can do solve in your sleep.</p><figure class=align-center><img loading=lazy src=https://i.redd.it/hyansz5q3f5a1.png#center alt="Is my input invalid or..."><figcaption><p><a href=https://www.reddit.com/r/adventofcode/comments/zjqz5y/2022_day_12_is_my_input_invalid_or/>https://www.reddit.com/r/adventofcode/comments/zjqz5y/2022_day_12_is_my_input_invalid_or/</a></p></figcaption></figure><figure class=align-center><img loading=lazy src=https://i.redd.it/v0x6gph20f5a1.png#center alt="Apparently long fall boots are standard equipments for elves"><figcaption><p><a href=https://www.reddit.com/r/adventofcode/comments/zjqjqb/2022_day_12_apparently_long_fall_boots_are/>https://www.reddit.com/r/adventofcode/comments/zjqjqb/2022_day_12_apparently_long_fall_boots_are/</a></p></figcaption></figure><figure class=align-center><img loading=lazy src=https://i.redd.it/xgcqsebqte5a1.jpg#center alt="It's that time of the year again"><figcaption><p><a href=https://www.reddit.com/r/adventofcode/comments/zjpp38/2022_day_12_its_that_time_of_the_year_again/>https://www.reddit.com/r/adventofcode/comments/zjpp38/2022_day_12_its_that_time_of_the_year_again/</a></p></figcaption></figure></div><footer class=post-footer><ul class=post-tags><li><a href=https://erri120.github.io/tags/advent-of-code-2022/>Advent of Code 2022</a></li><li><a href=https://erri120.github.io/tags/c#/>C#</a></li></ul><nav class=paginav><a class=next href=https://erri120.github.io/posts/2022-12-11/><span class=title>Next »</span><br><span>Advent of Code 2022: Day 11</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2022: Day 12 on twitter" href="https://twitter.com/intent/tweet/?text=Advent%20of%20Code%202022%3a%20Day%2012&url=https%3a%2f%2ferri120.github.io%2fposts%2f2022-12-12%2f&hashtags=AdventofCode2022%2cC%23"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2022: Day 12 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ferri120.github.io%2fposts%2f2022-12-12%2f&title=Advent%20of%20Code%202022%3a%20Day%2012"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=erri120/erri120.github.io issue-term=pathname label=site-comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://erri120.github.io>erri120's random Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>